COMMIT_HASH:f5d111117ddc0f4d83a1bad34d61b857681b6720|AUTHOR_NAME:Chrismelba-Instaclustr|AUTHOR_EMAIL:78569435+Chrismelba-Instaclustr@users.noreply.github.com|DATE:2024-08-23 01:10:56 +1000|TITLE:Updated readme to show that Instaclustr now supports pg_cron (#348)|MESSAGE:Co-authored-by: Chris Carter <chrismelba@gmail.com>
Co-authored-by: Marco Slot <marco.slot@gmail.com>
diff --git a/README.md b/README.md
index 2ea8824..dc952d8 100644
--- a/README.md
+++ b/README.md
@@ -216,14 +216,14 @@ The following table keeps track of which of the major managed Postgres services
 | [Crunchy Bridge](https://www.crunchydata.com/products/crunchy-bridge/?ref=producthunt) | :heavy_check_mark: |
 | [DigitalOcean](https://www.digitalocean.com/products/managed-databases/) | :heavy_check_mark: |
 | [Google Cloud](https://cloud.google.com/sql/postgresql/) | :heavy_check_mark: |
-| [Heroku](https://elements.heroku.com/addons/heroku-postgresql) | :x: | |
+| [Heroku](https://elements.heroku.com/addons/heroku-postgresql) | :x: | 
+| [Instaclustr](https://instaclustr.com) | :heavy_check_mark:  |
 | [ScaleGrid](https://scalegrid.io/postgresql.html) | :heavy_check_mark:  |
 | [Scaleway](https://www.scaleway.com/en/database/) | :heavy_check_mark:  |
 | [Supabase](https://supabase.io/docs/guides/database) | :heavy_check_mark:  |
 | [Tembo](https://tembo.io) | :heavy_check_mark:  |
 | [YugabyteDB](https://www.yugabyte.com/) | :heavy_check_mark:  |
 
-
 ## Code of Conduct
 
 This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.

COMMIT_HASH:f6ab30eb129c3d9c6f9d0a36f53cb7c784eb90be|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-08-22 15:32:56 +0200|TITLE:Merge pull request #330 from hari90/AddYugabyte|MESSAGE:Add YugabyteDB to list of supported services
COMMIT_HASH:3a314861c523a6ebdd9e948a90645034cd085d29|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-08-22 12:03:08 +0200|TITLE:Add bounds checks on step size|MESSAGE:
diff --git a/.gitignore b/.gitignore
index 37bbe0d..1c5d255 100644
--- a/.gitignore
+++ b/.gitignore
@@ -42,3 +42,7 @@ pg_cron--?.?.sql
 log/
 results/
 src/*.bc
+
+regression.diffs
+regression.out
+tmp_check/
diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index d79d542..96f2766 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -54,6 +54,28 @@ HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
 SELECT cron.schedule('50 seconds c', 'SELECT 1'); 
 ERROR:  invalid schedule: 50 seconds c
 HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
+-- Invalid input: step out of range
+SELECT cron.schedule('*/0 10 * * *', 'SELECT 1');
+ERROR:  invalid schedule: */0 10 * * *
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
+SELECT cron.schedule('-1 * * * *', 'SELECT 1');
+ERROR:  invalid schedule: -1 * * * *
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
+SELECT cron.schedule('*/-1 10 * * *', 'SELECT 1');
+ERROR:  invalid schedule: */-1 10 * * *
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
+SELECT cron.schedule('*/60 10 * * *', 'SELECT 1');
+ERROR:  invalid schedule: */60 10 * * *
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
+SELECT cron.schedule('* * * 13 *', 'SELECT 1');
+ERROR:  invalid schedule: * * * 13 *
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
+SELECT cron.schedule('* * * 0 *', 'SELECT 1');
+ERROR:  invalid schedule: * * * 0 *
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
+SELECT cron.schedule('*/5000000000 10 * * *', 'SELECT 1');
+ERROR:  invalid schedule: */5000000000 10 * * *
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
 -- Invalid input: seconds out of range
 SELECT cron.schedule('-1 seconds', 'SELECT 1'); 
 ERROR:  invalid schedule: -1 seconds
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index 45f94d9..f816833 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -29,6 +29,15 @@ SELECT cron.schedule('* * * *', 'SELECT 1');
 SELECT cron.schedule('5 secondc', 'SELECT 1'); 
 SELECT cron.schedule('50 seconds c', 'SELECT 1'); 
 
+-- Invalid input: step out of range
+SELECT cron.schedule('*/0 10 * * *', 'SELECT 1');
+SELECT cron.schedule('-1 * * * *', 'SELECT 1');
+SELECT cron.schedule('*/-1 10 * * *', 'SELECT 1');
+SELECT cron.schedule('*/60 10 * * *', 'SELECT 1');
+SELECT cron.schedule('* * * 13 *', 'SELECT 1');
+SELECT cron.schedule('* * * 0 *', 'SELECT 1');
+SELECT cron.schedule('*/5000000000 10 * * *', 'SELECT 1');
+
 -- Invalid input: seconds out of range
 SELECT cron.schedule('-1 seconds', 'SELECT 1'); 
 SELECT cron.schedule('0 seconds', 'SELECT 1'); 

COMMIT_HASH:5c10a8a24527b79c301eaeb04317846f2426dcd5|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-08-22 11:59:14 +0200|TITLE:Fix possible buffer underflow issue in cron parsing|MESSAGE:
diff --git a/src/entry.c b/src/entry.c
index 9bb57cc..c39aeaa 100644
--- a/src/entry.c
+++ b/src/entry.c
@@ -409,7 +409,8 @@ get_range(bitstr_t *bits, int low, int high, char *names[], int ch, FILE *file)
 	 * Code adapted from set_elements() where this error was probably intended
 	 * to be catched.
 	 */
-	if (num1 < low || num1 > high || num2 < low || num2 > high)
+	if (num1 < low || num1 > high || num2 < low || num2 > high ||
+		num3 < 0 || num3 > high)
 		return EOF;
 
 	/* range. set all elements from num1 to num2, stepping
@@ -508,7 +509,7 @@ set_range(bitstr_t *bits, int low, int high, int start, int stop, int step) {
 	Debug(DPARS|DEXT, ("set_range(?,%d,%d,%d,%d,%d)\n",
 			   low, high, start, stop, step))
 
-	if (start < low || stop > high)
+	if (start < low || stop > high || step <= 0)
 		return EOF;
 	start -= low;
 	stop -= low;

COMMIT_HASH:9490f9cc9803f75105f2f7d89839a998f011f8d8|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-08-09 14:58:03 +0200|TITLE:Revert "Remove unnecessary lastStartTime reset"|MESSAGE:This reverts commit d90843de92d5e517a23b1e17da56dc08c496c774.

diff --git a/src/pg_cron.c b/src/pg_cron.c
index 25b04b6..16b8eb8 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -1542,6 +1542,8 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				break;
 			}
 
+			task->lastStartTime = GetCurrentTimestamp();
+
 			if (CronLogRun)
 				UpdateJobRunDetail(task->runId, &pid, GetCronStatus(CRON_STATUS_RUNNING), NULL, &task->lastStartTime, NULL);
 
@@ -1655,6 +1657,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				task->startDeadline = 0;
 				task->state = CRON_TASK_RUNNING;
 
+				task->lastStartTime = GetCurrentTimestamp();
 				if (CronLogRun)
 					UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_RUNNING), NULL, &task->lastStartTime, NULL);
 			}

COMMIT_HASH:14bfd0b9a45e93ee50752816836e4b4e663d1420|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-08-09 14:57:32 +0200|TITLE:Merge pull request #347 from citusdata/compat/1.4|MESSAGE:Select procedure based on argument type of cron_unschedule_named
COMMIT_HASH:bd0196a86434ffba9de90b0c08d34e27170d5f71|AUTHOR_NAME:Alexander Kukushkin|AUTHOR_EMAIL:cyberdemn@gmail.com|DATE:2024-08-09 13:46:03 +0200|TITLE:Select procedure based on argument type of cron_unschedule_named|MESSAGE:The #299 PR took care of bacward compatibility of the function, but
there is still one problem left. If extension isn't updated type of the
jobname field in the cron.job table is still NAME, and as a result scan
was failing to find rows and unschedule a named job.

This fix is relying on the fact that SQL API of the unschedule()
function is updated consistently with the cron.job table definition.

diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index 6a48f4e..d79d542 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -9,6 +9,18 @@ SELECT extversion FROM pg_extension WHERE extname='pg_cron';
 ALTER EXTENSION pg_cron UPDATE TO '1.4';
 SELECT cron.unschedule(job_name := 'no_such_job');
 ERROR:  could not find valid entry for job 'no_such_job'
+SELECT cron.schedule('testjob', '* * * * *', 'SELECT 1');
+ schedule 
+----------
+        1
+(1 row)
+
+SELECT cron.unschedule('testjob');
+ unschedule 
+------------
+ t
+(1 row)
+
 -- Test cache invalidation
 DROP EXTENSION pg_cron;
 CREATE EXTENSION pg_cron VERSION '1.4';
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index ce2511b..45f94d9 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -3,6 +3,8 @@ SELECT extversion FROM pg_extension WHERE extname='pg_cron';
 -- Test binary compatibility with v1.4 function signature.
 ALTER EXTENSION pg_cron UPDATE TO '1.4';
 SELECT cron.unschedule(job_name := 'no_such_job');
+SELECT cron.schedule('testjob', '* * * * *', 'SELECT 1');
+SELECT cron.unschedule('testjob');
 
 -- Test cache invalidation
 DROP EXTENSION pg_cron;
diff --git a/src/job_metadata.c b/src/job_metadata.c
index be6da36..d831a1b 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -674,8 +674,9 @@ cron_unschedule(PG_FUNCTION_ARGS)
 Datum
 cron_unschedule_named(PG_FUNCTION_ARGS)
 {
-	Datum jobNameDatum = 0;
+	Datum jobNameDatum = PG_GETARG_DATUM(0);
 	char *jobName = NULL;
+	RegProcedure procedure;
 
 	Oid userId = GetUserId();
 	char *userName = GetUserNameFromId(userId, false);
@@ -699,19 +700,19 @@ cron_unschedule_named(PG_FUNCTION_ARGS)
 	 */
 	if (get_fn_expr_argtype(fcinfo->flinfo, 0) == NAMEOID)
 	{
-		jobName = NameStr(*PG_GETARG_NAME(0));
-		jobNameDatum = CStringGetTextDatum(jobName);
+		procedure = F_NAMEEQ;
+		jobName = NameStr(*DatumGetName(jobNameDatum));
 	}
 	else
 	{
-		jobNameDatum = PG_GETARG_DATUM(0);
+		procedure = F_TEXTEQ;
 		jobName = TextDatumGetCString(jobNameDatum);
 	}
 
 	cronJobsTable = table_open(CronJobRelationId(), RowExclusiveLock);
 
 	ScanKeyInit(&scanKey[0], Anum_cron_job_jobname,
-				BTEqualStrategyNumber, F_TEXTEQ, jobNameDatum);
+				BTEqualStrategyNumber, procedure, jobNameDatum);
 	ScanKeyInit(&scanKey[1], Anum_cron_job_username,
 				BTEqualStrategyNumber, F_TEXTEQ, userNameDatum);
 

COMMIT_HASH:e5eb77e8634cb41b2b16e71c6320cfe637ec3043|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-08-09 11:58:32 +0200|TITLE:Merge pull request #346 from citusdata/bugfix/job-cache-invalidation|MESSAGE:Fix bug with invalidation of CachedCronJobRelationId
COMMIT_HASH:a666e11933233d5d5fc2a6735f655b60e2581b16|AUTHOR_NAME:Alexander Kukushkin|AUTHOR_EMAIL:cyberdemn@gmail.com|DATE:2024-08-09 10:01:06 +0200|TITLE:Fix bug with invalidation of CachedCronJobRelationId|MESSAGE:The callback was registered only for bgworker and as a result client
backends were failing to unschedule jobs if the extension was droped and
recreated in the same session:
```
CREATE EXTENSION pg_cron;
SELECT cron.schedule('0 10 * * *', 'VACUUM');
SELECT cron.unschedule(1);
DROP EXTENSION pg_cron;
CREATE EXTENSION pg_cron;
SELECT cron.schedule('0 10 * * *', 'VACUUM');
SELECT cron.unschedule(1);
ERROR:  could not open relation with OID 16388
```

diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index 9c1878d..6a48f4e 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -9,6 +9,9 @@ SELECT extversion FROM pg_extension WHERE extname='pg_cron';
 ALTER EXTENSION pg_cron UPDATE TO '1.4';
 SELECT cron.unschedule(job_name := 'no_such_job');
 ERROR:  could not find valid entry for job 'no_such_job'
+-- Test cache invalidation
+DROP EXTENSION pg_cron;
+CREATE EXTENSION pg_cron VERSION '1.4';
 ALTER EXTENSION pg_cron UPDATE;
 -- Vacuum every day at 10:00am (GMT)
 SELECT cron.schedule('0 10 * * *', 'VACUUM');
diff --git a/include/job_metadata.h b/include/job_metadata.h
index 16a782a..e89b19b 100644
--- a/include/job_metadata.h
+++ b/include/job_metadata.h
@@ -62,4 +62,6 @@ extern int64 NextRunId(void);
 extern void MarkPendingRunsAsFailed(void);
 extern char *GetCronStatus(CronStatus cronstatus);
 
+extern void InvalidateJobCacheCallback(Datum argument, Oid relationId);
+
 #endif
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index fc865ec..ce2511b 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -3,6 +3,11 @@ SELECT extversion FROM pg_extension WHERE extname='pg_cron';
 -- Test binary compatibility with v1.4 function signature.
 ALTER EXTENSION pg_cron UPDATE TO '1.4';
 SELECT cron.unschedule(job_name := 'no_such_job');
+
+-- Test cache invalidation
+DROP EXTENSION pg_cron;
+CREATE EXTENSION pg_cron VERSION '1.4';
+
 ALTER EXTENSION pg_cron UPDATE;
 
 -- Vacuum every day at 10:00am (GMT)
diff --git a/src/job_metadata.c b/src/job_metadata.c
index dd7b6f0..be6da36 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -79,7 +79,6 @@ static int64 ScheduleCronJob(text *scheduleText, text *commandText,
 								bool active, text *jobnameText);
 static Oid CronExtensionOwner(void);
 static void EnsureDeletePermission(Relation cronJobsTable, HeapTuple heapTuple);
-static void InvalidateJobCacheCallback(Datum argument, Oid relationId);
 static void InvalidateJobCache(void);
 static Oid CronJobRelationId(void);
 
@@ -121,9 +120,6 @@ bool EnableSuperuserJobs = true;
 void
 InitializeJobMetadataCache(void)
 {
-	/* watch for invalidation events */
-	CacheRegisterRelcacheCallback(InvalidateJobCacheCallback, (Datum) 0);
-
 	CronJobContext = AllocSetContextCreate(CurrentMemoryContext,
 											 "pg_cron job context",
 											 ALLOCSET_DEFAULT_MINSIZE,
@@ -820,7 +816,7 @@ InvalidateJobCache(void)
  * InvalidateJobCacheCallback invalidates the job cache in response to
  * an invalidation event.
  */
-static void
+void
 InvalidateJobCacheCallback(Datum argument, Oid relationId)
 {
 	if (relationId == CachedCronJobRelationId ||
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 64d3a7c..25b04b6 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -208,6 +208,9 @@ _PG_init(void)
 								"configuration variable in postgresql.conf.")));
 	}
 
+	/* watch for invalidation events */
+	CacheRegisterRelcacheCallback(InvalidateJobCacheCallback, (Datum) 0);
+
 	DefineCustomStringVariable(
 		"cron.database_name",
 		gettext_noop("Database in which pg_cron metadata is kept."),

COMMIT_HASH:9d0576c64edd90fb3d8ac30763296a8106315638|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-06-17 13:25:01 +0200|TITLE:Merge pull request #317 from japinli/illumos|MESSAGE:Fix compiler error on Illumos
COMMIT_HASH:9f73333ed49f2be55084c2584cd893d56d941257|AUTHOR_NAME:Japin Li|AUTHOR_EMAIL:japinli@hotmail.com|DATE:2024-06-17 10:55:55 +0800|TITLE:Disable sign compare on illumos|MESSAGE:On illumos, the UINT8_MAX is defined as 255U, see:
https://github.com/illumos/illumos-gate/blob/master/usr/src/uts/common/sys/int_limits.h#L92

diff --git a/Makefile b/Makefile
index 254fcd3..c139cac 100644
--- a/Makefile
+++ b/Makefile
@@ -17,7 +17,7 @@ else
     PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-implicit-fallthrough -Iinclude -I$(libpq_srcdir)
 endif
 ifeq ($(shell uname -s),SunOS)
-    PG_CPPFLAGS += -D__EXTENSIONS__
+    PG_CPPFLAGS += -Wno-sign-compare -D__EXTENSIONS__
 endif
 SHLIB_LINK = $(libpq)
 EXTRA_CLEAN += $(addprefix src/,*.gcno *.gcda) # clean up after profiling runs

COMMIT_HASH:d3caa46cc60a9c16430f5fc7085b7a9538a89a81|AUTHOR_NAME:Japin Li|AUTHOR_EMAIL:japinli@hotmail.com|DATE:2024-06-17 10:49:22 +0800|TITLE:Fix unknown type name 'sigjmp_buf'|MESSAGE:On illumos, the sigjmp_buf is defined under the following macros:

    !defined(_STRICT_STDC) || defined(__XOPEN_OR_POSIX) || \
        defined(__EXTENSIONS__)

https://github.com/illumos/illumos-gate/blob/master/usr/src/head/setjmp.h#L50-L58

diff --git a/Makefile b/Makefile
index 053314c..254fcd3 100644
--- a/Makefile
+++ b/Makefile
@@ -16,6 +16,9 @@ ifeq ($(CC),gcc)
 else
     PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-implicit-fallthrough -Iinclude -I$(libpq_srcdir)
 endif
+ifeq ($(shell uname -s),SunOS)
+    PG_CPPFLAGS += -D__EXTENSIONS__
+endif
 SHLIB_LINK = $(libpq)
 EXTRA_CLEAN += $(addprefix src/,*.gcno *.gcda) # clean up after profiling runs
 

COMMIT_HASH:e2a6143b706f8a36a24442c8af99ed1f58704d68|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-05-31 20:59:06 +0200|TITLE:Merge pull request #332 from esiaero/main|MESSAGE:Replace MemoryContextResetAndDeleteChildren macro with MemoryContextReset for PG 17 compatibility
COMMIT_HASH:a8df8a9265e348b8518c5d1e0b2dfd7878726d25|AUTHOR_NAME:Evan Si|AUTHOR_EMAIL:evsi@amazon.com|DATE:2024-05-31 17:30:29 +0000|TITLE:Replace MemoryContextResetAndDeleteChildren macro with MemoryContextReset|MESSAGE:MemoryContextResetAndDeleteChildren will be retired in the upcoming PG 17 [0].
It has been equivalent to MemoryContextReset since PG 9.5 [1]. The reference to
MemoryContextResetAndDeleteChildren is thus replaced by MemoryContextReset for
compatibility purposes.

[0] https://github.com/postgres/postgres/commit/6a72c42fd5af7ada49584694f543eb0

[1] https://github.com/postgres/postgres/commit/eaa5808e8ec4e82ce1a87103a6b6f68

diff --git a/src/job_metadata.c b/src/job_metadata.c
index fdc8805..dd7b6f0 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -141,7 +141,7 @@ InitializeJobMetadataCache(void)
 void
 ResetJobMetadataCache(void)
 {
-	MemoryContextResetAndDeleteChildren(CronJobContext);
+	MemoryContextReset(CronJobContext);
 
 	CronJobHash = CreateCronJobHash();
 }

COMMIT_HASH:a77fb1b4799436db2081a100a4eeaadce5019f73|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-05-28 15:32:10 +0200|TITLE:Merge pull request #331 from ryw/patch-1|MESSAGE:Make it easier to find the query to see all scheduled jobs
COMMIT_HASH:805c6aaecbdeb99bc789f41bd7075a4621b292cf|AUTHOR_NAME:Ry Walker|AUTHOR_EMAIL:4283+ryw@users.noreply.github.com|DATE:2024-05-28 09:26:28 -0400|TITLE:Make it easier to find the query to see all scheduled jobs|MESSAGE:
diff --git a/README.md b/README.md
index da2a13a..3570a3e 100644
--- a/README.md
+++ b/README.md
@@ -158,6 +158,11 @@ max_worker_processes = 20
 
 For security, jobs are executed in the database in which the `cron.schedule` function is called with the same permissions as the current user. In addition, users are only able to see their own jobs in the `cron.job` table.
 
+```sql
+-- View active jobs
+select * from cron.job;
+```
+
 ## Viewing job run details
 
 You can view the status of running and recently completed job runs in the `cron.job_run_details`:

COMMIT_HASH:f7c58270de43ce60cbe4e34350c7ed614230410c|AUTHOR_NAME:Hari Krishna Sunder|AUTHOR_EMAIL:hari90@users.noreply.github.com|DATE:2024-05-25 09:52:40 -0700|TITLE:Add YugabyteDB to list of supported services|MESSAGE:
diff --git a/README.md b/README.md
index da2a13a..191453a 100644
--- a/README.md
+++ b/README.md
@@ -216,6 +216,7 @@ The following table keeps track of which of the major managed Postgres services
 | [Scaleway](https://www.scaleway.com/en/database/) | :heavy_check_mark:  |
 | [Supabase](https://supabase.io/docs/guides/database) | :heavy_check_mark:  |
 | [Tembo](https://tembo.io) | :heavy_check_mark:  |
+| [YugabyteDB](https://www.yugabyte.com/) | :heavy_check_mark:  |
 
 
 ## Code of Conduct

COMMIT_HASH:d90843de92d5e517a23b1e17da56dc08c496c774|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-05-17 10:31:55 +0200|TITLE:Remove unnecessary lastStartTime reset|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 5137c8b..64d3a7c 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -1539,8 +1539,6 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				break;
 			}
 
-			task->lastStartTime = GetCurrentTimestamp();
-
 			if (CronLogRun)
 				UpdateJobRunDetail(task->runId, &pid, GetCronStatus(CRON_STATUS_RUNNING), NULL, &task->lastStartTime, NULL);
 
@@ -1654,7 +1652,6 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				task->startDeadline = 0;
 				task->state = CRON_TASK_RUNNING;
 
-				task->lastStartTime = GetCurrentTimestamp();
 				if (CronLogRun)
 					UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_RUNNING), NULL, &task->lastStartTime, NULL);
 			}

COMMIT_HASH:9a5324dfee6a961d3dc21b95737385c22c3ed57a|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-05-17 10:30:52 +0200|TITLE:Merge pull request #324 from kketch/kketch/start-time-for-all-failed-runs|MESSAGE:Log start & end time for all failed runs
COMMIT_HASH:e7996b66ab64b4cce97431bc2e54225c47215ca4|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-05-17 10:22:45 +0200|TITLE:Merge pull request #326 from sminux/fix_unget_data_overflow|MESSAGE:Fixes #311
COMMIT_HASH:51c0f64848cbd3d8b7803b9a7dee5cb1ecd71c31|AUTHOR_NAME:sminux|AUTHOR_EMAIL:espin55@yandex.ru|DATE:2024-05-05 23:43:43 +0300|TITLE:Make limit in condition up to 1000|MESSAGE:
diff --git a/src/misc.c b/src/misc.c
index a3ac06c..ac7d9a4 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -85,7 +85,7 @@ unget_char(int ch, FILE *file)
 	 */
 	file_buffer *buffer = (file_buffer *) file;
 
-	if (buffer->unget_count >= 1024)
+	if (buffer->unget_count >= 1000)
 	{	
 		perror("ungetc limit exceeded");
 		exit(ERROR_EXIT);

COMMIT_HASH:a30a1a050af8b9c6c56fa77d16445c47b70d5c67|AUTHOR_NAME:kketch|AUTHOR_EMAIL:wennerkevin@gmail.com|DATE:2024-04-23 21:37:50 +0200|TITLE:log start & end time for all failed runs|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 8d575ff..5137c8b 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -1283,7 +1283,6 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 	CronJob *cronJob = GetCronJob(jobId);
 	PGconn *connection = task->connection;
 	ConnStatusType connectionStatus = CONNECTION_BAD;
-	TimestampTz start_time;
 
 	switch (checkState)
 	{
@@ -1540,10 +1539,10 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				break;
 			}
 
-			start_time = GetCurrentTimestamp();
+			task->lastStartTime = GetCurrentTimestamp();
 
 			if (CronLogRun)
-				UpdateJobRunDetail(task->runId, &pid, GetCronStatus(CRON_STATUS_RUNNING), NULL, &start_time, NULL);
+				UpdateJobRunDetail(task->runId, &pid, GetCronStatus(CRON_STATUS_RUNNING), NULL, &task->lastStartTime, NULL);
 
 			task->state = CRON_TASK_BGW_RUNNING;
 			break;
@@ -1655,9 +1654,9 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				task->startDeadline = 0;
 				task->state = CRON_TASK_RUNNING;
 
-				start_time = GetCurrentTimestamp();
+				task->lastStartTime = GetCurrentTimestamp();
 				if (CronLogRun)
-					UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_RUNNING), NULL, &start_time, NULL);
+					UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_RUNNING), NULL, &task->lastStartTime, NULL);
 			}
 			else
 			{
@@ -1777,8 +1776,10 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 			if (task->errorMessage != NULL)
 			{
-				if (CronLogRun)
-					UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_FAILED), task->errorMessage, NULL, NULL);
+				if (CronLogRun) {
+					TimestampTz end_time = GetCurrentTimestamp();
+					UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_FAILED), task->errorMessage, &task->lastStartTime, &end_time);
+				}
 
 				ereport(LOG, (errmsg("cron job " INT64_FORMAT " %s",
 									 jobId, task->errorMessage)));

COMMIT_HASH:7e91e72b1bebc5869bb900d9253cc9e92518b33f|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-04-05 16:55:15 +0200|TITLE:Merge pull request #319 from Ngalstyan4/narek/fix-drop-database-deadlock|MESSAGE:Allow interrupts in pg_cron launcher loop to avoid deadlock
COMMIT_HASH:19f8ebf9349b6a3642e81a4d19dd0ea967d3f357|AUTHOR_NAME:Narek Galstyan|AUTHOR_EMAIL:narekg@berkeley.edu|DATE:2024-04-01 19:46:36 +0000|TITLE:Allow interrupts in pg_cron launcher loop to avoid deadlock|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 094fb70..8d575ff 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -631,6 +631,8 @@ PgCronLauncherMain(Datum arg)
 		List *taskList = NIL;
 		TimestampTz currentTime = 0;
 
+		CHECK_FOR_INTERRUPTS();
+
 		AcceptInvalidationMessages();
 
 		if (CronReloadConfig)

COMMIT_HASH:2a1d3113f58306870fd9aa970e61e54284795917|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-02-06 22:06:59 +0100|TITLE:Merge pull request #310 from ryw/main|MESSAGE:Add Tembo to list of managed clouds
COMMIT_HASH:61732335e948e29207cd8f261e5457f50ccde441|AUTHOR_NAME:Ry Walker|AUTHOR_EMAIL:4283+ryw@users.noreply.github.com|DATE:2024-02-06 15:53:17 -0500|TITLE:Add Tembo to list of managed clouds|MESSAGE:
diff --git a/README.md b/README.md
index e6cdd4b..da2a13a 100644
--- a/README.md
+++ b/README.md
@@ -215,6 +215,7 @@ The following table keeps track of which of the major managed Postgres services
 | [ScaleGrid](https://scalegrid.io/postgresql.html) | :heavy_check_mark:  |
 | [Scaleway](https://www.scaleway.com/en/database/) | :heavy_check_mark:  |
 | [Supabase](https://supabase.io/docs/guides/database) | :heavy_check_mark:  |
+| [Tembo](https://tembo.io) | :heavy_check_mark:  |
 
 
 ## Code of Conduct

COMMIT_HASH:d6f841cc9bfe98f4ee902acb0a329aef45617dca|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2024-01-05 23:51:07 +0100|TITLE:Merge pull request #299 from nmisch/compat1.4|MESSAGE:Make cron_unschedule_named() accept v1.4 SQL signature.
COMMIT_HASH:afd1d142ecb00628b724941e65fe0b33cbc0a4a6|AUTHOR_NAME:Noah Misch|AUTHOR_EMAIL:nmisch@google.com|DATE:2023-12-18 17:43:45 -0800|TITLE:Make cron_unschedule_named() accept v1.4 SQL signature.|MESSAGE:The PostgreSQL-recommended way to handle this would have been to
introduce a new C symbol for the new signature.  It's too late for that,
so use get_fn_expr_argtype() to discover the caller's expectations.
Fixes https://github.com/citusdata/pg_cron/issues/267.

diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index f2e2b90..9c1878d 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -5,6 +5,10 @@ SELECT extversion FROM pg_extension WHERE extname='pg_cron';
  1.0
 (1 row)
 
+-- Test binary compatibility with v1.4 function signature.
+ALTER EXTENSION pg_cron UPDATE TO '1.4';
+SELECT cron.unschedule(job_name := 'no_such_job');
+ERROR:  could not find valid entry for job 'no_such_job'
 ALTER EXTENSION pg_cron UPDATE;
 -- Vacuum every day at 10:00am (GMT)
 SELECT cron.schedule('0 10 * * *', 'VACUUM');
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index 5f09c40..fc865ec 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -1,5 +1,8 @@
 CREATE EXTENSION pg_cron VERSION '1.0';
 SELECT extversion FROM pg_extension WHERE extname='pg_cron';
+-- Test binary compatibility with v1.4 function signature.
+ALTER EXTENSION pg_cron UPDATE TO '1.4';
+SELECT cron.unschedule(job_name := 'no_such_job');
 ALTER EXTENSION pg_cron UPDATE;
 
 -- Vacuum every day at 10:00am (GMT)
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 17a7088..fdc8805 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -697,8 +697,20 @@ cron_unschedule_named(PG_FUNCTION_ARGS)
 		ereport(ERROR, (errmsg("job_name can not be NULL")));
 	}
 
-	jobNameDatum = PG_GETARG_DATUM(0);
-	jobName = TextDatumGetCString(jobNameDatum);
+	/*
+	 * v1.5 changed the first argument type from "name" to "text".  Cope with
+	 * calls from "CREATE EXTENSION pg_cron VERSION '1.4'".
+	 */
+	if (get_fn_expr_argtype(fcinfo->flinfo, 0) == NAMEOID)
+	{
+		jobName = NameStr(*PG_GETARG_NAME(0));
+		jobNameDatum = CStringGetTextDatum(jobName);
+	}
+	else
+	{
+		jobNameDatum = PG_GETARG_DATUM(0);
+		jobName = TextDatumGetCString(jobNameDatum);
+	}
 
 	cronJobsTable = table_open(CronJobRelationId(), RowExclusiveLock);
 

COMMIT_HASH:a8cb0e0b5018cf82e5a90728a91d04fb79594642|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2023-11-04 15:09:47 +0100|TITLE:Merge pull request #293 from nuno-faria/main|MESSAGE:
COMMIT_HASH:a19c6b9df969fb8a1513b2e8986bae2689043eb0|AUTHOR_NAME:nuno-faria|AUTHOR_EMAIL:nunofpfaria@gmail.com|DATE:2023-11-01 12:43:29 +0000|TITLE:Update the database when scheduling an existing job|MESSAGE:
diff --git a/src/job_metadata.c b/src/job_metadata.c
index fe9249c..17a7088 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -253,7 +253,8 @@ ScheduleCronJob(text *scheduleText, text *commandText, text *databaseText,
 		appendStringInfo(&querybuf, "on conflict on constraint jobname_username_uniq ");
 		appendStringInfo(&querybuf, "do update set ");
 		appendStringInfo(&querybuf, "schedule = EXCLUDED.schedule, ");
-		appendStringInfo(&querybuf, "command = EXCLUDED.command");
+		appendStringInfo(&querybuf, "command = EXCLUDED.command, ");
+		appendStringInfo(&querybuf, "database = EXCLUDED.database");
 	}
 	else
 	{

COMMIT_HASH:cd13bc99ca4587a225e8d4472c28df2e9bdbcb93|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2023-10-21 00:07:12 +0200|TITLE:Merge pull request #292 from citusdata/marcoslot/fix-dom|MESSAGE:
COMMIT_HASH:be3876deead213dc33db87c7fad4f72345f14c81|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2023-10-21 00:02:07 +0200|TITLE:Update CHANGELOG.md|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index b6f14d2..a9cc156 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,7 @@
+### pg_cron v1.6.2 (October 20, 2023) ###
+
+* Fixes off-by-1 issue in day of month
+
 ### pg_cron v1.6.1 (September 26, 2023) ###
 
 * Restart the pg_cron scheduler if cancelled

COMMIT_HASH:c9dedd3947d80566b6418c0fb2e30f10191d3dca|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2023-10-20 23:59:45 +0200|TITLE:Fix pointer reuse bug causing off-by-1 day of month|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 889bc45..094fb70 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -967,7 +967,6 @@ ShouldRunTask(entry *schedule, TimestampTz currentTime, bool doWild,
 	pg_time_t currentTime_t = timestamptz_to_time_t(currentTime);
 	pg_time_t tomorrowTime_t = timestamptz_to_time_t(currentTime + USECS_PER_DAY);
 	struct pg_tm* cur_tm = pg_localtime(&currentTime_t, pg_tzset(cron_timezone));
-	struct pg_tm* tom_tm = pg_localtime(&tomorrowTime_t, pg_tzset(cron_timezone));
 
 	int minute = cur_tm->tm_min -FIRST_MINUTE;
 	int hour = cur_tm->tm_hour -FIRST_HOUR;
@@ -975,7 +974,12 @@ ShouldRunTask(entry *schedule, TimestampTz currentTime, bool doWild,
 	int month = cur_tm->tm_mon +1 -FIRST_MONTH;
 	int dayOfWeek = cur_tm->tm_wday -FIRST_DOW;
 
-	bool lastdom = (schedule->flags & DOM_LAST) != 0 && tom_tm->tm_mday == 1;
+	/*
+	 * pg_localtime returns a pointer to a global struct,
+	 * so cur_tm cannot be used after this point.
+	 */
+	struct pg_tm* tomorrow_tm = pg_localtime(&tomorrowTime_t, pg_tzset(cron_timezone));
+	bool lastdom = (schedule->flags & DOM_LAST) != 0 && tomorrow_tm->tm_mday == 1;
 	bool thisdom = lastdom || bit_test(schedule->dom, dayOfMonth) != 0;
 	bool thisdow = bit_test(schedule->dow, dayOfWeek);
 

COMMIT_HASH:306a680d5a447d8ef710e846fbeac3ad9757579a|AUTHOR_NAME:Hanefi Onaldi|AUTHOR_EMAIL:hanefi@citusdata.com|DATE:2023-10-16 14:40:26 +0300|TITLE:Qualify function call in migration script (#291)|MESSAGE:The migration script for pg_cron 1.2 to 1.3 was using nextval() without
qualifying it with pg_catalog. This is a problem if the user has
installed pg_cron in a schema other than pg_catalog. This commit fixes
the problem by qualifying the function call.
diff --git a/pg_cron--1.2--1.3.sql b/pg_cron--1.2--1.3.sql
index 8af8056..b1e6a68 100644
--- a/pg_cron--1.2--1.3.sql
+++ b/pg_cron--1.2--1.3.sql
@@ -3,7 +3,7 @@
 CREATE SEQUENCE cron.runid_seq;
 CREATE TABLE cron.job_run_details (
 	jobid bigint,
-	runid bigint primary key default nextval('cron.runid_seq'),
+	runid bigint primary key default pg_catalog.nextval('cron.runid_seq'),
 	job_pid integer,
 	database text,
 	username text,

COMMIT_HASH:fa978887b0277ccd22ef5332ebf3876780b64d5f|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-09-26 16:31:17 +0200|TITLE:Update CHANGELOG.md|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 69e7b88..b6f14d2 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,8 @@
+### pg_cron v1.6.1 (September 26, 2023) ###
+
+* Restart the pg_cron scheduler if cancelled
+* Fix the schema version to 1.6 (requires ALTER EXTENSION pg_cron UPDATE)
+
 ### pg_cron v1.6.0 (August 29, 2023) ###
 
 * Adds a cron.launch_active_jobs setting, by Bertrand Drouvot

COMMIT_HASH:ebd918536ebc1ad95527d754289924102e4274e4|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-09-18 09:44:16 +0200|TITLE:Update README.md to PG16|MESSAGE:
diff --git a/README.md b/README.md
index db69884..e6cdd4b 100644
--- a/README.md
+++ b/README.md
@@ -71,18 +71,18 @@ The code in pg_cron that handles parsing and scheduling comes directly from the
 
 ## Installing pg_cron
 
-Install on Red Hat, CentOS, Fedora, Amazon Linux with PostgreSQL 15 using [PGDG](https://yum.postgresql.org/repopackages/):
+Install on Red Hat, CentOS, Fedora, Amazon Linux with PostgreSQL 16 using [PGDG](https://yum.postgresql.org/repopackages/):
 
 ```bash
 # Install the pg_cron extension
-sudo yum install -y pg_cron_15
+sudo yum install -y pg_cron_16
 ```
 
-Install on Debian, Ubuntu with PostgreSQL 15 using [apt.postgresql.org](https://wiki.postgresql.org/wiki/Apt):
+Install on Debian, Ubuntu with PostgreSQL 16 using [apt.postgresql.org](https://wiki.postgresql.org/wiki/Apt):
 
 ```bash
 # Install the pg_cron extension
-sudo apt-get -y install postgresql-15-cron
+sudo apt-get -y install postgresql-16-cron
 ```
 
 You can also install pg_cron by building it from source:
@@ -91,7 +91,7 @@ You can also install pg_cron by building it from source:
 git clone https://github.com/citusdata/pg_cron.git
 cd pg_cron
 # Ensure pg_config is in your path, e.g.
-export PATH=/usr/pgsql-15/bin:$PATH
+export PATH=/usr/pgsql-16/bin:$PATH
 make && sudo PATH=$PATH make install
 ```
 

COMMIT_HASH:ffc017ddc4238c5789b56a7b28d0f5574c4bbb2a|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2023-09-08 12:41:47 +0200|TITLE:Change control file version to 1.6|MESSAGE:
diff --git a/pg_cron--1.5--1.6.sql b/pg_cron--1.5--1.6.sql
new file mode 100644
index 0000000..b428608
--- /dev/null
+++ b/pg_cron--1.5--1.6.sql
@@ -0,0 +1 @@
+/* no SQL changes in 1.6 */
diff --git a/pg_cron.control b/pg_cron.control
index b2bdf77..fbef0fb 100644
--- a/pg_cron.control
+++ b/pg_cron.control
@@ -1,5 +1,5 @@
 comment = 'Job scheduler for PostgreSQL'
-default_version = '1.5'
+default_version = '1.6'
 module_pathname = '$libdir/pg_cron'
 relocatable = false
 schema = pg_catalog

COMMIT_HASH:9944eda34bcb5bd83c1f68fceda92a44d7774128|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-09-04 11:11:22 +0200|TITLE:Merge pull request #286 from citusdata/marcocitus/terminate|MESSAGE:
COMMIT_HASH:7fc155f5310db1eb7acd69b9e8a4516597f31440|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2023-09-01 14:29:47 +0200|TITLE:Restart pg_cron when terminating the background worker|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 074fa1b..889bc45 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -665,7 +665,8 @@ PgCronLauncherMain(Datum arg)
 
 	ereport(LOG, (errmsg("pg_cron scheduler shutting down")));
 
-	proc_exit(0);
+	/* return error code to trigger restart */
+	proc_exit(1);
 }
 
 

COMMIT_HASH:15dcd5727069383bc35b76881270e6d360c660d4|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2023-08-29 13:09:02 +0200|TITLE:Add CHANGELOG for 1.6.0|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 0997f25..69e7b88 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,10 @@
+### pg_cron v1.6.0 (August 29, 2023) ###
+
+* Adds a cron.launch_active_jobs setting, by Bertrand Drouvot
+* Adds support for PostgreSQL 16, by Cristoph Berg & zhjwpku
+* Adds scheduling on the last day of the month, by zhjwpku
+* Fixes a possible memory corruption bug, by zhjwpku
+
 ### pg_cron v1.5.2 (April 9, 2023) ###
 
 * Fixes a bug that caused crashes after upgrading binaries to 1.5, by Polina Bungina

COMMIT_HASH:85765fb8b585a4b514d599d271e4e770a0b8f09b|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2023-08-29 13:03:46 +0200|TITLE:Clean up launch active jobs logic|MESSAGE:
diff --git a/include/pg_cron.h b/include/pg_cron.h
index 6822ab4..fd5127f 100644
--- a/include/pg_cron.h
+++ b/include/pg_cron.h
@@ -14,5 +14,6 @@
 
 /* global settings */
 extern char *CronTableDatabaseName;
+extern bool LaunchActiveJobs;
 
 #endif
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 2f72cf1..074fa1b 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -166,7 +166,6 @@ static int RunningTaskCount = 0;
 static int MaxRunningTasks = 0;
 static int CronLogMinMessages = WARNING;
 static bool UseBackgroundWorkers = false;
-static bool LaunchActiveJobs = true;
 
 char  *cron_timezone = NULL;
 
@@ -634,11 +633,6 @@ PgCronLauncherMain(Datum arg)
 
 		AcceptInvalidationMessages();
 
-		if (!CronJobCacheValid && LaunchActiveJobs)
-		{
-			RefreshTaskHash();
-		}
-
 		if (CronReloadConfig)
 		{
 			/* set the desired log_min_messages */
@@ -648,6 +642,16 @@ PgCronLauncherMain(Datum arg)
 			CronReloadConfig = false;
 		}
 
+		/*
+		 * Both CronReloadConfig and CronJobCacheValid are triggered by SIGHUP.
+		 * ProcessConfigFile should come first, because RefreshTaskHash depends
+		 * on settings that might have changed.
+		 */
+		if (!CronJobCacheValid)
+		{
+			RefreshTaskHash();
+		}
+
 		taskList = CurrentTaskList();
 		currentTime = GetCurrentTimestamp();
 
@@ -1279,7 +1283,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 		case CRON_TASK_WAITING:
 		{
 			/* check if job has been removed */
-			if (!task->isActive || !LaunchActiveJobs)
+			if (!task->isActive)
 			{
 				/* remove task as well */
 				RemoveTask(jobId);
diff --git a/src/task_states.c b/src/task_states.c
index 5974e7e..34077c6 100644
--- a/src/task_states.c
+++ b/src/task_states.c
@@ -30,6 +30,9 @@ static CronTask * GetCronTask(int64 jobId);
 static MemoryContext CronTaskContext = NULL;
 static HTAB *CronTaskHash = NULL;
 
+/* settings */
+bool LaunchActiveJobs = true;
+
 
 /*
  * InitializeTaskStateHash initializes the hash for storing task states.
@@ -101,7 +104,7 @@ RefreshTaskHash(void)
 		CronJob *job = (CronJob *) lfirst(jobCell);
 
 		task = GetCronTask(job->jobId);
-		task->isActive = job->active;
+		task->isActive = LaunchActiveJobs && job->active;
 		task->secondsInterval = job->schedule.secondsInterval;
 	}
 

COMMIT_HASH:8552bb8f983f8fa28b0df20844a0f93fa2388c75|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-08-29 13:17:22 +0200|TITLE:Merge pull request #283 from bdrouvotAWS/pr_global_switch|MESSAGE:
COMMIT_HASH:81dbc8c5b6a3a8bbfec884faf5672073645db951|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-08-21 12:41:21 +0200|TITLE:Merge pull request #273 from zhjwpku/support-last-day-of-month|MESSAGE:add possibility to schedule jobs on the last day of month
COMMIT_HASH:ac7609499a1a8aebb4f2ac64f010f45919d23cb7|AUTHOR_NAME:bdrouvotAWS|AUTHOR_EMAIL:bdrouvot@amazon.com|DATE:2023-08-03 07:47:00 +0000|TITLE:Overall on/off to launch active jobs|MESSAGE:This patch introduces a new GUC (cron.launch_active_jobs) that controls whether
or not jobs marked as "active" should be launched without requiring a postmaster
restart.

It allows:

- global on/off switch without having to update the "active" column in
  cron.job for all the jobs.
- global on/off switch without loss of the previous jobs states (i.e the "active"
  columns value remains the same). When it's set to true, jobs resume working as
  before (if "active" column is true).

diff --git a/src/pg_cron.c b/src/pg_cron.c
index e52c371..819d5ec 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -166,6 +166,7 @@ static int RunningTaskCount = 0;
 static int MaxRunningTasks = 0;
 static int CronLogMinMessages = WARNING;
 static bool UseBackgroundWorkers = false;
+static bool LaunchActiveJobs = true;
 
 char  *cron_timezone = NULL;
 
@@ -268,6 +269,16 @@ _PG_init(void)
 		GUC_SUPERUSER_ONLY,
 		NULL, NULL, NULL);
 
+	DefineCustomBoolVariable(
+		"cron.launch_active_jobs",
+		gettext_noop("Launch jobs that are defined as active."),
+		NULL,
+		&LaunchActiveJobs,
+		true,
+		PGC_SIGHUP,
+		GUC_SUPERUSER_ONLY,
+		NULL, NULL, NULL);
+
 	if (!UseBackgroundWorkers)
 		DefineCustomIntVariable(
 			"cron.max_running_jobs",
@@ -623,7 +634,7 @@ PgCronLauncherMain(Datum arg)
 
 		AcceptInvalidationMessages();
 
-		if (!CronJobCacheValid)
+		if (!CronJobCacheValid && LaunchActiveJobs)
 		{
 			RefreshTaskHash();
 		}
@@ -1263,7 +1274,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 		case CRON_TASK_WAITING:
 		{
 			/* check if job has been removed */
-			if (!task->isActive)
+			if (!task->isActive || !LaunchActiveJobs)
 			{
 				/* remove task as well */
 				RemoveTask(jobId);

COMMIT_HASH:fd6cda64bfff7eb7b74b8dd48c2446f36cf4e8db|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-08-14 11:41:03 +0200|TITLE:Merge pull request #281 from Debian/kr-prototypes|MESSAGE:
COMMIT_HASH:59f1f3ce2d1ecf305f4280cd93b5898aa31b0946|AUTHOR_NAME:Christoph Berg|AUTHOR_EMAIL:myon@debian.org|DATE:2023-07-31 21:40:34 +0200|TITLE:Convert K&R function definitions|MESSAGE:clang-15 with PG16 finally chokes on them.

diff --git a/src/entry.c b/src/entry.c
index e5ead6e..cc9a5eb 100644
--- a/src/entry.c
+++ b/src/entry.c
@@ -266,12 +266,12 @@ parse_cron_entry(char *schedule)
 
 
 static int
-get_list(bits, low, high, names, ch, file)
-	bitstr_t	*bits;		/* one bit per flag, default=FALSE */
-	int		low, high;	/* bounds, impl. offset for bitstr */
-	char		*names[];	/* NULL or *[] of names for these elements */
-	int		ch;		/* current character being processed */
-	FILE		*file;		/* file being read */
+get_list(bitstr_t *bits, int low, int high, char *names[], int ch, FILE *file)
+	/* bitstr_t	*bits; */		/* one bit per flag, default=FALSE */
+	/* int		low, high; */	/* bounds, impl. offset for bitstr */
+	/* char		*names[]; */	/* NULL or *[] of names for these elements */
+	/* int		ch; */		/* current character being processed */
+	/* FILE		*file; */		/* file being read */
 {
 	register int	done;
 
@@ -313,12 +313,12 @@ get_list(bits, low, high, names, ch, file)
 
 
 static int
-get_range(bits, low, high, names, ch, file)
-	bitstr_t	*bits;		/* one bit per flag, default=FALSE */
-	int		low, high;	/* bounds, impl. offset for bitstr */
-	char		*names[];	/* NULL or names of elements */
-	int		ch;		/* current character being processed */
-	FILE 		*file;		/* file being read */
+get_range(bitstr_t *bits, int low, int high, char *names[], int ch, FILE *file)
+	/* bitstr_t	*bits;		one bit per flag, default=FALSE */
+	/* int		low, high;	bounds, impl. offset for bitstr */
+	/* char		*names[];	NULL or names of elements */
+	/* int		ch;		current character being processed */
+	/* FILE 		*file;		file being read */
 {
 	/* range = number | number "-" number [ "/" number ]
 	 */
@@ -416,12 +416,12 @@ get_range(bits, low, high, names, ch, file)
 
 
 static int
-get_number(numptr, low, names, ch, file)
-	int	*numptr;	/* where does the result go? */
-	int	low;		/* offset applied to result if symbolic enum used */
-	char	*names[];	/* symbolic names, if any, for enums */
-	int	ch;		/* current character */
-	FILE 		*file;		/* source */
+get_number(int *numptr, int low, char *names[], int ch, FILE *file)
+	/* int	*numptr;	where does the result go? */
+	/* int	low;/		offset applied to result if symbolic enum used */
+	/* char	*names[];	symbolic names, if any, for enums */
+	/* int	ch;		current character */
+	/* FILE 		*file;		source */
 {
 	char	temp[MAX_TEMPSTR], *pc;
 	int	len, i, all_digits;
@@ -475,11 +475,11 @@ get_number(numptr, low, names, ch, file)
 
 
 static int
-set_element(bits, low, high, number)
-	bitstr_t	*bits; 		/* one bit per flag, default=FALSE */
-	int		low;
-	int		high;
-	int		number;
+set_element(bitstr_t *bits, int low, int high, int number)
+	/* bitstr_t	*bits; 		one bit per flag, default=FALSE */
+	/* int		low; */
+	/* int		high; */
+	/* int		number; */
 {
 	Debug(DPARS|DEXT, ("set_element(?,%d,%d,%d)\n", low, high, number))
 
diff --git a/src/misc.c b/src/misc.c
index bf7e2b3..a3ac06c 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -33,8 +33,7 @@
 /* get_char(file) : like getc() but increment LineNumber on newlines
  */
 int
-get_char(file)
-	FILE	*file;
+get_char(FILE *file)
 {
 	int	ch;
 
@@ -74,9 +73,7 @@ get_char(file)
 /* unget_char(ch, file) : like ungetc but do LineNumber processing
  */
 void
-unget_char(ch, file)
-	int	ch;
-	FILE	*file;
+unget_char(int ch, FILE *file)
 {
 
 	/*
@@ -108,11 +105,7 @@ unget_char(ch, file)
  *		(4) returns EOF or terminating character, whichever
  */
 int
-get_string(string, size, file, terms)
-	char	*string;
-	int	size;
-	FILE	*file;
-	char	*terms;
+get_string(char *string, int size, FILE *file, char *terms)
 {
 	int	ch;
 
@@ -133,8 +126,7 @@ get_string(string, size, file, terms)
 /* skip_comments(file) : read past comment (if any)
  */
 void
-skip_comments(file)
-	FILE	*file;
+skip_comments(FILE *file)
 {
 	int	ch;
 

COMMIT_HASH:4da3981fea8688518e7cde39b685cc0a37903f9c|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-07-28 11:11:58 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 9b63f45..f508aa1 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,5 @@
 [![Citus Banner](/github-banner.png)](https://www.citusdata.com/)
 
-[![Slack Status](https://citus-slack.herokuapp.com/badge.svg)](https://citus-public.slack.com/)
-
 ## What is pg_cron?
 
 pg_cron is a simple cron-based job scheduler for PostgreSQL (10 or higher) that runs inside the database as an extension. It uses the same syntax as regular cron, but it allows you to schedule PostgreSQL commands directly from the database. You can also use '[1-59] seconds' to schedule a job based on an interval.
@@ -137,8 +135,11 @@ It may be necessary to enable `trust` authentication for connections coming from
 
 You can also use a unix domain socket directory as the hostname and enable `trust` authentication for local connections in [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html), which is normally safe:
 ```
-# Connect via a unix domain socket
+# Connect via a unix domain socket:
 cron.host = '/tmp'
+
+# Can also be an empty string to look for the default directory:
+cron.host = ''
 ```
 
 Alternatively, pg_cron can be configured to use background workers. In that case, the number of concurrent jobs is limited by the `max_worker_processes` setting, so you may need to raise that.

COMMIT_HASH:1c9fa93c9ffe87801d588bdcc167d0d3157af872|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-06-16 17:06:47 +0200|TITLE:Merge pull request #271 from zhjwpku/fix_memory_corruption_bug_of_cron|MESSAGE:
COMMIT_HASH:aa3f7220eadc2f8edb8ef1de7673a55bbf4bf6bd|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-06-12 10:59:06 +0200|TITLE:Merge pull request #275 from sahemant/fix-compile-error|MESSAGE:
COMMIT_HASH:0cb8118e8dfda30af58a65e14e2b7fe73ec6c931|AUTHOR_NAME:Hemanth Sandrana|AUTHOR_EMAIL:16522686+sahemant@users.noreply.github.com|DATE:2023-06-09 16:37:17 +0530|TITLE:fix compiler error - shadows a  previous local|MESSAGE:gcc -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Werror=vla -Wendif-labels -Wmissing-format-attribute -Wimplicit-fallthrough=3 -Wcast-function-type -Wshadow=compatible-local -Wformat-security -fno-strict-aliasing -fwrapv -fexcess-precision=standard -Wno-format-truncation -Wno-stringop-truncation -g  -ggdb3 -fPIC -fvisibility=hidden -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-implicit-fallthrough -Iinclude -I../../src/interfaces/libpq -I. -I. -I../../src/include  -DLOCK_DEBUG -D_GNU_SOURCE -I/usr/include/libxml2   -c -o src/job_metadata.o src/job_metadata.c -MMD -MP -MF .deps/job_metadata.Po
src/job_metadata.c: In function ‘ParseSchedule’:
src/job_metadata.c:1526:10: error: declaration of ‘schedule’ shadows a previous local [-Werror=shadow=compatible-local]
 1526 |   entry *schedule = calloc(sizeof(entry), sizeof(char));
      |          ^~~~~~~~
src/job_metadata.c:1514:9: note: shadowed declaration is here
 1514 |  entry *schedule = parse_cron_entry(scheduleText);
      |         ^~~~~~~~
cc1: all warnings being treated as errors
make: *** [../../src/Makefile.global:949: src/job_metadata.o] Error 1
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 7054f8b..fe9249c 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -1507,11 +1507,12 @@ static entry *
 ParseSchedule(char *scheduleText)
 {
 	uint32 secondsInterval = 0;
+	entry *schedule;
 
 	/*
 	 * First try to parse as a cron schedule.
 	 */
-	entry *schedule = parse_cron_entry(scheduleText);
+	schedule = parse_cron_entry(scheduleText);
 	if (schedule != NULL)
 	{
 		/* valid cron schedule */
@@ -1523,7 +1524,7 @@ ParseSchedule(char *scheduleText)
 	 */
 	if (TryParseInterval(scheduleText, &secondsInterval))
 	{
-		entry *schedule = calloc(sizeof(entry), sizeof(char));
+		schedule = calloc(sizeof(entry), sizeof(char));
 		schedule->secondsInterval = secondsInterval;
 		return schedule;
 	}

COMMIT_HASH:956c07adb5e4088b46624fa14d4cb3b3c1d5b228|AUTHOR_NAME:Junwang Zhao|AUTHOR_EMAIL:zhjwpku@gmail.com|DATE:2023-05-31 23:47:36 +0800|TITLE:add possibility to schedule jobs on the last day of month|MESSAGE:Paul and I had a discussion about adding the feature of last day
of month, there are things you want do on the last day of the
month, like:

- pay your rent, mortgage
- visit your mother or parole officer
- calculate paychecks for your empoyees

So this might be a reasonable feature, the idea using '$' to indicate
last day-of-month came from regex syntax, '$' is the end of a line.

backport from this PR:

https://github.com/vixie/cron/pull/20

Signed-off-by: Junwang Zhao <zhjwpku@gmail.com>

diff --git a/README.md b/README.md
index 9b63f45..0ae477d 100644
--- a/README.md
+++ b/README.md
@@ -6,6 +6,8 @@
 
 pg_cron is a simple cron-based job scheduler for PostgreSQL (10 or higher) that runs inside the database as an extension. It uses the same syntax as regular cron, but it allows you to schedule PostgreSQL commands directly from the database. You can also use '[1-59] seconds' to schedule a job based on an interval.
 
+pg_cron also allows you using '$' to indicate last day of the month.
+
 ```sql
 -- Delete old data on Saturday at 3:30am (GMT)
 SELECT cron.schedule('30 3 * * 6', $$DELETE FROM events WHERE event_time < now() - interval '1 week'$$);
@@ -43,7 +45,10 @@ SELECT cron.schedule_in_database('weekly-vacuum', '0 4 * * 0', 'VACUUM', 'some_o
        44
 
 -- Call a stored procedure every 5 seconds
-SELECT cron.schedule('process-updates', '5 seconds', 'CALL process_updates()'); 
+SELECT cron.schedule('process-updates', '5 seconds', 'CALL process_updates()');
+
+-- Process payroll at 12:00 of the last day of each month
+SELECT cron.schedule('process-payroll', '0 12 $ * *', 'CALL process_payroll()');
 ```
 
 pg_cron can run multiple jobs in parallel, but it runs at most one instance of a job at a time. If a second run is supposed to start before the first one finishes, then the second run is queued and started as soon as the first run completes.
@@ -53,7 +58,7 @@ The schedule uses the standard cron syntax, in which * means "run every time per
 ```
  ┌───────────── min (0 - 59)
  │ ┌────────────── hour (0 - 23)
- │ │ ┌─────────────── day of month (1 - 31)
+ │ │ ┌─────────────── day of month (1 - 31) or last day of the month ($)
  │ │ │ ┌──────────────── month (1 - 12)
  │ │ │ │ ┌───────────────── day of week (0 - 6) (0 to 6 are Sunday to
  │ │ │ │ │                  Saturday, or use names; 7 is also Sunday)
@@ -169,7 +174,7 @@ select * from cron.job_run_details order by start_time desc limit 5;
 └───────┴───────┴─────────┴──────────┴──────────┴───────────────────┴───────────┴──────────────────┴───────────────────────────────┴───────────────────────────────┘
 (10 rows)
 ```
- 
+
 The records in `cron.job_run_details` are not cleaned automatically, but every user that can schedule cron jobs also has permission to delete their own `cron.job_run_details` records. 
 
 Especially when you have jobs that run every few seconds, it can be a good idea to clean up regularly, which can easily be done using pg_cron itself:
diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index bfc0e60..f2e2b90 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -260,6 +260,27 @@ SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
      4 |         | 17  seconds  | SELECT 1
 (4 rows)
 
+-- valid last of day job
+SELECT cron.schedule('last-day-of-month-job1', '0 11 $ * *', 'SELECT 1');
+ schedule 
+----------
+        5
+(1 row)
+
+SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
+ jobid |        jobname         |   schedule   | command  
+-------+------------------------+--------------+----------
+     1 |                        | 1 second     | SELECT 1
+     2 |                        |  30 sEcOnDs  | SELECT 1
+     3 |                        | 59 seconds   | SELECT 1
+     4 |                        | 17  seconds  | SELECT 1
+     5 | last-day-of-month-job1 | 0 11 $ * *   | SELECT 1
+(5 rows)
+
+-- invalid last of day job
+SELECT cron.schedule('bad-last-dom-job1', '0 11 $foo * *', 'VACUUM FULL');
+ERROR:  invalid schedule: 0 11 $foo * *
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
 -- cleaning
 DROP EXTENSION pg_cron;
 drop user pgcron_cront;
diff --git a/include/cron.h b/include/cron.h
index 2f38f86..12634ed 100644
--- a/include/cron.h
+++ b/include/cron.h
@@ -91,8 +91,10 @@
 #define MAXHOSTNAMELEN 64
 #endif
 
+#define Is_Blank(c) ((c) == '\t' || (c) == ' ')
+
 #define	Skip_Blanks(c, f) \
-			while (c == '\t' || c == ' ') \
+			while (Is_Blank(c)) \
 				c = get_char(f);
 
 #define	Skip_Nonblanks(c, f) \
@@ -125,8 +127,6 @@ typedef int time_min;
 #define	CRON_LOG_JOBFAILED	0x04
 #define	CRON_LOG_JOBPID		0x08
 
-#define SECONDS_PER_MINUTE 60
-
 #define	FIRST_MINUTE	0
 #define	LAST_MINUTE	59
 #define	MINUTE_COUNT	(LAST_MINUTE - FIRST_MINUTE + 1)
@@ -171,6 +171,7 @@ typedef	struct _entry {
 #define	WHEN_REBOOT	0x04
 #define MIN_STAR	0x08
 #define HR_STAR		0x10
+#define DOM_LAST	0x20
 } entry;
 
 			/* the crontab database will be a list of the
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index 8c87bc6..5f09c40 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -139,6 +139,13 @@ SELECT cron.schedule('59 seconds', 'SELECT 1');
 SELECT cron.schedule('17  seconds ', 'SELECT 1'); 
 SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
 
+-- valid last of day job
+SELECT cron.schedule('last-day-of-month-job1', '0 11 $ * *', 'SELECT 1');
+SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
+
+-- invalid last of day job
+SELECT cron.schedule('bad-last-dom-job1', '0 11 $foo * *', 'VACUUM FULL');
+
 -- cleaning
 DROP EXTENSION pg_cron;
 drop user pgcron_cront;
diff --git a/src/entry.c b/src/entry.c
index 994cc3b..6e6de71 100644
--- a/src/entry.c
+++ b/src/entry.c
@@ -188,10 +188,21 @@ parse_cron_entry(char *schedule)
 		/* DOM (days of month)
 		 */
 
-		if (ch == '*')
-			e->flags |= DOM_STAR;
-		ch = get_list(e->dom, FIRST_DOM, LAST_DOM,
-			      PPC_NULL, ch, file);
+		if (ch == '$') {
+			ch = get_char(file);
+			if (!Is_Blank(ch)) {
+				ecode = e_dom;
+				goto eof;
+			}
+			Skip_Blanks(ch, file);
+			e->flags |= DOM_LAST;
+		} else {
+			if (ch == '*')
+				e->flags |= DOM_STAR;
+			ch = get_list(e->dom, FIRST_DOM, LAST_DOM,
+					PPC_NULL, ch, file);
+		}
+
 		if (ch == EOF) {
 			ecode = e_dom;
 			goto eof;
diff --git a/src/pg_cron.c b/src/pg_cron.c
index e52c371..21dabc4 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -949,20 +949,25 @@ ShouldRunTask(entry *schedule, TimestampTz currentTime, bool doWild,
 			  bool doNonWild)
 {
 	pg_time_t currentTime_t = timestamptz_to_time_t(currentTime);
-	struct pg_tm* tm = pg_localtime(&currentTime_t, pg_tzset(cron_timezone));
+	pg_time_t tomorrowTime_t = timestamptz_to_time_t(currentTime + USECS_PER_DAY);
+	struct pg_tm* cur_tm = pg_localtime(&currentTime_t, pg_tzset(cron_timezone));
+	struct pg_tm* tom_tm = pg_localtime(&tomorrowTime_t, pg_tzset(cron_timezone));
 
-	int minute = tm->tm_min -FIRST_MINUTE;
-	int hour = tm->tm_hour -FIRST_HOUR;
-	int dayOfMonth = tm->tm_mday -FIRST_DOM;
-	int month = tm->tm_mon +1 -FIRST_MONTH;
-	int dayOfWeek = tm->tm_wday -FIRST_DOW;
+	int minute = cur_tm->tm_min -FIRST_MINUTE;
+	int hour = cur_tm->tm_hour -FIRST_HOUR;
+	int dayOfMonth = cur_tm->tm_mday -FIRST_DOM;
+	int month = cur_tm->tm_mon +1 -FIRST_MONTH;
+	int dayOfWeek = cur_tm->tm_wday -FIRST_DOW;
+
+	bool lastdom = (schedule->flags & DOM_LAST) != 0 && tom_tm->tm_mday == 1;
+	bool thisdom = lastdom || bit_test(schedule->dom, dayOfMonth) != 0;
+	bool thisdow = bit_test(schedule->dow, dayOfWeek);
 
 	if (bit_test(schedule->minute, minute) &&
 	    bit_test(schedule->hour, hour) &&
 	    bit_test(schedule->month, month) &&
-	    ( ((schedule->flags & DOM_STAR) || (schedule->flags & DOW_STAR))
-	      ? (bit_test(schedule->dow,dayOfWeek) && bit_test(schedule->dom,dayOfMonth))
-	      : (bit_test(schedule->dow,dayOfWeek) || bit_test(schedule->dom,dayOfMonth)))) {
+	    ( (schedule->flags & (DOM_STAR|DOW_STAR)) != 0
+	      ? (thisdom && thisdow) : (thisdom) || thisdow)) {
 		if ((doNonWild && !(schedule->flags & (MIN_STAR|HR_STAR)))
 		    || (doWild && (schedule->flags & (MIN_STAR|HR_STAR))))
 		{

COMMIT_HASH:541eea41b4e124319245d7b73851edf2b5abf0cf|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-05-30 10:35:42 +0200|TITLE:Merge pull request #268 from Debian/test-latest-version|MESSAGE:
COMMIT_HASH:347e768676124c2f34ef89f2ed1c38c7a2b15d59|AUTHOR_NAME:Junwang Zhao|AUTHOR_EMAIL:zhjwpku@gmail.com|DATE:2023-05-29 15:19:22 +0800|TITLE:fix memory corruption bug of cron module|MESSAGE:I found a bug of vixie cron, which bit_nset and bit_nclear are used
to set and clean bits of range [start, stop], for `dow` and `hour`,
they use 8 bits and 24bits, the following statement will write the
next byte since the pass the length instead of the stop position,
which will corrupt the memory.

bit_nset(e->hour, 0, (LAST_HOUR-FIRST_HOUR+1));
bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
bit_nclear(bits, 0, (high-low+1));

Paul vixie(the author of vixie cron) fix this with some code refactory,
this patch just backport it back to pg_cron.

The original PRs:

1. https://github.com/vixie/cron/pull/16
2. https://github.com/vixie/cron/pull/18

Signed-off-by: Junwang Zhao <zhjwpku@gmail.com>

diff --git a/src/entry.c b/src/entry.c
index 994cc3b..e5ead6e 100644
--- a/src/entry.c
+++ b/src/entry.c
@@ -38,7 +38,8 @@ typedef	enum ecode {
 static int	get_list(bitstr_t *, int, int, char *[], int, FILE *),
 		get_range(bitstr_t *, int, int, char *[], int, FILE *),
 		get_number(int *, int, char *[], int, FILE *);
-static int	set_element(bitstr_t *, int, int, int);
+static int	set_element(bitstr_t *, int, int, int),
+		set_range(bitstr_t *, int, int, int, int, int);
 
 
 void
@@ -124,38 +125,63 @@ parse_cron_entry(char *schedule)
 		if (!strcmp("reboot", cmd) || !strcmp("restart", cmd)) {
 			e->flags |= WHEN_REBOOT;
 		} else if (!strcmp("yearly", cmd) || !strcmp("annually", cmd)){
-			bit_set(e->minute, 0);
-			bit_set(e->hour, 0);
-			bit_set(e->dom, 0);
-			bit_set(e->month, 0);
-			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
-                        e->flags |= DOW_STAR;
+			set_element(e->minute, FIRST_MINUTE, LAST_MINUTE,
+				    FIRST_MINUTE);
+			set_element(e->hour, FIRST_HOUR, LAST_HOUR,
+				    FIRST_HOUR);
+			set_element(e->dom, FIRST_DOM, LAST_DOM,
+				    FIRST_DOM);
+			set_element(e->month, FIRST_MONTH, LAST_MONTH,
+				    FIRST_MINUTE);
+			set_range(e->dow, FIRST_DOW, LAST_DOW,
+				  FIRST_DOW, LAST_DOW, 1);
+			e->flags |= DOW_STAR;
 		} else if (!strcmp("monthly", cmd)) {
-			bit_set(e->minute, 0);
-			bit_set(e->hour, 0);
-			bit_set(e->dom, 0);
-			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
-			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
-                        e->flags |= DOW_STAR;
+			set_element(e->minute, FIRST_MINUTE, LAST_MINUTE,
+				    FIRST_MINUTE);
+			set_element(e->hour, FIRST_HOUR, LAST_HOUR,
+				    FIRST_HOUR);
+			set_element(e->dom, FIRST_DOM, LAST_DOM,
+				    FIRST_DOM);
+			set_range(e->month, FIRST_MONTH, LAST_MONTH,
+				  FIRST_MONTH, LAST_MONTH, 1);
+			set_range(e->dow, FIRST_DOW, LAST_DOW,
+				  FIRST_DOW, LAST_DOW, 1);
+			e->flags |= DOW_STAR;
 		} else if (!strcmp("weekly", cmd)) {
-			bit_set(e->minute, 0);
-			bit_set(e->hour, 0);
-			bit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));
-			e->flags |= DOM_STAR;
-			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
-			bit_nset(e->dow, 0,0);
+			set_element(e->minute, FIRST_MINUTE, LAST_MINUTE,
+				    FIRST_MINUTE);
+			set_element(e->hour, FIRST_HOUR, LAST_HOUR,
+				    FIRST_HOUR);
+			set_range(e->dom, FIRST_DOM, LAST_DOM,
+				  FIRST_DOM, LAST_DOM, 1);
+			set_range(e->month, FIRST_MONTH, LAST_MONTH,
+				  FIRST_MONTH, LAST_MONTH, 1);
+			set_element(e->dow, FIRST_DOW, LAST_DOW,
+				    FIRST_DOW);
+			e->flags |= DOW_STAR;
 		} else if (!strcmp("daily", cmd) || !strcmp("midnight", cmd)) {
-			bit_set(e->minute, 0);
-			bit_set(e->hour, 0);
-			bit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));
-			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
-			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
+			set_element(e->minute, FIRST_MINUTE, LAST_MINUTE,
+				    FIRST_MINUTE);
+			set_element(e->hour, FIRST_HOUR, LAST_HOUR,
+				    FIRST_HOUR);
+			set_range(e->dom, FIRST_DOM, LAST_DOM,
+				  FIRST_DOM, LAST_DOM, 1);
+			set_range(e->month, FIRST_MONTH, LAST_MONTH,
+				  FIRST_MONTH, LAST_MONTH, 1);
+			set_range(e->dow, FIRST_DOW, LAST_DOW,
+				  FIRST_DOW, LAST_DOW, 1);
 		} else if (!strcmp("hourly", cmd)) {
-			bit_set(e->minute, 0);
-			bit_nset(e->hour, 0, (LAST_HOUR-FIRST_HOUR+1));
-			bit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));
-			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
-			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
+			set_element(e->minute, FIRST_MINUTE, LAST_MINUTE,
+				    FIRST_MINUTE);
+			set_range(e->hour, FIRST_HOUR, LAST_HOUR,
+				  FIRST_HOUR, LAST_HOUR, 1);
+			set_range(e->dom, FIRST_DOM, LAST_DOM,
+				  FIRST_DOM, LAST_DOM, 1);
+			set_range(e->month, FIRST_MONTH, LAST_MONTH,
+				  FIRST_MONTH, LAST_MONTH, 1);
+			set_range(e->dow, FIRST_DOW, LAST_DOW,
+				  FIRST_DOW, LAST_DOW, 1);
 			e->flags |= HR_STAR;
 		} else {
 			ecode = e_timespec;
@@ -262,7 +288,7 @@ get_list(bits, low, high, names, ch, file)
 
 	/* clear the bit string, since the default is 'off'.
 	 */
-	bit_nclear(bits, 0, (high-low+1));
+	bit_nclear(bits, 0, (high-low));
 
 	/* process all ranges
 	 */
@@ -297,7 +323,6 @@ get_range(bits, low, high, names, ch, file)
 	/* range = number | number "-" number [ "/" number ]
 	 */
 
-	register int	i;
 	auto int	num1, num2, num3;
 
 	Debug(DPARS|DEXT, ("get_range()...entering, exit won't show\n"))
@@ -381,9 +406,10 @@ get_range(bits, low, high, names, ch, file)
 	 * proposed conceptually by bob@acornrc, syntactically
 	 * designed then implemented by paul vixie).
 	 */
-	for (i = num1;  i <= num2;  i += num3)
-		if (EOF == set_element(bits, low, high, i))
-			return EOF;
+	if (EOF == set_range(bits, low, high, num1, num2, num3)) {
+		unget_char(ch, file);
+		return EOF;
+	}
 
 	return ch;
 }
@@ -460,6 +486,27 @@ set_element(bits, low, high, number)
 	if (number < low || number > high)
 		return EOF;
 
-	bit_set(bits, (number-low));
+	number -= low;
+
+	bit_set(bits, number);
+	return OK;
+}
+
+static int
+set_range(bitstr_t *bits, int low, int high, int start, int stop, int step) {
+	Debug(DPARS|DEXT, ("set_range(?,%d,%d,%d,%d,%d)\n",
+			   low, high, start, stop, step))
+
+	if (start < low || stop > high)
+		return EOF;
+	start -= low;
+	stop -= low;
+
+	if (step == 1) {
+		bit_nset(bits, start, stop);
+	} else {
+		for (int i = start; i <= stop; i += step)
+			bit_set(bits, i);
+	}
 	return OK;
 }

COMMIT_HASH:00db68d4b6389f74b3c9ad2744cd79e4d0b773bf|AUTHOR_NAME:Christoph Berg|AUTHOR_EMAIL:myon@debian.org|DATE:2023-05-12 21:26:18 +0200|TITLE:Test latest version instead of hardcoding 1.4|MESSAGE:The 1.4 version of the SQL scripts are no longer compatible with the C
code since cron_unschedule_named expects "text" as input now.

Instead of hardcoding '1.4', simply upgrade to the most recent version.
Also drop the test for extversion after the upgrade since this value is
prone to be missed on future releases.

Problem was visible on big-endian architectures.

https://github.com/citusdata/pg_cron/issues/267

diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index aa3b1fa..bfc0e60 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -5,13 +5,7 @@ SELECT extversion FROM pg_extension WHERE extname='pg_cron';
  1.0
 (1 row)
 
-ALTER EXTENSION pg_cron UPDATE TO '1.4';
-SELECT extversion FROM pg_extension WHERE extname='pg_cron';
- extversion 
-------------
- 1.4
-(1 row)
-
+ALTER EXTENSION pg_cron UPDATE;
 -- Vacuum every day at 10:00am (GMT)
 SELECT cron.schedule('0 10 * * *', 'VACUUM');
  schedule 
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index febcf47..8c87bc6 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -1,7 +1,6 @@
 CREATE EXTENSION pg_cron VERSION '1.0';
 SELECT extversion FROM pg_extension WHERE extname='pg_cron';
-ALTER EXTENSION pg_cron UPDATE TO '1.4';
-SELECT extversion FROM pg_extension WHERE extname='pg_cron';
+ALTER EXTENSION pg_cron UPDATE;
 
 -- Vacuum every day at 10:00am (GMT)
 SELECT cron.schedule('0 10 * * *', 'VACUUM');

COMMIT_HASH:b8d8f4bb467cf0b86281351977522707cda0bc1a|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2023-04-06 13:56:10 +0200|TITLE:Add CHANGELOG for 1.5.2|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 06954ca..0997f25 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,7 @@
+### pg_cron v1.5.2 (April 9, 2023) ###
+
+* Fixes a bug that caused crashes after upgrading binaries to 1.5, by Polina Bungina
+
 ### pg_cron v1.5.1 (February 9, 2023) ###
 
 * Fixes a bug that caused incorrect parsing of some crons schedules

COMMIT_HASH:6875fa687a3858400442b1a0b88e8921d24d2572|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-04-06 13:54:44 +0200|TITLE:Merge pull request #262 from hughcapet/fix-1.5-update|MESSAGE:
COMMIT_HASH:416ac75518253b872507e46ac4dc27198c243e49|AUTHOR_NAME:Polina Bungina|AUTHOR_EMAIL:bungina@gmail.com|DATE:2023-04-06 13:43:47 +0200|TITLE:Switch to NameStr and copy the name value|MESSAGE:
diff --git a/src/job_metadata.c b/src/job_metadata.c
index bd5c29c..7054f8b 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -985,7 +985,7 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 			/* Handle the column type change introduced in 1.5 */
 			if (TupleDescAttr(tupleDescriptor, Anum_cron_job_jobname - 1)->atttypid == NAMEOID)
 			{
-				job->jobName = (DatumGetName(jobName))->data;
+				job->jobName = pstrdup(NameStr(*DatumGetName(jobName)));
 			}
 			else
 			{

COMMIT_HASH:da1d8987777ea3b3713e848dd75bffe91e12ebfc|AUTHOR_NAME:Polina Bungina|AUTHOR_EMAIL:bungina@gmail.com|DATE:2023-04-06 12:42:58 +0200|TITLE:Add comment|MESSAGE:
diff --git a/src/job_metadata.c b/src/job_metadata.c
index d7dd2df..bd5c29c 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -982,6 +982,7 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 									 tupleDescriptor, &isJobNameNull);
 		if (!isJobNameNull)
 		{
+			/* Handle the column type change introduced in 1.5 */
 			if (TupleDescAttr(tupleDescriptor, Anum_cron_job_jobname - 1)->atttypid == NAMEOID)
 			{
 				job->jobName = (DatumGetName(jobName))->data;

COMMIT_HASH:d1564fd34af494d53463976b36d7adfbbdbd40fa|AUTHOR_NAME:Polina Bungina|AUTHOR_EMAIL:bungina@gmail.com|DATE:2023-04-06 08:12:34 +0200|TITLE:Fix jobname field handling|MESSAGE:After job name was converted to a text field in 6fc9ca9 there is a
problem in updating the extension from the versions where the field is of
type name. Namely: when postgres is started but the extenision is still not
updated, thus, the column type is not yet altered, pg_cron launcher gets a
Segmentation Fault during the attempt to convert a heap tuple from
cron.job table to a CronJob struct.

diff --git a/src/job_metadata.c b/src/job_metadata.c
index c95a802..d7dd2df 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -982,7 +982,14 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 									 tupleDescriptor, &isJobNameNull);
 		if (!isJobNameNull)
 		{
-			job->jobName = TextDatumGetCString(jobName);
+			if (TupleDescAttr(tupleDescriptor, Anum_cron_job_jobname - 1)->atttypid == NAMEOID)
+			{
+				job->jobName = (DatumGetName(jobName))->data;
+			}
+			else
+			{
+				job->jobName = TextDatumGetCString(jobName);
+			}
 		}
 		else
 		{

COMMIT_HASH:d161eb940fbaf0620c989c6e69244ec0cb3e4b3b|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-03-13 13:29:11 +0100|TITLE:Merge pull request #250 from Debian/pg_time_t|MESSAGE:
COMMIT_HASH:c14336e96175fd8e1f2f4636dde42d3e213fea19|AUTHOR_NAME:Christoph Berg|AUTHOR_EMAIL:myon@debian.org|DATE:2023-03-13 13:13:02 +0100|TITLE:Use correct time type on 32-bit systems|MESSAGE:time_t depends on the current architecture:

```
gcc -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Werror=vla -Wendif-labels -Wmissing-format-attribute -Wimplicit-fallthrough=3 -Wcast-function-type -Wformat-security -fno-strict-aliasing -fwrapv -fexcess-precision=standard -Wno-format-truncation -Wno-stringop-truncation -g -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -g -O2 -ffile-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-uninitialized -Wno-implicit-fallthrough -Iinclude -I/usr/include/postgresql -I. -I./ -I/usr/include/postgresql/14/server -I/usr/include/postgresql/internal  -Wdate-time -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -I/usr/include/libxml2   -c -o src/pg_cron.o src/pg_cron.c
src/pg_cron.c: In function ‘ShouldRunTask’:
src/pg_cron.c:948:41: error: passing argument 1 of ‘pg_localtime’ from incompatible pointer type [-Werror=incompatible-pointer-types]
  948 |         struct pg_tm* tm = pg_localtime(&currentTime_t, pg_tzset(cron_timezone));
      |                                         ^~~~~~~~~~~~~~
      |                                         |
      |                                         time_t * {aka long int *}
In file included from /usr/include/postgresql/14/server/miscadmin.h:29,
                 from src/pg_cron.c:20:
/usr/include/postgresql/14/server/pgtime.h:48:52: note: expected ‘const pg_time_t *’ {aka ‘const long long int *’} but argument is of type ‘time_t *’ {aka ‘long int *’}
   48 | extern struct pg_tm *pg_localtime(const pg_time_t *timep, const pg_tz *tz);
      |                                   ~~~~~~~~~~~~~~~~~^~~~~
```

diff --git a/src/pg_cron.c b/src/pg_cron.c
index 0bfa050..e52c371 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -948,7 +948,7 @@ static bool
 ShouldRunTask(entry *schedule, TimestampTz currentTime, bool doWild,
 			  bool doNonWild)
 {
-	time_t currentTime_t = timestamptz_to_time_t(currentTime);
+	pg_time_t currentTime_t = timestamptz_to_time_t(currentTime);
 	struct pg_tm* tm = pg_localtime(&currentTime_t, pg_tzset(cron_timezone));
 
 	int minute = tm->tm_min -FIRST_MINUTE;

COMMIT_HASH:2b606102119b5f4f489cd967dd52e3dc5a8d918c|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-02-13 12:49:20 +0100|TITLE:Merge pull request #242 from zhjwpku/fix_pg16_compile_issue|MESSAGE:
COMMIT_HASH:607f80e220dcb237711bf1881f4cd6958c30825f|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-02-13 12:48:54 +0100|TITLE:Merge pull request #243 from zhjwpku/fix_some_vulnerabilities|MESSAGE:avoid attacker to override operator
COMMIT_HASH:7caa4f58bc63931731c7b72f7020cb66d92f42a7|AUTHOR_NAME:Junwang Zhao|AUTHOR_EMAIL:zhjwpku@gmail.com|DATE:2023-02-13 19:11:48 +0800|TITLE:avoid attacker to override operator|MESSAGE:same as #192, this fix avoid operator override during
extension upgrade.

Signed-off-by: Junwang Zhao <zhjwpku@gmail.com>

diff --git a/pg_cron--1.2--1.3.sql b/pg_cron--1.2--1.3.sql
index a86e4d1..8af8056 100644
--- a/pg_cron--1.2--1.3.sql
+++ b/pg_cron--1.2--1.3.sql
@@ -17,7 +17,7 @@ CREATE TABLE cron.job_run_details (
 GRANT SELECT ON cron.job_run_details TO public;
 GRANT DELETE ON cron.job_run_details TO public;
 ALTER TABLE cron.job_run_details ENABLE ROW LEVEL SECURITY;
-CREATE POLICY cron_job_run_details_policy ON cron.job_run_details USING (username = current_user);
+CREATE POLICY cron_job_run_details_policy ON cron.job_run_details USING (username OPERATOR(pg_catalog.=) current_user);
 
 SELECT pg_catalog.pg_extension_config_dump('cron.job_run_details', '');
 SELECT pg_catalog.pg_extension_config_dump('cron.runid_seq', '');

COMMIT_HASH:a37748d2751013124bffbb4b7db695138d7110b1|AUTHOR_NAME:Junwang Zhao|AUTHOR_EMAIL:zhjwpku@gmail.com|DATE:2023-02-13 17:28:15 +0800|TITLE:fix pg 16 compile error|MESSAGE:pgcron does not build agaist postgres upstream because pg 16 has
the following two changes:

1. c727f511bd7bf3c58063737bcf7a8f331346f253 refactor aclcheck
   functions, use one common `object_aclcheck` to replace all
   dozens of mostly-duplicate `pg_foo_aclcheck()` functions.
2. 0a20ff54f5e66158930d5328f89f087d4e9ab400 introduced
   utils/guc_hooks.h and removed commands/variable.h

This patch address these issues and make pg_cron compile agaist
postgres version 16.

Signed-off-by: Junwang Zhao <zhjwpku@gmail.com>

diff --git a/src/job_metadata.c b/src/job_metadata.c
index aaa95f1..c95a802 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -26,6 +26,9 @@
 #include "access/xact.h"
 #include "access/xlog.h"
 #include "catalog/pg_extension.h"
+#if (PG_VERSION_NUM >= 160000)
+#include "catalog/pg_database.h"
+#endif
 #include "catalog/indexing.h"
 #include "catalog/namespace.h"
 #include "commands/extension.h"
@@ -303,8 +306,14 @@ ScheduleCronJob(text *scheduleText, text *commandText, text *databaseText,
 	}
 
 	/* ensure the user that is used in the job can connect to the database */
+#if (PG_VERSION_NUM >= 160000)
+	aclresult = object_aclcheck(DatabaseRelationId,
+								get_database_oid(database_name, false),
+								userIdcheckacl, ACL_CONNECT);
+#else
 	aclresult = pg_database_aclcheck(get_database_oid(database_name, false),
 										userIdcheckacl, ACL_CONNECT);
+#endif
 
 	if (aclresult != ACLCHECK_OK)
 		elog(ERROR, "User %s does not have CONNECT privilege on %s",
@@ -1273,7 +1282,14 @@ AlterJob(int64 jobId, text *scheduleText, text *commandText, text *databaseText,
 	{
 		database_name = text_to_cstring(databaseText);
 		/* ensure the user that is used in the job can connect to the database */
-		aclresult = pg_database_aclcheck(get_database_oid(database_name, false), userIdcheckacl, ACL_CONNECT);
+#if (PG_VERSION_NUM >= 160000)
+		aclresult = object_aclcheck(DatabaseRelationId,
+									get_database_oid(database_name, false),
+									userIdcheckacl, ACL_CONNECT);
+#else
+		aclresult = pg_database_aclcheck(get_database_oid(database_name, false),
+										 userIdcheckacl, ACL_CONNECT);
+#endif
 
 		if (aclresult != ACLCHECK_OK)
 			elog(ERROR, "User %s does not have CONNECT privilege on %s", GetUserNameFromId(userIdcheckacl, false), database_name);
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 399551c..0bfa050 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -60,7 +60,11 @@
 #include "commands/extension.h"
 #include "commands/sequence.h"
 #include "commands/trigger.h"
+#if (PG_VERSION_NUM >= 160000)
+#include "utils/guc_hooks.h"
+#else
 #include "commands/variable.h"
+#endif
 #include "lib/stringinfo.h"
 #include "libpq-fe.h"
 #include "libpq/pqmq.h"

COMMIT_HASH:37b56877bd1f27eac1b76196879c673125185084|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2023-02-09 15:27:18 +0100|TITLE:Fix bug that causes some cron schedules to get incorrectly parsed|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1aba168..06954ca 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,7 @@
+### pg_cron v1.5.1 (February 9, 2023) ###
+
+* Fixes a bug that caused incorrect parsing of some crons schedules
+
 ### pg_cron v1.5.0 (February 7, 2023) ###
 
 * Adds the possibility of scheduling a job with a 1-59 second interval
diff --git a/src/entry.c b/src/entry.c
index 6b592c8..994cc3b 100644
--- a/src/entry.c
+++ b/src/entry.c
@@ -72,7 +72,7 @@ parse_cron_entry(char *schedule)
 	 *	minutes hours doms months dows USERNAME cmd\n
 	 */
 
-	ecode_e	ecode = e_none;
+	ecode_e ecode = e_none;
 	entry *e = (entry *) calloc(sizeof(entry), sizeof(char));
 	int	ch = 0;
 	char cmd[MAX_COMMAND];
@@ -231,7 +231,7 @@ parse_cron_entry(char *schedule)
 	return e;
 
  eof:
-	elog(LOG, "failed to parse entry %d", ecode);
+	elog(DEBUG1, "failed to parse entry %d", ecode);
 	free_entry(e);
 	while (ch != EOF && ch != '\n')
 		ch = get_char(file);
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 0d2f674..aaa95f1 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -1485,7 +1485,17 @@ ParseSchedule(char *scheduleText)
 	uint32 secondsInterval = 0;
 
 	/*
-	 * Parse as interval on seconds or fall back to trying cron schedule.
+	 * First try to parse as a cron schedule.
+	 */
+	entry *schedule = parse_cron_entry(scheduleText);
+	if (schedule != NULL)
+	{
+		/* valid cron schedule */
+		return schedule;
+	}
+
+	/*
+	 * Parse as interval on seconds.
 	 */
 	if (TryParseInterval(scheduleText, &secondsInterval))
 	{
@@ -1494,7 +1504,8 @@ ParseSchedule(char *scheduleText)
 		return schedule;
 	}
 
-	return parse_cron_entry(scheduleText);
+	elog(LOG, "failed to parse schedule: %s", scheduleText);
+	return NULL;
 }
 
 
@@ -1505,19 +1516,25 @@ ParseSchedule(char *scheduleText)
 static bool
 TryParseInterval(char *scheduleText, uint32 *secondsInterval)
 {
+	char lastChar = '\0';
 	char plural = '\0';
 	char extra = '\0';
 	char *lowercaseSchedule = asc_tolower(scheduleText, strlen(scheduleText));
 
-	int numParts = sscanf(lowercaseSchedule, " %u second%c %c", secondsInterval,
-						  &plural, &extra);
+	int numParts = sscanf(lowercaseSchedule, " %u secon%c%c %c", secondsInterval,
+						  &lastChar, &plural, &extra);
+	if (lastChar != 'd')
+	{
+		/* value did not have a "second" suffix */
+		return false;
+	}
 
-	if (numParts == 1)
+	if (numParts == 2)
 	{
 		/* <number> second (allow "2 second") */
 		return 0 < *secondsInterval && *secondsInterval < 60;
 	}
-	else if (numParts == 2 && plural == 's')
+	else if (numParts == 3 && plural == 's')
 	{
 		/* <number> seconds (allow "1 seconds") */
 		return 0 < *secondsInterval && *secondsInterval < 60;

COMMIT_HASH:77c03c26168eda08366bb48bfa81acf33184077d|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2023-02-07 10:25:14 +0100|TITLE:Add v1.5.0 changelog|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 8df26db..1aba168 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,18 @@
+### pg_cron v1.5.0 (February 7, 2023) ###
+
+* Adds the possibility of scheduling a job with a 1-59 second interval
+* Adds a cron.timezone setting to configure the timezone of cron schedules
+* Removes pg_stat_activity reporting of internal pg_cron metadata queries
+* Fixes a bug that caused issues with long job names
+* Fixes a bug that caused inactive @reboot jobs to still run
+* Fixes a bug that could limit concurrency for background workers
+* Fixes a bug that prevented compiling on ARM
+* Fixes regression tests for PostgreSQL <= 12
+
 ### pg_cron v1.4.2 (July 15, 2022) ###
 
 * Fixes a bug that could lead to privilege escalation if users can trigger CREATE EXTENSION
-* Add compatibility for PostgreSQL 15 beta
+* Add compatibility for PostgreSQL 15
 * Fixes a bug that could cause unschedule to crash
 * Ensures that cron.max_running_jobs is not higher than possible connection count
 

COMMIT_HASH:6318ca575eeddaafee9ed9cd5217120bce82b622|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2023-02-07 10:25:03 +0100|TITLE:Add Microsoft code of conduct|MESSAGE:
diff --git a/README.md b/README.md
index ce1fe87..9b63f45 100644
--- a/README.md
+++ b/README.md
@@ -209,3 +209,8 @@ The following table keeps track of which of the major managed Postgres services
 | [ScaleGrid](https://scalegrid.io/postgresql.html) | :heavy_check_mark:  |
 | [Scaleway](https://www.scaleway.com/en/database/) | :heavy_check_mark:  |
 | [Supabase](https://supabase.io/docs/guides/database) | :heavy_check_mark:  |
+
+
+## Code of Conduct
+
+This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.

COMMIT_HASH:aee85c922f95bffa032bf4824717fc779e79a36d|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-02-07 10:15:48 +0100|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index e1911d2..ce1fe87 100644
--- a/README.md
+++ b/README.md
@@ -110,8 +110,9 @@ By default, the pg_cron background worker expects its metadata tables to be crea
 # optionally, specify the database in which the pg_cron background worker should run (defaults to postgres)
 cron.database_name = 'postgres'
 ```
+`pg_cron` may only be installed to one database in a cluster. If you need to run jobs in multiple databases, use `cron.schedule_in_database()`.
 
-Previously we could only use GMT time, but now you can adapt your time by setting cron.timezone. You can configure this by setting the `cron.timezone` configuration parameter in postgresql.conf.
+Previously pg_cron could only use GMT time, but now you can adapt your time by setting `cron.timezone` in postgresql.conf.
 ```
 # add to postgresql.conf
 
@@ -121,8 +122,6 @@ cron.timezone = 'PRC'
 
 After restarting PostgreSQL, you can create the pg_cron functions and metadata tables using `CREATE EXTENSION pg_cron`.
 
-_Note: `pg_cron` may only be installed to one database in a cluster. If you need to run jobs in multiple databases, use `cron.schedule_in_database()`._
-
 ```sql
 -- run as superuser:
 CREATE EXTENSION pg_cron;
@@ -131,9 +130,17 @@ CREATE EXTENSION pg_cron;
 GRANT USAGE ON SCHEMA cron TO marco;
 ```
 
+### Ensuring pg_cron can start jobs
+
 **Important**: By default, pg_cron uses libpq to open a new connection to the local database, which needs to be allowed by [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html). 
 It may be necessary to enable `trust` authentication for connections coming from localhost in  for the user running the cron job, or you can add the password to a [.pgpass file](https://www.postgresql.org/docs/current/static/libpq-pgpass.html), which libpq will use when opening a connection. 
 
+You can also use a unix domain socket directory as the hostname and enable `trust` authentication for local connections in [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html), which is normally safe:
+```
+# Connect via a unix domain socket
+cron.host = '/tmp'
+```
+
 Alternatively, pg_cron can be configured to use background workers. In that case, the number of concurrent jobs is limited by the `max_worker_processes` setting, so you may need to raise that.
 
 ```
@@ -143,13 +150,36 @@ cron.use_background_workers = on
 max_worker_processes = 20
 ```
 
-You can also use a unix domain socket directory as the hostname and enable `trust` authentication for local connections in [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html), which is normally safe:
-```
-# Connect via a unix domain socket
-cron.host = '/tmp'
+For security, jobs are executed in the database in which the `cron.schedule` function is called with the same permissions as the current user. In addition, users are only able to see their own jobs in the `cron.job` table.
+
+## Viewing job run details
+
+You can view the status of running and recently completed job runs in the `cron.job_run_details`:
+
+```sql
+select * from cron.job_run_details order by start_time desc limit 5;
+┌───────┬───────┬─────────┬──────────┬──────────┬───────────────────┬───────────┬──────────────────┬───────────────────────────────┬───────────────────────────────┐
+│ jobid │ runid │ job_pid │ database │ username │      command      │  status   │  return_message  │          start_time           │           end_time            │
+├───────┼───────┼─────────┼──────────┼──────────┼───────────────────┼───────────┼──────────────────┼───────────────────────────────┼───────────────────────────────┤
+│    10 │  4328 │    2610 │ postgres │ marco    │ select process()  │ succeeded │ SELECT 1         │ 2023-02-07 09:30:00.098164+01 │ 2023-02-07 09:30:00.130729+01 │
+│    10 │  4327 │    2609 │ postgres │ marco    │ select process()  │ succeeded │ SELECT 1         │ 2023-02-07 09:29:00.015168+01 │ 2023-02-07 09:29:00.832308+01 │
+│    10 │  4321 │    2603 │ postgres │ marco    │ select process()  │ succeeded │ SELECT 1         │ 2023-02-07 09:28:00.011965+01 │ 2023-02-07 09:28:01.420901+01 │
+│    10 │  4320 │    2602 │ postgres │ marco    │ select process()  │ failed    │ server restarted │ 2023-02-07 09:27:00.011833+01 │ 2023-02-07 09:27:00.72121+01  │
+│     9 │  4320 │    2602 │ postgres │ marco    │ select do_stuff() │ failed    │ job canceled     │ 2023-02-07 09:26:00.011833+01 │ 2023-02-07 09:26:00.22121+01  │
+└───────┴───────┴─────────┴──────────┴──────────┴───────────────────┴───────────┴──────────────────┴───────────────────────────────┴───────────────────────────────┘
+(10 rows)
+```
+ 
+The records in `cron.job_run_details` are not cleaned automatically, but every user that can schedule cron jobs also has permission to delete their own `cron.job_run_details` records. 
+
+Especially when you have jobs that run every few seconds, it can be a good idea to clean up regularly, which can easily be done using pg_cron itself:
+
+```sql
+-- Delete old cron.job_run_details records of the current user every day at noon
+SELECT  cron.schedule('delete-job-run-details', '0 12 * * *', $$DELETE FROM cron.job_run_details WHERE end_time < now() - interval '7 days'$$);
 ```
 
-For security, jobs are executed in the database in which the `cron.schedule` function is called with the same permissions as the current user. In addition, users are only able to see their own jobs in the `cron.job` table.
+If you do not want to use `cron.job_run_details` at all, then you can add `cron.log_run = off` to `postgresql.conf`.
 
 ## Example use cases
 

COMMIT_HASH:71642fd1bf286d83d3c2754e0965b8be24250a7c|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-02-07 09:52:11 +0100|TITLE:Merge pull request #235 from citusdata/marcocitus/jobs-in-seconds|MESSAGE:
COMMIT_HASH:c15004f33e9916ea356b1b60ded34074d710856b|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2023-02-04 16:59:21 +0100|TITLE:Add possibility to schedule jobs by interval in seconds|MESSAGE:
diff --git a/README.md b/README.md
index 1b08091..e1911d2 100644
--- a/README.md
+++ b/README.md
@@ -4,7 +4,7 @@
 
 ## What is pg_cron?
 
-pg_cron is a simple cron-based job scheduler for PostgreSQL (10 or higher) that runs inside the database as an extension. It uses the same syntax as regular cron, but it allows you to schedule PostgreSQL commands directly from the database:
+pg_cron is a simple cron-based job scheduler for PostgreSQL (10 or higher) that runs inside the database as an extension. It uses the same syntax as regular cron, but it allows you to schedule PostgreSQL commands directly from the database. You can also use '[1-59] seconds' to schedule a job based on an interval.
 
 ```sql
 -- Delete old data on Saturday at 3:30am (GMT)
@@ -41,6 +41,9 @@ SELECT cron.schedule_in_database('weekly-vacuum', '0 4 * * 0', 'VACUUM', 'some_o
  schedule
 ----------
        44
+
+-- Call a stored procedure every 5 seconds
+SELECT cron.schedule('process-updates', '5 seconds', 'CALL process_updates()'); 
 ```
 
 pg_cron can run multiple jobs in parallel, but it runs at most one instance of a job at a time. If a second run is supposed to start before the first one finishes, then the second run is queued and started as soon as the first run completes.
diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index 52ba985..aa3b1fa 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -29,9 +29,35 @@ SELECT cron.unschedule(1);
 -- Invalid input: input too long
 SELECT cron.schedule(repeat('a', 1000), '');
 ERROR:  invalid schedule: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
+-- Invalid input: missing parts
+SELECT cron.schedule('* * * *', 'SELECT 1'); 
+ERROR:  invalid schedule: * * * *
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
+-- Invalid input: trailing characters
+SELECT cron.schedule('5 secondc', 'SELECT 1'); 
+ERROR:  invalid schedule: 5 secondc
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
+SELECT cron.schedule('50 seconds c', 'SELECT 1'); 
+ERROR:  invalid schedule: 50 seconds c
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
+-- Invalid input: seconds out of range
+SELECT cron.schedule('-1 seconds', 'SELECT 1'); 
+ERROR:  invalid schedule: -1 seconds
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
+SELECT cron.schedule('0 seconds', 'SELECT 1'); 
+ERROR:  invalid schedule: 0 seconds
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
+SELECT cron.schedule('60 seconds', 'SELECT 1'); 
+ERROR:  invalid schedule: 60 seconds
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
+SELECT cron.schedule('10000000000 seconds', 'SELECT 1'); 
+ERROR:  invalid schedule: 10000000000 seconds
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
 -- Try to update pg_cron on restart
 SELECT cron.schedule('@restar', 'ALTER EXTENSION pg_cron UPDATE');
 ERROR:  invalid schedule: @restar
+HINT:  Use cron format (e.g. 5 4 * * *), or interval format '[1-59] seconds'
 SELECT cron.schedule('@restart', 'ALTER EXTENSION pg_cron UPDATE');
  schedule 
 ----------
@@ -200,12 +226,46 @@ CREATE OR REPLACE FUNCTION public.func1(text, current_setting) RETURNS text
 CREATE OR REPLACE FUNCTION public.func1(current_setting) RETURNS text
     LANGUAGE sql volatile AS 'INSERT INTO test(data) VALUES (current_user); SELECT current_database()::text;';
 CREATE CAST (current_setting AS text) WITH FUNCTION public.func1(current_setting) AS IMPLICIT;
-CREATE EXTENSION pg_cron VERSION '1.4';
+CREATE EXTENSION pg_cron;
 select * from public.test;
  data 
 ------
 (0 rows)
 
+-- valid interval jobs
+SELECT cron.schedule('1 second', 'SELECT 1'); 
+ schedule 
+----------
+        1
+(1 row)
+
+SELECT cron.schedule(' 30 sEcOnDs ', 'SELECT 1'); 
+ schedule 
+----------
+        2
+(1 row)
+
+SELECT cron.schedule('59 seconds', 'SELECT 1'); 
+ schedule 
+----------
+        3
+(1 row)
+
+SELECT cron.schedule('17  seconds ', 'SELECT 1'); 
+ schedule 
+----------
+        4
+(1 row)
+
+SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
+ jobid | jobname |   schedule   | command  
+-------+---------+--------------+----------
+     1 |         | 1 second     | SELECT 1
+     2 |         |  30 sEcOnDs  | SELECT 1
+     3 |         | 59 seconds   | SELECT 1
+     4 |         | 17  seconds  | SELECT 1
+(4 rows)
+
 -- cleaning
 DROP EXTENSION pg_cron;
 drop user pgcron_cront;
diff --git a/include/cron.h b/include/cron.h
index 02480cf..2f38f86 100644
--- a/include/cron.h
+++ b/include/cron.h
@@ -159,7 +159,7 @@ typedef	struct _entry {
 	uid_t		uid;	
 	gid_t		gid;
 	char		**envp;
-	char		*cmd;
+	int         secondsInterval;
 	bitstr_t	bit_decl(minute, MINUTE_COUNT);
 	bitstr_t	bit_decl(hour,   HOUR_COUNT);
 	bitstr_t	bit_decl(dom,    DOM_COUNT);
diff --git a/include/task_states.h b/include/task_states.h
index f35b7e2..8b135cd 100644
--- a/include/task_states.h
+++ b/include/task_states.h
@@ -49,6 +49,8 @@ typedef struct CronTask
 	PGconn *connection;
 	PostgresPollingStatusType pollingStatus;
 	TimestampTz startDeadline;
+	TimestampTz lastStartTime;
+	uint32 secondsInterval;
 	bool isSocketReady;
 	bool isActive;
 	char *errorMessage;
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index 417ad53..febcf47 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -13,6 +13,19 @@ SELECT cron.unschedule(1);
 -- Invalid input: input too long
 SELECT cron.schedule(repeat('a', 1000), '');
 
+-- Invalid input: missing parts
+SELECT cron.schedule('* * * *', 'SELECT 1'); 
+
+-- Invalid input: trailing characters
+SELECT cron.schedule('5 secondc', 'SELECT 1'); 
+SELECT cron.schedule('50 seconds c', 'SELECT 1'); 
+
+-- Invalid input: seconds out of range
+SELECT cron.schedule('-1 seconds', 'SELECT 1'); 
+SELECT cron.schedule('0 seconds', 'SELECT 1'); 
+SELECT cron.schedule('60 seconds', 'SELECT 1'); 
+SELECT cron.schedule('10000000000 seconds', 'SELECT 1'); 
+
 -- Try to update pg_cron on restart
 SELECT cron.schedule('@restar', 'ALTER EXTENSION pg_cron UPDATE');
 SELECT cron.schedule('@restart', 'ALTER EXTENSION pg_cron UPDATE');
@@ -117,9 +130,16 @@ CREATE OR REPLACE FUNCTION public.func1(current_setting) RETURNS text
 
 CREATE CAST (current_setting AS text) WITH FUNCTION public.func1(current_setting) AS IMPLICIT;
 
-CREATE EXTENSION pg_cron VERSION '1.4';
+CREATE EXTENSION pg_cron;
 select * from public.test;
 
+-- valid interval jobs
+SELECT cron.schedule('1 second', 'SELECT 1'); 
+SELECT cron.schedule(' 30 sEcOnDs ', 'SELECT 1'); 
+SELECT cron.schedule('59 seconds', 'SELECT 1'); 
+SELECT cron.schedule('17  seconds ', 'SELECT 1'); 
+SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
+
 -- cleaning
 DROP EXTENSION pg_cron;
 drop user pgcron_cront;
diff --git a/src/entry.c b/src/entry.c
index 6febb8c..6b592c8 100644
--- a/src/entry.c
+++ b/src/entry.c
@@ -44,8 +44,6 @@ static int	set_element(bitstr_t *, int, int, int);
 void
 free_entry(entry *e)
 {
-	if (e->cmd)
-		free(e->cmd);
 	free(e);
 }
 
diff --git a/src/job_metadata.c b/src/job_metadata.c
index f654332..0d2f674 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -37,6 +37,7 @@
 #include "utils/acl.h"
 #include "utils/builtins.h"
 #include "utils/fmgroids.h"
+#include "utils/formatting.h"
 #include "utils/inval.h"
 #include "utils/lsyscache.h"
 #include "utils/memutils.h"
@@ -88,6 +89,9 @@ static void AlterJob(int64 jobId, text *scheduleText, text *commandText,
 						text *databaseText, text *usernameText, bool *active);
 
 static Oid GetRoleOidIfCanLogin(char *username);
+static entry * ParseSchedule(char *scheduleText);
+static bool TryParseInterval(char *scheduleText, uint32 *secondsInterval);
+
 
 /* SQL-callable functions */
 PG_FUNCTION_INFO_V1(cron_schedule);
@@ -215,12 +219,14 @@ ScheduleCronJob(text *scheduleText, text *commandText, text *databaseText,
 
 	/* check schedule is valid */
 	schedule = text_to_cstring(scheduleText);
-	parsedSchedule = parse_cron_entry(schedule);
+	parsedSchedule = ParseSchedule(schedule);
 
 	if (parsedSchedule == NULL)
 	{
 		ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
-						errmsg("invalid schedule: %s", schedule)));
+						errmsg("invalid schedule: %s", schedule),
+						errhint("Use cron format (e.g. 5 4 * * *), or interval "
+								"format '[1-59] seconds'")));
 	}
 
 	free_entry(parsedSchedule);
@@ -975,7 +981,7 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 		}
 	}
 
-	parsedSchedule = parse_cron_entry(job->scheduleText);
+	parsedSchedule = ParseSchedule(job->scheduleText);
 	if (parsedSchedule != NULL)
 	{
 		/* copy the schedule and free the allocated memory immediately */
@@ -1282,12 +1288,14 @@ AlterJob(int64 jobId, text *scheduleText, text *commandText, text *databaseText,
 	if (scheduleText != NULL)
 	{
 		schedule = text_to_cstring(scheduleText);
-		parsedSchedule = parse_cron_entry(schedule);
+		parsedSchedule = ParseSchedule(schedule);
 
 		if (parsedSchedule == NULL)
 		{
 			ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
-					errmsg("invalid schedule: %s", schedule)));
+					errmsg("invalid schedule: %s", schedule),
+					errhint("Use cron format (e.g. 5 4 * * *), or interval "
+							"format '[1-59] seconds'")));
 		}
 
 		free_entry(parsedSchedule);
@@ -1464,3 +1472,56 @@ JobTableExists(void)
 
 	return jobTableOid != InvalidOid;
 }
+
+
+/*
+ * ParseSchedule attempts to parse a cron schedule or an interval in seconds.
+ * The returned pointer is allocated using malloc and should be freed by the
+ * caller.
+ */
+static entry *
+ParseSchedule(char *scheduleText)
+{
+	uint32 secondsInterval = 0;
+
+	/*
+	 * Parse as interval on seconds or fall back to trying cron schedule.
+	 */
+	if (TryParseInterval(scheduleText, &secondsInterval))
+	{
+		entry *schedule = calloc(sizeof(entry), sizeof(char));
+		schedule->secondsInterval = secondsInterval;
+		return schedule;
+	}
+
+	return parse_cron_entry(scheduleText);
+}
+
+
+/*
+ * TryParseInterval returns whether scheduleText is of the form
+ * <positive number> second[s].
+ */
+static bool
+TryParseInterval(char *scheduleText, uint32 *secondsInterval)
+{
+	char plural = '\0';
+	char extra = '\0';
+	char *lowercaseSchedule = asc_tolower(scheduleText, strlen(scheduleText));
+
+	int numParts = sscanf(lowercaseSchedule, " %u second%c %c", secondsInterval,
+						  &plural, &extra);
+
+	if (numParts == 1)
+	{
+		/* <number> second (allow "2 second") */
+		return 0 < *secondsInterval && *secondsInterval < 60;
+	}
+	else if (numParts == 2 && plural == 's')
+	{
+		/* <number> seconds (allow "1 seconds") */
+		return 0 < *secondsInterval && *secondsInterval < 60;
+	}
+
+	return false;
+}
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 3fe8530..399551c 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -683,6 +683,27 @@ StartAllPendingRuns(List *taskList, TimestampTz currentTime)
 		RebootJobsScheduled = true;
 	}
 
+	foreach(taskCell, taskList)
+	{
+		CronTask *task = (CronTask *) lfirst(taskCell);
+
+		if (task->secondsInterval > 0 && task->isActive)
+		{
+			/*
+			 * For interval jobs, if a task takes longer than the interval,
+			 * we only queue up once. So if a task that is supposed to run
+			 * every 30 seconds takes 5 minutes, we start another run
+			 * immediately after 5 minutes, but then return to regular cadence.
+			 */
+			if (task->pendingRunCount == 0 &&
+				TimestampDifferenceExceeds(task->lastStartTime, currentTime,
+										   task->secondsInterval * 1000))
+			{
+				task->pendingRunCount += 1;
+			}
+		}
+	}
+
 	if (lastMinute == 0)
 	{
 		lastMinute = TimestampMinuteStart(currentTime);
@@ -1052,6 +1073,22 @@ PollForTasks(List *taskList)
 
 		if (task->state == CRON_TASK_WAITING && task->pendingRunCount == 0)
 		{
+			/*
+			 * Make sure we do not wait past the next run time of an interval
+			 * job.
+			 */
+			if (task->secondsInterval > 0)
+			{
+				TimestampTz nextRunTime =
+					TimestampTzPlusMilliseconds(task->lastStartTime,
+												task->secondsInterval * 1000);
+
+				if (TimestampDifferenceExceeds(nextRunTime, nextEventTime, 0))
+				{
+					nextEventTime = nextRunTime;
+				}
+			}
+
 			/* don't poll idle tasks */
 			continue;
 		}
@@ -1122,9 +1159,11 @@ PollForTasks(List *taskList)
 	pollTimeout = waitSeconds * 1000 + waitMicros / 1000;
 	if (pollTimeout <= 0)
 	{
-		pfree(polledTasks);
-		pfree(pollFDs);
-		return;
+		/*
+		 * Interval jobs might frequently be overdue, inject a small
+		 * 1ms wait to avoid getting into a tight loop.
+		 */
+		pollTimeout = 1;
 	}
 	else if (pollTimeout > MaxWait)
 	{
@@ -1238,6 +1277,8 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			else
 				task->state = CRON_TASK_START;
 
+			task->lastStartTime = currentTime;
+
 			RunningTaskCount++;
 
 			/* Add new entry to audit table. */
diff --git a/src/task_states.c b/src/task_states.c
index f65be48..5974e7e 100644
--- a/src/task_states.c
+++ b/src/task_states.c
@@ -102,6 +102,7 @@ RefreshTaskHash(void)
 
 		task = GetCronTask(job->jobId);
 		task->isActive = job->active;
+		task->secondsInterval = job->schedule.secondsInterval;
 	}
 
 	CronJobCacheValid = true;
@@ -122,6 +123,13 @@ GetCronTask(int64 jobId)
 	if (!isPresent)
 	{
 		InitializeCronTask(task, jobId);
+
+		/*
+		 * We only initialize last run when entering into the hash.
+		 * The net effect is that the timer for the first run of an
+		 * interval job starts when pg_cron first learns about the job.
+		 */
+		task->lastStartTime = GetCurrentTimestamp();
 	}
 
 	return task;

COMMIT_HASH:12562f3022f6c660d922fa32b9ea628288910c3f|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2023-02-03 16:35:58 +0100|TITLE:Add missing isActive check for @reboot|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 35dddc4..3fe8530 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -673,7 +673,8 @@ StartAllPendingRuns(List *taskList, TimestampTz currentTime)
 			CronJob *cronJob = GetCronJob(task->jobId);
 			entry *schedule = &cronJob->schedule;
 
-			if (schedule->flags & WHEN_REBOOT)
+			if (schedule->flags & WHEN_REBOOT &&
+				task->isActive)
 			{
 				task->pendingRunCount += 1;
 			}

COMMIT_HASH:4b5f23085d7762523137e694adc093afeceb4551|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-02-05 15:06:44 +0100|TITLE:Merge pull request #231 from citusdata/marcocitus/fix-concurrent-bgw|MESSAGE:Fix issue #200 preventing concurrent background workers
COMMIT_HASH:92217f5ae28fa736a81371bac84be6adeff7c284|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-02-05 15:02:30 +0100|TITLE:Merge pull request #233 from citusdata/marcocitus/remove-activity|MESSAGE:Remove pg_stat_activity reporting from job metadata queries
COMMIT_HASH:a1e7824a63bc135d275cd45fe3956f0dadf1561e|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-02-05 15:01:11 +0100|TITLE:Merge pull request #232 from citusdata/marcocitus/fix-job-name|MESSAGE:Make job name a text field
COMMIT_HASH:317d514612fc338f2e19c4c8cbfd7517f35071d7|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-02-04 18:19:33 +0100|TITLE:Merge pull request #236 from citusdata/marcocitus-patch-1|MESSAGE:Change PostgreSQL 12 to 15 in README
COMMIT_HASH:5e2c4346fec542a889911fa575e710bae9ed1293|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-02-04 17:18:22 +0100|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index d63c3a5..1b08091 100644
--- a/README.md
+++ b/README.md
@@ -65,18 +65,18 @@ The code in pg_cron that handles parsing and scheduling comes directly from the
 
 ## Installing pg_cron
 
-Install on Red Hat, CentOS, Fedora, Amazon Linux with PostgreSQL 12 using [PGDG](https://yum.postgresql.org/repopackages/):
+Install on Red Hat, CentOS, Fedora, Amazon Linux with PostgreSQL 15 using [PGDG](https://yum.postgresql.org/repopackages/):
 
 ```bash
 # Install the pg_cron extension
-sudo yum install -y pg_cron_12
+sudo yum install -y pg_cron_15
 ```
 
-Install on Debian, Ubuntu with PostgreSQL 12 using [apt.postgresql.org](https://wiki.postgresql.org/wiki/Apt):
+Install on Debian, Ubuntu with PostgreSQL 15 using [apt.postgresql.org](https://wiki.postgresql.org/wiki/Apt):
 
 ```bash
 # Install the pg_cron extension
-sudo apt-get -y install postgresql-12-cron
+sudo apt-get -y install postgresql-15-cron
 ```
 
 You can also install pg_cron by building it from source:
@@ -85,7 +85,7 @@ You can also install pg_cron by building it from source:
 git clone https://github.com/citusdata/pg_cron.git
 cd pg_cron
 # Ensure pg_config is in your path, e.g.
-export PATH=/usr/pgsql-12/bin:$PATH
+export PATH=/usr/pgsql-15/bin:$PATH
 make && sudo PATH=$PATH make install
 ```
 

COMMIT_HASH:a7243b47c832a5f7300a9284d15d21d623f5a39e|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2023-02-03 17:38:01 +0100|TITLE:Remove pgstat_report_activity remove job metadata queries|MESSAGE:
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 9d137a5..c1713e4 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -844,7 +844,6 @@ LoadCronJobList(void)
 		PopActiveSnapshot();
 		CommitTransactionCommand();
 		MemoryContextSwitchTo(originalContext);
-		pgstat_report_activity(STATE_IDLE, NULL);
 
 		return NIL;
 	}
@@ -897,7 +896,6 @@ LoadCronJobList(void)
 	PopActiveSnapshot();
 	CommitTransactionCommand();
 	MemoryContextSwitchTo(originalContext);
-	pgstat_report_activity(STATE_IDLE, NULL);
 
 	return jobList;
 }
@@ -1082,8 +1080,6 @@ InsertJobRunDetail(int64 runId, int64 *jobId, char *database, char *username, ch
 	argTypes[5] = TEXTOID;
 	argValues[5] = CStringGetTextDatum(status);
 
-	pgstat_report_activity(STATE_RUNNING, querybuf.data);
-
 	if(SPI_execute_with_args(querybuf.data,
 		argCount, argTypes, argValues, NULL, false, 1) != SPI_OK_INSERT)
 		elog(ERROR, "SPI_exec failed: %s", querybuf.data);
@@ -1094,7 +1090,6 @@ InsertJobRunDetail(int64 runId, int64 *jobId, char *database, char *username, ch
 	PopActiveSnapshot();
 	CommitTransactionCommand();
 	MemoryContextSwitchTo(originalContext);
-	pgstat_report_activity(STATE_IDLE, NULL);
 }
 
 void
@@ -1186,8 +1181,6 @@ UpdateJobRunDetail(int64 runId, int32 *job_pid, char *status, char *return_messa
 	/* and add the where clause */
 	appendStringInfo(&querybuf, " where runid = $%d", i);
 
-	pgstat_report_activity(STATE_RUNNING, querybuf.data);
-
 	if(SPI_execute_with_args(querybuf.data,
 		i, argTypes, argValues, NULL, false, 1) != SPI_OK_UPDATE)
 		elog(ERROR, "SPI_exec failed: %s", querybuf.data);
@@ -1198,7 +1191,6 @@ UpdateJobRunDetail(int64 runId, int32 *job_pid, char *status, char *return_messa
 	PopActiveSnapshot();
 	CommitTransactionCommand();
 	MemoryContextSwitchTo(originalContext);
-	pgstat_report_activity(STATE_IDLE, NULL);
 }
 
 
@@ -1396,8 +1388,6 @@ MarkPendingRunsAsFailed(void)
 		, CRON_SCHEMA_NAME, JOB_RUN_DETAILS_TABLE_NAME, GetCronStatus(CRON_STATUS_FAILED), GetCronStatus(CRON_STATUS_STARTING), GetCronStatus(CRON_STATUS_RUNNING));
 
 
-	pgstat_report_activity(STATE_RUNNING, querybuf.data);
-
 	if (SPI_exec(querybuf.data, 0) != SPI_OK_UPDATE)
 		elog(ERROR, "SPI_exec failed: %s", querybuf.data);
 
@@ -1407,7 +1397,6 @@ MarkPendingRunsAsFailed(void)
 	PopActiveSnapshot();
 	CommitTransactionCommand();
 	MemoryContextSwitchTo(originalContext);
-	pgstat_report_activity(STATE_IDLE, NULL);
 }
 
 char *

COMMIT_HASH:c3c1c0e2045d875c3bbae2bc263414a0757d7b9c|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2023-02-03 14:23:20 +0100|TITLE:Fix issue #200 preventing concurrent background workers|MESSAGE:
diff --git a/include/task_states.h b/include/task_states.h
index ea33970..f35b7e2 100644
--- a/include/task_states.h
+++ b/include/task_states.h
@@ -16,6 +16,7 @@
 #include "libpq-fe.h"
 #include "postmaster/bgworker.h"
 #include "storage/dsm.h"
+#include "storage/shm_mq.h"
 #include "utils/timestamp.h"
 
 
@@ -52,6 +53,7 @@ typedef struct CronTask
 	bool isActive;
 	char *errorMessage;
 	bool freeErrorMessage;
+	shm_mq_handle *sharedMemoryQueue;
 	dsm_segment *seg;
 	BackgroundWorkerHandle handle;
 } CronTask;
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 50acb40..35dddc4 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -138,7 +138,7 @@ static void ManageCronTasks(List *taskList, TimestampTz currentTime);
 static void ManageCronTask(CronTask *task, TimestampTz currentTime);
 static void ExecuteSqlString(const char *sql);
 static void GetTaskFeedback(PGresult *result, CronTask *task);
-static void GetBgwTaskFeedback(shm_mq_handle *responseq, CronTask *task, bool running);
+static void ProcessBgwTaskFeedback(CronTask *task, bool running);
 
 static bool jobCanceled(CronTask *task);
 static bool jobStartupTimeout(CronTask *task, TimestampTz currentTime);
@@ -1399,7 +1399,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			 * there trying to write the queue long after we've gone away.)
 			 */
 			oldcontext = MemoryContextSwitchTo(TopMemoryContext);
-			shm_mq_attach(mq, task->seg, NULL);
+			task->sharedMemoryQueue = shm_mq_attach(mq, task->seg, NULL);
 			MemoryContextSwitchTo(oldcontext);
 
 			/*
@@ -1649,11 +1649,9 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 		case CRON_TASK_BGW_RUNNING:
 		{
 			pid_t pid;
-			shm_mq_handle *responseq;
-			shm_mq *mq;
-			shm_toc *toc;
 
 			Assert(UseBackgroundWorkers);
+
 			/* check if job has been removed */
 			if (jobCanceled(task))
 			{
@@ -1665,28 +1663,28 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				break;
 			}
 
-			toc = shm_toc_attach(PG_CRON_MAGIC, dsm_segment_address(task->seg));
-			#if PG_VERSION_NUM < 100000
-				mq = shm_toc_lookup(toc, PG_CRON_KEY_QUEUE);
-			#else
-				mq = shm_toc_lookup(toc, PG_CRON_KEY_QUEUE, false);
-			#endif
-			responseq = shm_mq_attach(mq, task->seg, NULL);
-
 			/* still waiting for job to complete */
 			if (GetBackgroundWorkerPid(&task->handle, &pid) != BGWH_STOPPED)
 			{
-				GetBgwTaskFeedback(responseq, task, true);
-				shm_mq_detach(responseq);
-				break;
+				bool isRunning = true;
+
+				/* process notices and warnings */
+				ProcessBgwTaskFeedback(task, isRunning);
 			}
+			else
+			{
+				bool isRunning = false;
 
-			GetBgwTaskFeedback(responseq, task, false);
+				/* process remaining notices and final task result */
+				ProcessBgwTaskFeedback(task, isRunning);
 
-			task->state = CRON_TASK_DONE;
-			dsm_detach(task->seg);
-			task->seg = NULL;
-			RunningTaskCount--;
+				task->state = CRON_TASK_DONE;
+
+				dsm_detach(task->seg);
+
+				task->seg = NULL;
+				RunningTaskCount--;
+			}
 
 			break;
 		}
@@ -1855,10 +1853,17 @@ GetTaskFeedback(PGresult *result, CronTask *task)
 	PQclear(result);
 }
 
+
+/*
+ * ProcessBgwTaskFeedback reads messages from a shared memory queue associated
+ * with the background worker that is executing a given task. If the task is
+ * still running, the function does not block if the queue is empty. Otherwise,
+ * it reads until the end of the queue.
+ */
 static void
-GetBgwTaskFeedback(shm_mq_handle *responseq, CronTask *task, bool running)
+ProcessBgwTaskFeedback(CronTask *task, bool running)
 {
-
+	shm_mq_handle *responseq = task->sharedMemoryQueue;
 	TimestampTz end_time;
 
 	Size            nbytes;
@@ -1874,11 +1879,15 @@ GetBgwTaskFeedback(shm_mq_handle *responseq, CronTask *task, bool running)
 	 */
 	for (;;)
 	{
+		/* do not wait if the task is running */
+		bool nowait = running;
+
 		/* Get next message. */
-		res = shm_mq_receive(responseq, &nbytes, &data, false);
+		res = shm_mq_receive(responseq, &nbytes, &data, nowait);
 
 		if (res != SHM_MQ_SUCCESS)
 			break;
+
 		initStringInfo(&msg);
 		resetStringInfo(&msg);
 		enlargeStringInfo(&msg, nbytes);

COMMIT_HASH:6fc9ca9e32cb82da1b128f3e89041a996a842f37|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2023-02-03 15:22:21 +0100|TITLE:Make job name a text field|MESSAGE:
diff --git a/include/cron_job.h b/include/cron_job.h
index 3d1e96e..738fbad 100644
--- a/include/cron_job.h
+++ b/include/cron_job.h
@@ -27,7 +27,7 @@ typedef struct FormData_cron_job
 	text database;
 	text userName;
 	bool active;
-	Name jobName;
+	text jobName;
 #endif
 } FormData_cron_job;
 
diff --git a/include/job_metadata.h b/include/job_metadata.h
index c0fe18a..16a782a 100644
--- a/include/job_metadata.h
+++ b/include/job_metadata.h
@@ -39,7 +39,7 @@ typedef struct CronJob
 	char *database;
 	char *userName;
 	bool active;
-	Name jobName;
+	char *jobName;
 } CronJob;
 
 
diff --git a/pg_cron--1.4-1--1.5.sql b/pg_cron--1.4-1--1.5.sql
new file mode 100644
index 0000000..5d96773
--- /dev/null
+++ b/pg_cron--1.4-1--1.5.sql
@@ -0,0 +1,9 @@
+ALTER TABLE cron.job ALTER COLUMN jobname TYPE text;
+
+DROP FUNCTION cron.unschedule(name);
+CREATE FUNCTION cron.unschedule(job_name text)
+    RETURNS bool
+    LANGUAGE C STRICT
+    AS 'MODULE_PATHNAME', $$cron_unschedule_named$$;
+COMMENT ON FUNCTION cron.unschedule(text)
+    IS 'unschedule a pg_cron job';
diff --git a/pg_cron.control b/pg_cron.control
index 4b7f088..b2bdf77 100644
--- a/pg_cron.control
+++ b/pg_cron.control
@@ -1,4 +1,5 @@
 comment = 'Job scheduler for PostgreSQL'
-default_version = '1.4-1'
+default_version = '1.5'
 module_pathname = '$libdir/pg_cron'
 relocatable = false
+schema = pg_catalog
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 9d137a5..1eb5c1a 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -662,8 +662,8 @@ cron_unschedule(PG_FUNCTION_ARGS)
 Datum
 cron_unschedule_named(PG_FUNCTION_ARGS)
 {
-	Datum jobNameDatum = PG_GETARG_DATUM(0);
-	Name jobName = DatumGetName(jobNameDatum);
+	Datum jobNameDatum = 0;
+	char *jobName = NULL;
 
 	Oid userId = GetUserId();
 	char *userName = GetUserNameFromId(userId, false);
@@ -676,10 +676,18 @@ cron_unschedule_named(PG_FUNCTION_ARGS)
 	bool indexOK = false;
 	HeapTuple heapTuple = NULL;
 
+	if (PG_ARGISNULL(0))
+	{
+		ereport(ERROR, (errmsg("job_name can not be NULL")));
+	}
+
+	jobNameDatum = PG_GETARG_DATUM(0);
+	jobName = TextDatumGetCString(jobNameDatum);
+
 	cronJobsTable = table_open(CronJobRelationId(), RowExclusiveLock);
 
 	ScanKeyInit(&scanKey[0], Anum_cron_job_jobname,
-				BTEqualStrategyNumber, F_NAMEEQ, jobNameDatum);
+				BTEqualStrategyNumber, F_TEXTEQ, jobNameDatum);
 	ScanKeyInit(&scanKey[1], Anum_cron_job_username,
 				BTEqualStrategyNumber, F_TEXTEQ, userNameDatum);
 
@@ -690,7 +698,7 @@ cron_unschedule_named(PG_FUNCTION_ARGS)
 	if (!HeapTupleIsValid(heapTuple))
 	{
 		ereport(ERROR, (errmsg("could not find valid entry for job '%s'",
-							   NameStr(*jobName))));
+							   jobName)));
 	}
 
 	EnsureDeletePermission(cronJobsTable, heapTuple);
@@ -961,7 +969,7 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 									 tupleDescriptor, &isJobNameNull);
 		if (!isJobNameNull)
 		{
-			job->jobName = DatumGetName(jobName);
+			job->jobName = TextDatumGetCString(jobName);
 		}
 		else
 		{

COMMIT_HASH:4eb9c3ce22448f34bfee10e6afe23848c0ed1e68|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-01-03 10:52:19 +0100|TITLE:Merge pull request #223 from ViliusS/fix-sunday|MESSAGE:Fix weekly example to really run on Sunday
COMMIT_HASH:193b59b332a7eb79e7c75ae8101bfb8aedb952f8|AUTHOR_NAME:Vilius Šumskas|AUTHOR_EMAIL:vilius@sumskas.eu|DATE:2023-01-03 09:57:54 +0200|TITLE:Fix weekly example to really run on Sunday|MESSAGE:
diff --git a/README.md b/README.md
index a335f07..d63c3a5 100644
--- a/README.md
+++ b/README.md
@@ -37,7 +37,7 @@ SELECT cron.unschedule(42);
           t
 
 -- Vacuum every Sunday at 4:00am (GMT) in a database other than the one pg_cron is installed in
-SELECT cron.schedule_in_database('weekly-vacuum', '0 4 * * *', 'VACUUM', 'some_other_database');
+SELECT cron.schedule_in_database('weekly-vacuum', '0 4 * * 0', 'VACUUM', 'some_other_database');
  schedule
 ----------
        44

COMMIT_HASH:2f0b7056dcea0d7306b45e48d6c22cd51a541fd3|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2023-01-02 09:37:59 +0100|TITLE:Merge pull request #222 from ecehansavas/fix-variable-shadow|MESSAGE:Fix variable shadowing
COMMIT_HASH:e6384787c2ba2b0bc4ab55f88cf63043d9925263|AUTHOR_NAME:Ecehan SAVAŞ BAŞAK|AUTHOR_EMAIL:esavas78@gmail.com|DATE:2022-12-29 22:26:09 +0300|TITLE:Fix variable shadowing|MESSAGE:
diff --git a/src/task_states.c b/src/task_states.c
index e934d2f..f65be48 100644
--- a/src/task_states.c
+++ b/src/task_states.c
@@ -100,7 +100,7 @@ RefreshTaskHash(void)
 	{
 		CronJob *job = (CronJob *) lfirst(jobCell);
 
-		CronTask *task = GetCronTask(job->jobId);
+		task = GetCronTask(job->jobId);
 		task->isActive = job->active;
 	}
 

COMMIT_HASH:2b3d4144a8c4d303e470f7f818fc47a955fbc5fe|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-12-13 10:14:15 +0100|TITLE:Merge pull request #220 from TsinghuaLucky912/time_zone|MESSAGE:
COMMIT_HASH:d3d4bb49f920a887b59741e9095ef631be55271c|AUTHOR_NAME:TsinghuaLucky912|AUTHOR_EMAIL:2903807914@qq.com|DATE:2022-12-13 16:58:34 +0800|TITLE:use check_timezone|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 526b655..023362d 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -184,7 +184,6 @@ static const struct config_enum_entry cron_message_level_options[] = {
 };
 
 static const char *cron_error_severity(int elevel);
-static bool check_cron_timezone(char **newval, void **extra, GucSource source);
 
 /*
  * _PG_init gets called when the extension is loaded.
@@ -310,7 +309,7 @@ _PG_init(void)
 		"GMT",
 		PGC_POSTMASTER,
 		GUC_SUPERUSER_ONLY,
-		check_cron_timezone, NULL, NULL);
+		check_timezone, NULL, NULL);
 
 	/* set up common data for all our workers */
 	worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
@@ -476,133 +475,6 @@ cron_error_severity(int elevel)
 	return elevel_char;
 }
 
-/*
- * TIMEZONE
- */
-
-/*
- * check_cron_timezone: GUC check_hook for cron.timezone
- */
-static bool
-check_cron_timezone(char **newval, void **extra, GucSource source)
-{
-	pg_tz	   *new_tz;
-	long		gmtoffset;
-	char	   *endptr;
-	double		hours;
-
-	if (pg_strncasecmp(*newval, "interval", 8) == 0)
-	{
-		/*
-		 * Support INTERVAL 'foo'.  This is for SQL spec compliance, not
-		 * because it has any actual real-world usefulness.
-		 */
-		const char *valueptr = *newval;
-		char	   *val;
-		Interval   *interval;
-
-		valueptr += 8;
-		while (isspace((unsigned char) *valueptr))
-			valueptr++;
-		if (*valueptr++ != '\'')
-			return false;
-		val = pstrdup(valueptr);
-		/* Check and remove trailing quote */
-		endptr = strchr(val, '\'');
-		if (!endptr || endptr[1] != '\0')
-		{
-			pfree(val);
-			return false;
-		}
-		*endptr = '\0';
-
-		/*
-		 * Try to parse it.  XXX an invalid interval format will result in
-		 * ereport(ERROR), which is not desirable for GUC.  We did what we
-		 * could to guard against this in flatten_set_variable_args, but a
-		 * string coming in from postgresql.conf might contain anything.
-		 */
-		interval = DatumGetIntervalP(DirectFunctionCall3(interval_in,
-														 CStringGetDatum(val),
-														 ObjectIdGetDatum(InvalidOid),
-														 Int32GetDatum(-1)));
-
-		pfree(val);
-		if (interval->month != 0)
-		{
-			GUC_check_errdetail("Cannot specify months in time zone interval.");
-			pfree(interval);
-			return false;
-		}
-		if (interval->day != 0)
-		{
-			GUC_check_errdetail("Cannot specify days in time zone interval.");
-			pfree(interval);
-			return false;
-		}
-
-		/* Here we change from SQL to Unix sign convention */
-		gmtoffset = -(interval->time / USECS_PER_SEC);
-		new_tz = pg_tzset_offset(gmtoffset);
-
-		pfree(interval);
-	}
-	else
-	{
-		/*
-		 * Try it as a numeric number of hours (possibly fractional).
-		 */
-		hours = strtod(*newval, &endptr);
-		if (endptr != *newval && *endptr == '\0')
-		{
-			/* Here we change from SQL to Unix sign convention */
-			gmtoffset = -hours * SECS_PER_HOUR;
-			new_tz = pg_tzset_offset(gmtoffset);
-		}
-		else
-		{
-			/*
-			 * Otherwise assume it is a timezone name, and try to load it.
-			 */
-			new_tz = pg_tzset(*newval);
-
-			if (!new_tz)
-			{
-				/* We need a valid time zone value here, otherwise it will affect the execution of the subsequent schedule. */
-				ereport(ERROR,
-						 errcode(ERRCODE_INVALID_PARAMETER_VALUE),
-						 errmsg("invalid value for parameter \"cron.timezone\": \"%s\"",
-								 *newval));
-			}
-
-			if (!pg_tz_acceptable(new_tz))
-			{
-				GUC_check_errmsg("time zone \"%s\" appears to use leap seconds",
-								 *newval);
-				GUC_check_errdetail("PostgreSQL does not support leap seconds.");
-				return false;
-			}
-		}
-	}
-
-	/* Test for failure in pg_tzset_offset, which we assume is out-of-range */
-	if (!new_tz)
-	{
-		GUC_check_errdetail("UTC timezone offset is out of range.");
-		return false;
-	}
-
-	/*
-	 * Pass back data for assign_timezone to use
-	 */
-	*extra = malloc(sizeof(pg_tz *));
-	if (!*extra)
-		return false;
-	*((pg_tz **) *extra) = new_tz;
-
-	return true;
-}
-
 /*
  * bgw_generate_returned_message -
  *      generates the message to be inserted into the job_run_details table

COMMIT_HASH:a2cc197a2cb123cc0119762645f42c89d7ba7ee1|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-12-12 21:08:12 +0100|TITLE:Merge pull request #221 from citusdata/reuse-backend-sigterm-handler|MESSAGE:Reuse backend SIGTERM handler for cron workers
COMMIT_HASH:66aee6f2a3605e58775d01c1819a463a6e36c89b|AUTHOR_NAME:aykutbozkurt|AUTHOR_EMAIL:aykut.bozkurt1995@gmail.com|DATE:2022-12-12 21:58:52 +0300|TITLE:Reuse backend SIGTERM handler for cron workers|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index a840467..3246663 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -118,7 +118,6 @@ void _PG_init(void);
 void _PG_fini(void);
 static void pg_cron_sigterm(SIGNAL_ARGS);
 static void pg_cron_sighup(SIGNAL_ARGS);
-static void pg_cron_background_worker_sigterm(SIGNAL_ARGS);
 PGDLLEXPORT void PgCronLauncherMain(Datum arg);
 PGDLLEXPORT void CronBackgroundWorker(Datum arg);
 
@@ -534,29 +533,6 @@ bgw_generate_returned_message(StringInfoData *display_msg, ErrorData edata)
 		appendStringInfo(display_msg, "\nCONTEXT: %s", edata.context);
 }
 
-/*
- * Signal handler for SIGTERM for background workers
- * 		When we receive a SIGTERM, we set InterruptPending and ProcDiePending
- * 		just like a normal backend.  The next CHECK_FOR_INTERRUPTS() will do the
- * 		right thing.
- */
-static void
-pg_cron_background_worker_sigterm(SIGNAL_ARGS)
-{
-	int save_errno = errno;
-
-	if (MyProc)
-		SetLatch(&MyProc->procLatch);
-
-	if (!proc_exit_inprogress)
-	{
-		InterruptPending = true;
-		ProcDiePending = true;
-	}
-
-	errno = save_errno;
-}
-
 
 /*
  * PgCronLauncherMain is the main entry-point for the background worker
@@ -1991,7 +1967,8 @@ CronBackgroundWorker(Datum main_arg)
 	shm_mq *mq;
 	shm_mq_handle *responseq;
 
-	pqsignal(SIGTERM, pg_cron_background_worker_sigterm);
+	/* handle SIGTERM like regular backend */
+	pqsignal(SIGTERM, die);
 	BackgroundWorkerUnblockSignals();
 
 	/* Set up a memory context and resource owner. */

COMMIT_HASH:bedbc493a0e0442af01e96c4d04d82b7a613464d|AUTHOR_NAME:TsinghuaLucky912|AUTHOR_EMAIL:postgres@localhost.localdomain|DATE:2022-12-09 20:25:45 -0800|TITLE:Add a judgment function for cron.timezone: check_cron_timezone|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index a840467..526b655 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -184,6 +184,7 @@ static const struct config_enum_entry cron_message_level_options[] = {
 };
 
 static const char *cron_error_severity(int elevel);
+static bool check_cron_timezone(char **newval, void **extra, GucSource source);
 
 /*
  * _PG_init gets called when the extension is loaded.
@@ -309,7 +310,7 @@ _PG_init(void)
 		"GMT",
 		PGC_POSTMASTER,
 		GUC_SUPERUSER_ONLY,
-		NULL, NULL, NULL);
+		check_cron_timezone, NULL, NULL);
 
 	/* set up common data for all our workers */
 	worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
@@ -475,6 +476,133 @@ cron_error_severity(int elevel)
 	return elevel_char;
 }
 
+/*
+ * TIMEZONE
+ */
+
+/*
+ * check_cron_timezone: GUC check_hook for cron.timezone
+ */
+static bool
+check_cron_timezone(char **newval, void **extra, GucSource source)
+{
+	pg_tz	   *new_tz;
+	long		gmtoffset;
+	char	   *endptr;
+	double		hours;
+
+	if (pg_strncasecmp(*newval, "interval", 8) == 0)
+	{
+		/*
+		 * Support INTERVAL 'foo'.  This is for SQL spec compliance, not
+		 * because it has any actual real-world usefulness.
+		 */
+		const char *valueptr = *newval;
+		char	   *val;
+		Interval   *interval;
+
+		valueptr += 8;
+		while (isspace((unsigned char) *valueptr))
+			valueptr++;
+		if (*valueptr++ != '\'')
+			return false;
+		val = pstrdup(valueptr);
+		/* Check and remove trailing quote */
+		endptr = strchr(val, '\'');
+		if (!endptr || endptr[1] != '\0')
+		{
+			pfree(val);
+			return false;
+		}
+		*endptr = '\0';
+
+		/*
+		 * Try to parse it.  XXX an invalid interval format will result in
+		 * ereport(ERROR), which is not desirable for GUC.  We did what we
+		 * could to guard against this in flatten_set_variable_args, but a
+		 * string coming in from postgresql.conf might contain anything.
+		 */
+		interval = DatumGetIntervalP(DirectFunctionCall3(interval_in,
+														 CStringGetDatum(val),
+														 ObjectIdGetDatum(InvalidOid),
+														 Int32GetDatum(-1)));
+
+		pfree(val);
+		if (interval->month != 0)
+		{
+			GUC_check_errdetail("Cannot specify months in time zone interval.");
+			pfree(interval);
+			return false;
+		}
+		if (interval->day != 0)
+		{
+			GUC_check_errdetail("Cannot specify days in time zone interval.");
+			pfree(interval);
+			return false;
+		}
+
+		/* Here we change from SQL to Unix sign convention */
+		gmtoffset = -(interval->time / USECS_PER_SEC);
+		new_tz = pg_tzset_offset(gmtoffset);
+
+		pfree(interval);
+	}
+	else
+	{
+		/*
+		 * Try it as a numeric number of hours (possibly fractional).
+		 */
+		hours = strtod(*newval, &endptr);
+		if (endptr != *newval && *endptr == '\0')
+		{
+			/* Here we change from SQL to Unix sign convention */
+			gmtoffset = -hours * SECS_PER_HOUR;
+			new_tz = pg_tzset_offset(gmtoffset);
+		}
+		else
+		{
+			/*
+			 * Otherwise assume it is a timezone name, and try to load it.
+			 */
+			new_tz = pg_tzset(*newval);
+
+			if (!new_tz)
+			{
+				/* We need a valid time zone value here, otherwise it will affect the execution of the subsequent schedule. */
+				ereport(ERROR,
+						 errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+						 errmsg("invalid value for parameter \"cron.timezone\": \"%s\"",
+								 *newval));
+			}
+
+			if (!pg_tz_acceptable(new_tz))
+			{
+				GUC_check_errmsg("time zone \"%s\" appears to use leap seconds",
+								 *newval);
+				GUC_check_errdetail("PostgreSQL does not support leap seconds.");
+				return false;
+			}
+		}
+	}
+
+	/* Test for failure in pg_tzset_offset, which we assume is out-of-range */
+	if (!new_tz)
+	{
+		GUC_check_errdetail("UTC timezone offset is out of range.");
+		return false;
+	}
+
+	/*
+	 * Pass back data for assign_timezone to use
+	 */
+	*extra = malloc(sizeof(pg_tz *));
+	if (!*extra)
+		return false;
+	*((pg_tz **) *extra) = new_tz;
+
+	return true;
+}
+
 /*
  * bgw_generate_returned_message -
  *      generates the message to be inserted into the job_run_details table

COMMIT_HASH:df77beb2c4885551478bd7583b002086041466ec|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-12-09 16:23:11 +0100|TITLE:Merge pull request #219 from TsinghuaLucky912/time_zone|MESSAGE:
COMMIT_HASH:35d1475099449415e63a28695d1cd98f3fd8228d|AUTHOR_NAME:TsinghuaLucky912|AUTHOR_EMAIL:2903807914@qq.com|DATE:2022-12-09 16:07:37 +0800|TITLE:Support GUC parameter: cron.timezone|MESSAGE:
diff --git a/README.md b/README.md
index d1f76da..a335f07 100644
--- a/README.md
+++ b/README.md
@@ -61,7 +61,7 @@ The schedule uses the standard cron syntax, in which * means "run every time per
 
 An easy way to create a cron schedule is: [crontab.guru](http://crontab.guru/).
 
-The code in pg_cron that handles parsing and scheduling comes directly from the cron source code by Paul Vixie, hence the same options are supported. Be aware that pg_cron always uses GMT!
+The code in pg_cron that handles parsing and scheduling comes directly from the cron source code by Paul Vixie, hence the same options are supported.
 
 ## Installing pg_cron
 
@@ -108,6 +108,14 @@ By default, the pg_cron background worker expects its metadata tables to be crea
 cron.database_name = 'postgres'
 ```
 
+Previously we could only use GMT time, but now you can adapt your time by setting cron.timezone. You can configure this by setting the `cron.timezone` configuration parameter in postgresql.conf.
+```
+# add to postgresql.conf
+
+# optionally, specify the timezone in which the pg_cron background worker should run (defaults to GMT). E.g:
+cron.timezone = 'PRC'
+```
+
 After restarting PostgreSQL, you can create the pg_cron functions and metadata tables using `CREATE EXTENSION pg_cron`.
 
 _Note: `pg_cron` may only be installed to one database in a cluster. If you need to run jobs in multiple databases, use `cron.schedule_in_database()`._
diff --git a/src/pg_cron.c b/src/pg_cron.c
index b0d8ed5..a840467 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -60,6 +60,7 @@
 #include "commands/extension.h"
 #include "commands/sequence.h"
 #include "commands/trigger.h"
+#include "commands/variable.h"
 #include "lib/stringinfo.h"
 #include "libpq-fe.h"
 #include "libpq/pqmq.h"
@@ -163,6 +164,8 @@ static int MaxRunningTasks = 0;
 static int CronLogMinMessages = WARNING;
 static bool UseBackgroundWorkers = false;
 
+char  *cron_timezone = NULL;
+
 static const struct config_enum_entry cron_message_level_options[] = {
 	{"debug5", DEBUG5, false},
 	{"debug4", DEBUG4, false},
@@ -298,6 +301,16 @@ _PG_init(void)
 		GUC_SUPERUSER_ONLY,
 		NULL, NULL, NULL);
 
+	DefineCustomStringVariable(
+		"cron.timezone",
+		gettext_noop("Specify timezone used for cron schedule."),
+		NULL,
+		&cron_timezone,
+		"GMT",
+		PGC_POSTMASTER,
+		GUC_SUPERUSER_ONLY,
+		NULL, NULL, NULL);
+
 	/* set up common data for all our workers */
 	worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
 	worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
@@ -934,7 +947,7 @@ ShouldRunTask(entry *schedule, TimestampTz currentTime, bool doWild,
 			  bool doNonWild)
 {
 	time_t currentTime_t = timestamptz_to_time_t(currentTime);
-	struct tm *tm = gmtime(&currentTime_t);
+	struct pg_tm* tm = pg_localtime(&currentTime_t, pg_tzset(cron_timezone));
 
 	int minute = tm->tm_min -FIRST_MINUTE;
 	int hour = tm->tm_hour -FIRST_HOUR;

COMMIT_HASH:cede44603484a4397636dd0ae873c1b4d13bc983|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-12-06 10:07:29 +0100|TITLE:Merge pull request #217 from bchrobot/docs-document-schedule-in-database|MESSAGE:docs: add cron.schedule_in_database to examples
COMMIT_HASH:0cf1e8b773becb9dba10cc59505481ec24599fdc|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-12-06 10:06:54 +0100|TITLE:Merge pull request #218 from bchrobot/docs-standardize-example|MESSAGE:docs: standardize example output
COMMIT_HASH:d5bbffa5d6ff918c46a2e0f7c3eca92c3ab6fce9|AUTHOR_NAME:Benjamin Chrobot|AUTHOR_EMAIL:benjamin.chrobot@alum.mit.edu|DATE:2022-12-03 09:40:14 -0500|TITLE:docs: standardize example output|MESSAGE:
diff --git a/README.md b/README.md
index f9bf9e3..c84a402 100644
--- a/README.md
+++ b/README.md
@@ -30,7 +30,6 @@ SELECT cron.unschedule('nightly-vacuum' );
  unschedule 
 ------------
  t
-(1 row)
 
 SELECT cron.unschedule(42);
  unschedule

COMMIT_HASH:90f7e78fa3faa6cd9b1cb8fab2d9f97708b8cf8e|AUTHOR_NAME:Benjamin Chrobot|AUTHOR_EMAIL:benjamin.chrobot@alum.mit.edu|DATE:2022-12-03 09:36:50 -0500|TITLE:docs: add cron.schedule_in_database to examples|MESSAGE:
diff --git a/README.md b/README.md
index f9bf9e3..c7b3278 100644
--- a/README.md
+++ b/README.md
@@ -36,6 +36,12 @@ SELECT cron.unschedule(42);
  unschedule
 ------------
           t
+
+-- Vacuum every Sunday at 4:00am (GMT) in a database other than the one pg_cron is installed in
+SELECT cron.schedule_in_database('weekly-vacuum', '0 4 * * *', 'VACUUM', 'some_other_database');
+ schedule
+----------
+       44
 ```
 
 pg_cron can run multiple jobs in parallel, but it runs at most one instance of a job at a time. If a second run is supposed to start before the first one finishes, then the second run is queued and started as soon as the first run completes.
@@ -99,12 +105,14 @@ By default, the pg_cron background worker expects its metadata tables to be crea
 ```
 # add to postgresql.conf
 
-# optionally, specify the database in which the pg_cron background worker should run (defaults to postgres) 
+# optionally, specify the database in which the pg_cron background worker should run (defaults to postgres)
 cron.database_name = 'postgres'
 ```
 
 After restarting PostgreSQL, you can create the pg_cron functions and metadata tables using `CREATE EXTENSION pg_cron`.
 
+_Note: `pg_cron` may only be installed to one database in a cluster. If you need to run jobs in multiple databases, use `cron.schedule_in_database()`._
+
 ```sql
 -- run as superuser:
 CREATE EXTENSION pg_cron;

COMMIT_HASH:465c2b1e11bd141b9703b9decd1a636d23892a2b|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-11-02 11:05:56 +0100|TITLE:Merge pull request #213 from hslightdb/tianxf42813|MESSAGE:
COMMIT_HASH:3ac55192fa451aafc0a67fe85ae52af4e0abcd0f|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-11-02 10:17:49 +0100|TITLE:Merge pull request #215 from credativ/name-type|MESSAGE:
COMMIT_HASH:d9f61dc1a74f77a68a325320ab06d85975e0e781|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-11-02 10:15:44 +0100|TITLE:Merge pull request #205 from zhjwpku/fix_typo_in_next_run_id|MESSAGE:
COMMIT_HASH:13c77dcc58e6ded78db648d15c0e7667fc40aa80|AUTHOR_NAME:Christoph Berg|AUTHOR_EMAIL:myon@debian.org|DATE:2022-11-01 16:12:10 +0100|TITLE:tests: Fix compatibility with PG<=12|MESSAGE:This fixes the testsuite to run with PG 12 and earlier.

ERROR:  return type mismatch in function declared to return text
DETAIL:  Actual return type is name.

Close #195.

diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index 78ac285..52ba985 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -196,9 +196,9 @@ DROP TYPE IF EXISTS current_setting cascade;
 NOTICE:  type "current_setting" does not exist, skipping
 CREATE TYPE current_setting AS ENUM ('cron.database_name');
 CREATE OR REPLACE FUNCTION public.func1(text, current_setting) RETURNS text
-    LANGUAGE sql volatile AS 'INSERT INTO test(data) VALUES (current_user); SELECT current_database();';
+    LANGUAGE sql volatile AS 'INSERT INTO test(data) VALUES (current_user); SELECT current_database()::text;';
 CREATE OR REPLACE FUNCTION public.func1(current_setting) RETURNS text
-    LANGUAGE sql volatile AS 'INSERT INTO test(data) VALUES (current_user); SELECT current_database();';
+    LANGUAGE sql volatile AS 'INSERT INTO test(data) VALUES (current_user); SELECT current_database()::text;';
 CREATE CAST (current_setting AS text) WITH FUNCTION public.func1(current_setting) AS IMPLICIT;
 CREATE EXTENSION pg_cron VERSION '1.4';
 select * from public.test;
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index 5aedb1e..417ad53 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -110,10 +110,10 @@ DROP TYPE IF EXISTS current_setting cascade;
 CREATE TYPE current_setting AS ENUM ('cron.database_name');
 
 CREATE OR REPLACE FUNCTION public.func1(text, current_setting) RETURNS text
-    LANGUAGE sql volatile AS 'INSERT INTO test(data) VALUES (current_user); SELECT current_database();';
+    LANGUAGE sql volatile AS 'INSERT INTO test(data) VALUES (current_user); SELECT current_database()::text;';
 
 CREATE OR REPLACE FUNCTION public.func1(current_setting) RETURNS text
-    LANGUAGE sql volatile AS 'INSERT INTO test(data) VALUES (current_user); SELECT current_database();';
+    LANGUAGE sql volatile AS 'INSERT INTO test(data) VALUES (current_user); SELECT current_database()::text;';
 
 CREATE CAST (current_setting AS text) WITH FUNCTION public.func1(current_setting) AS IMPLICIT;
 

COMMIT_HASH:a2bdb8f7fba065a6b86d16dc6d70de892427e250|AUTHOR_NAME:tianxf42813|AUTHOR_EMAIL:tianxf42813@hundsun.com|DATE:2022-10-14 22:20:39 +0800|TITLE:Fix that when the return value of char type function under arm environment is EOF, it is defaulted to 255, because the char type under arm is defaulted to unsigned char|MESSAGE:
diff --git a/src/entry.c b/src/entry.c
index 717a2c9..6febb8c 100644
--- a/src/entry.c
+++ b/src/entry.c
@@ -35,7 +35,7 @@ typedef	enum ecode {
 	e_cmd, e_timespec, e_username, e_cmd_len
 } ecode_e;
 
-static char	get_list(bitstr_t *, int, int, char *[], int, FILE *),
+static int	get_list(bitstr_t *, int, int, char *[], int, FILE *),
 		get_range(bitstr_t *, int, int, char *[], int, FILE *),
 		get_number(int *, int, char *[], int, FILE *);
 static int	set_element(bitstr_t *, int, int, int);
@@ -241,7 +241,7 @@ parse_cron_entry(char *schedule)
 }
 
 
-static char
+static int
 get_list(bits, low, high, names, ch, file)
 	bitstr_t	*bits;		/* one bit per flag, default=FALSE */
 	int		low, high;	/* bounds, impl. offset for bitstr */
@@ -288,7 +288,7 @@ get_list(bits, low, high, names, ch, file)
 }
 
 
-static char
+static int
 get_range(bits, low, high, names, ch, file)
 	bitstr_t	*bits;		/* one bit per flag, default=FALSE */
 	int		low, high;	/* bounds, impl. offset for bitstr */
@@ -391,7 +391,7 @@ get_range(bits, low, high, names, ch, file)
 }
 
 
-static char
+static int
 get_number(numptr, low, names, ch, file)
 	int	*numptr;	/* where does the result go? */
 	int	low;		/* offset applied to result if symbolic enum used */

COMMIT_HASH:bc2b9da9314d18bb242273bf7fc8e840d02fb3ac|AUTHOR_NAME:Junwang Zhao|AUTHOR_EMAIL:zhjwpku@gmail.com|DATE:2022-09-19 14:55:14 +0800|TITLE:[typo] %s/jobId/runId/g in NextRunId|MESSAGE:in NextRunId, we are generating runId but not jobId, fix the typo.

Signed-off-by: Junwang Zhao <zhjwpku@gmail.com>

diff --git a/src/job_metadata.c b/src/job_metadata.c
index 23c9e83..9d137a5 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -522,8 +522,8 @@ NextRunId(void)
 	Datum sequenceIdDatum = InvalidOid;
 	Oid savedUserId = InvalidOid;
 	int savedSecurityContext = 0;
-	Datum jobIdDatum = 0;
-	int64 jobId = 0;
+	Datum runIdDatum = 0;
+	int64 runId = 0;
 	bool failOK = true;
 	MemoryContext originalContext = CurrentMemoryContext;
 
@@ -551,17 +551,17 @@ NextRunId(void)
 	SetUserIdAndSecContext(CronExtensionOwner(), SECURITY_LOCAL_USERID_CHANGE);
 
 	/* generate new and unique colocation id from sequence */
-	jobIdDatum = DirectFunctionCall1(nextval_oid, sequenceIdDatum);
+	runIdDatum = DirectFunctionCall1(nextval_oid, sequenceIdDatum);
 
 	SetUserIdAndSecContext(savedUserId, savedSecurityContext);
 
-	jobId = DatumGetInt64(jobIdDatum);
+	runId = DatumGetInt64(runIdDatum);
 
 	PopActiveSnapshot();
 	CommitTransactionCommand();
 	MemoryContextSwitchTo(originalContext);
 
-	return jobId;
+	return runId;
 }
 
 /*

COMMIT_HASH:04928108f4e08738c47fb0164a2ef38b965a02e5|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-09-09 11:09:34 +0200|TITLE:Merge pull request #203 from zhjwpku/pg_dll_export|MESSAGE:
COMMIT_HASH:36e728e32c8b6a03b2d9f2e23d0481e986b3993b|AUTHOR_NAME:Junwang Zhao|AUTHOR_EMAIL:zhjwpku@gmail.com|DATE:2022-09-09 16:49:44 +0800|TITLE:add PGDLLEXPORT to adapt pg 16|MESSAGE:postgres master branch(a.k.a release 16) add a feature *Default to
hidden visibility for extension libraries where possible*[1], this
will cause problem when loading the pg_cron shared library.

```
ERROR:  could not find function "PgCronLauncherMain"
```

add PGDLLEXPORT can solve the problem.

[1] https://github.com/postgres/postgres/commit/089480c077056fc20fa8d8f5a3032a9dcf5ed812

Signed-off-by: Junwang Zhao <zhjwpku@gmail.com>

diff --git a/src/pg_cron.c b/src/pg_cron.c
index 5545894..b0d8ed5 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -118,8 +118,8 @@ void _PG_fini(void);
 static void pg_cron_sigterm(SIGNAL_ARGS);
 static void pg_cron_sighup(SIGNAL_ARGS);
 static void pg_cron_background_worker_sigterm(SIGNAL_ARGS);
-void PgCronLauncherMain(Datum arg);
-void CronBackgroundWorker(Datum arg);
+PGDLLEXPORT void PgCronLauncherMain(Datum arg);
+PGDLLEXPORT void CronBackgroundWorker(Datum arg);
 
 static void StartAllPendingRuns(List *taskList, TimestampTz currentTime);
 static void StartPendingRuns(CronTask *task, ClockProgress clockProgress,

COMMIT_HASH:6bf8443fb39226fec787eeff656ee5d147573116|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-07-15 14:02:59 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 938002c..f9bf9e3 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 [![Citus Banner](/github-banner.png)](https://www.citusdata.com/)
 
-[![Slack Status](http://slack.citusdata.com/badge.svg)](https://slack.citusdata.com)
+[![Slack Status](https://citus-slack.herokuapp.com/badge.svg)](https://citus-public.slack.com/)
 
 ## What is pg_cron?
 

COMMIT_HASH:82573a41eb82774e365ee6d149070f6576530d95|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2022-07-15 13:52:48 +0200|TITLE:Use -Wno-uniitialized in gcc instead of -Wno-maybe-unitialized|MESSAGE:
diff --git a/Makefile b/Makefile
index a87d1ba..053314c 100644
--- a/Makefile
+++ b/Makefile
@@ -12,7 +12,7 @@ REGRESS = pg_cron-test
 MODULE_big = $(EXTENSION)
 OBJS = $(patsubst %.c,%.o,$(wildcard src/*.c))
 ifeq ($(CC),gcc)
-    PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-maybe-uninitialized -Wno-implicit-fallthrough -Iinclude -I$(libpq_srcdir)
+    PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-uninitialized -Wno-implicit-fallthrough -Iinclude -I$(libpq_srcdir)
 else
     PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-implicit-fallthrough -Iinclude -I$(libpq_srcdir)
 endif

COMMIT_HASH:683e0da8d8f37eea5b2b4576e8992989b9a2fceb|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2022-07-15 00:14:59 +0200|TITLE:Add CHANGELOG for 1.4.2|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index a09e849..8df26db 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,10 @@
+### pg_cron v1.4.2 (July 15, 2022) ###
+
+* Fixes a bug that could lead to privilege escalation if users can trigger CREATE EXTENSION
+* Add compatibility for PostgreSQL 15 beta
+* Fixes a bug that could cause unschedule to crash
+* Ensures that cron.max_running_jobs is not higher than possible connection count
+
 ### pg_cron v1.4.1 (September 25, 2021) ###
 
 * Fixes PostgreSQL 11- support

COMMIT_HASH:7671aa0e5814237db0b50e1487ef80a391ec79cf|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-07-15 00:06:53 +0200|TITLE:Merge pull request #192 from italomg/fix-privilege-escalation|MESSAGE:
COMMIT_HASH:53a2e006fb5605daba953f029f31e673b28ccf7e|AUTHOR_NAME:Italo Garcia|AUTHOR_EMAIL:italo.garcia@aiven.io|DATE:2022-07-07 13:46:24 +0200|TITLE:Adding test for privilege elevation|MESSAGE:
diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index edf97e1..78ac285 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -189,6 +189,23 @@ SELECT username FROM cron.job where jobid=7;
  pgcron_cront
 (1 row)
 
+-- Override function
+DROP EXTENSION IF EXISTS pg_cron cascade;
+CREATE TABLE test (data text);
+DROP TYPE IF EXISTS current_setting cascade;
+NOTICE:  type "current_setting" does not exist, skipping
+CREATE TYPE current_setting AS ENUM ('cron.database_name');
+CREATE OR REPLACE FUNCTION public.func1(text, current_setting) RETURNS text
+    LANGUAGE sql volatile AS 'INSERT INTO test(data) VALUES (current_user); SELECT current_database();';
+CREATE OR REPLACE FUNCTION public.func1(current_setting) RETURNS text
+    LANGUAGE sql volatile AS 'INSERT INTO test(data) VALUES (current_user); SELECT current_database();';
+CREATE CAST (current_setting AS text) WITH FUNCTION public.func1(current_setting) AS IMPLICIT;
+CREATE EXTENSION pg_cron VERSION '1.4';
+select * from public.test;
+ data 
+------
+(0 rows)
+
 -- cleaning
 DROP EXTENSION pg_cron;
 drop user pgcron_cront;
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index f9c83d5..5aedb1e 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -103,6 +103,23 @@ SELECT username FROM cron.job where jobid=2;
 SELECT cron.schedule_in_database(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',database:=current_database(), username:='pgcron_cront');
 SELECT username FROM cron.job where jobid=7;
 
+-- Override function
+DROP EXTENSION IF EXISTS pg_cron cascade;
+CREATE TABLE test (data text);
+DROP TYPE IF EXISTS current_setting cascade;
+CREATE TYPE current_setting AS ENUM ('cron.database_name');
+
+CREATE OR REPLACE FUNCTION public.func1(text, current_setting) RETURNS text
+    LANGUAGE sql volatile AS 'INSERT INTO test(data) VALUES (current_user); SELECT current_database();';
+
+CREATE OR REPLACE FUNCTION public.func1(current_setting) RETURNS text
+    LANGUAGE sql volatile AS 'INSERT INTO test(data) VALUES (current_user); SELECT current_database();';
+
+CREATE CAST (current_setting AS text) WITH FUNCTION public.func1(current_setting) AS IMPLICIT;
+
+CREATE EXTENSION pg_cron VERSION '1.4';
+select * from public.test;
+
 -- cleaning
 DROP EXTENSION pg_cron;
 drop user pgcron_cront;

COMMIT_HASH:44cfd19312afa138cd86137d1b1f17adbe769c27|AUTHOR_NAME:Italo Garcia|AUTHOR_EMAIL:italo.garcia@aiven.io|DATE:2022-07-06 22:27:22 +0200|TITLE:Qualify function calls and operator usages|MESSAGE:
diff --git a/pg_cron.sql b/pg_cron.sql
index 74193cf..2de23f4 100644
--- a/pg_cron.sql
+++ b/pg_cron.sql
@@ -1,13 +1,13 @@
 DO $$
 BEGIN
-   IF current_database() <> current_setting('cron.database_name') AND current_database() <> 'contrib_regression' THEN
+   IF pg_catalog.current_database() OPERATOR(pg_catalog.<>) pg_catalog.current_setting('cron.database_name') AND pg_catalog.current_database() OPERATOR(pg_catalog.<>) 'contrib_regression' THEN
       RAISE EXCEPTION 'can only create extension in database %',
-                      current_setting('cron.database_name')
-      USING DETAIL = 'Jobs must be scheduled from the database configured in '||
-                     'cron.database_name, since the pg_cron background worker '||
+                      pg_catalog.current_setting('cron.database_name')
+      USING DETAIL = 'Jobs must be scheduled from the database configured in 'OPERATOR(pg_catalog.||)
+                     'cron.database_name, since the pg_cron background worker 'OPERATOR(pg_catalog.||)
                      'reads job descriptions from this database.',
-            HINT = format('Add cron.database_name = ''%s'' in postgresql.conf '||
-                          'to use the current database.', current_database());
+            HINT = pg_catalog.format('Add cron.database_name = ''%s'' in postgresql.conf 'OPERATOR(pg_catalog.||)
+                          'to use the current database.', pg_catalog.current_database());
    END IF;
 END;
 $$;
@@ -16,17 +16,17 @@ CREATE SCHEMA cron;
 CREATE SEQUENCE cron.jobid_seq;
 
 CREATE TABLE cron.job (
-	jobid bigint primary key default nextval('cron.jobid_seq'),
+	jobid bigint primary key default pg_catalog.nextval('cron.jobid_seq'),
 	schedule text not null,
 	command text not null,
 	nodename text not null default 'localhost',
-	nodeport int not null default inet_server_port(),
-	database text not null default current_database(),
+	nodeport int not null default pg_catalog.inet_server_port(),
+	database text not null default pg_catalog.current_database(),
 	username text not null default current_user
 );
 GRANT SELECT ON cron.job TO public;
 ALTER TABLE cron.job ENABLE ROW LEVEL SECURITY;
-CREATE POLICY cron_job_policy ON cron.job USING (username = current_user);
+CREATE POLICY cron_job_policy ON cron.job USING (username OPERATOR(pg_catalog.=) current_user);
 
 CREATE FUNCTION cron.schedule(schedule text, command text)
     RETURNS bigint

COMMIT_HASH:59e2ff40d0766c8ba140e6e31685238b699459d8|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-06-16 10:05:33 +0200|TITLE:Merge pull request #189 from hughcapet/pg15-compat|MESSAGE:
COMMIT_HASH:80587818730858eb8aecc27b7ec98c5e02b26487|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2022-06-16 10:03:59 +0200|TITLE:Remove enable_suerpuser_jobs test for now|MESSAGE:
diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index a845929..edf97e1 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -12,7 +12,6 @@ SELECT extversion FROM pg_extension WHERE extname='pg_cron';
  1.4
 (1 row)
 
-SET cron.enable_superuser_jobs TO on;
 -- Vacuum every day at 10:00am (GMT)
 SELECT cron.schedule('0 10 * * *', 'VACUUM');
  schedule 
@@ -190,27 +189,6 @@ SELECT username FROM cron.job where jobid=7;
  pgcron_cront
 (1 row)
 
--- Try to schedule a job as superuser when it is not allowed
-SET cron.enable_superuser_jobs TO off;
-SELECT cron.schedule(job_name:='disallowed-superuser', schedule:='* * * * *', command:='drop database pg_crondbno');
-ERROR:  cannot schedule jobs as superuser
-DETAIL:  Scheduling jobs as superuser is disallowed when cron.enable_superuser_jobs is set to off.
-SELECT cron.alter_job(7, username := current_user);
-ERROR:  cannot schedule jobs as superuser
-DETAIL:  Scheduling jobs as superuser is disallowed when cron.enable_superuser_jobs is set to off.
--- Scheduling as other users is allowed as superuser
-SELECT cron.schedule_in_database(job_name:='more vacuum', schedule:='0 12 * * *', command:='VACUUM', database:=current_database(), username:='pgcron_cront');
- schedule_in_database 
-----------------------
-                    8
-(1 row)
-
-SELECT cron.alter_job(7, username := 'pgcron_cront');
- alter_job 
------------
- 
-(1 row)
-
 -- cleaning
 DROP EXTENSION pg_cron;
 drop user pgcron_cront;
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index 3bc9cba..f9c83d5 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -3,8 +3,6 @@ SELECT extversion FROM pg_extension WHERE extname='pg_cron';
 ALTER EXTENSION pg_cron UPDATE TO '1.4';
 SELECT extversion FROM pg_extension WHERE extname='pg_cron';
 
-SET cron.enable_superuser_jobs TO on;
-
 -- Vacuum every day at 10:00am (GMT)
 SELECT cron.schedule('0 10 * * *', 'VACUUM');
 
@@ -105,16 +103,6 @@ SELECT username FROM cron.job where jobid=2;
 SELECT cron.schedule_in_database(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',database:=current_database(), username:='pgcron_cront');
 SELECT username FROM cron.job where jobid=7;
 
--- Try to schedule a job as superuser when it is not allowed
-SET cron.enable_superuser_jobs TO off;
-
-SELECT cron.schedule(job_name:='disallowed-superuser', schedule:='* * * * *', command:='drop database pg_crondbno');
-SELECT cron.alter_job(7, username := current_user);
-
--- Scheduling as other users is allowed as superuser
-SELECT cron.schedule_in_database(job_name:='more vacuum', schedule:='0 12 * * *', command:='VACUUM', database:=current_database(), username:='pgcron_cront');
-SELECT cron.alter_job(7, username := 'pgcron_cront');
-
 -- cleaning
 DROP EXTENSION pg_cron;
 drop user pgcron_cront;

COMMIT_HASH:53b53b3f8658aeb40c0515271ca9fd879e80e87e|AUTHOR_NAME:Polina Bungina|AUTHOR_EMAIL:polina.bungina@zalando.de|DATE:2022-06-13 17:53:37 +0200|TITLE:Compatibility with PostgreSQL 15|MESSAGE:- Rename pg_analyze_and_rewrite to pg_analyze_and_rewrite_fixedparams
- Call CHECK_FOR_INTERRUPTS after resetting Latch in order to properly
  handle SIGUSR1. It wasn't a problem until recent fixes of DROP
  {DATABASE,TABLESPACE} on Windows: postgres/postgres@4eb2176

diff --git a/src/pg_cron.c b/src/pg_cron.c
index 1a2ac26..5545894 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -998,6 +998,8 @@ WaitForLatch(int timeoutMs)
 
 	ResetLatch(MyLatch);
 
+	CHECK_FOR_INTERRUPTS();
+
 	if (rc & WL_POSTMASTER_DEATH)
 	{
 		/* postmaster died and we should bail out immediately */
@@ -2153,8 +2155,10 @@ ExecuteSqlString(const char *sql)
 		 * perform internal transaction control.
 		 */
 		oldcontext = MemoryContextSwitchTo(parsecontext);
-		#if PG_VERSION_NUM >= 100000
-			querytree_list = pg_analyze_and_rewrite(parsetree, sql, NULL, 0,NULL);
+		#if PG_VERSION_NUM >= 150000
+			querytree_list = pg_analyze_and_rewrite_fixedparams(parsetree, sql, NULL, 0, NULL);
+		#elif PG_VERSION_NUM >= 100000
+			querytree_list = pg_analyze_and_rewrite(parsetree, sql, NULL, 0, NULL);
 		#else
 			querytree_list = pg_analyze_and_rewrite(parsetree, sql, NULL, 0);
 		#endif

COMMIT_HASH:992226c6a4bd355cae823de922132080e9cff3c3|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-05-02 10:50:26 +0200|TITLE:Only allow cron.enable_superuser_jobs to be set in postgresql.conf|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 1a50e51..1a2ac26 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -238,7 +238,7 @@ _PG_init(void)
 		NULL,
 		&EnableSuperuserJobs,
 		true,
-		PGC_USERSET,
+		PGC_POSTMASTER,
 		GUC_SUPERUSER_ONLY,
 		NULL, NULL, NULL);
 

COMMIT_HASH:995b6fab3ec136cb5d9e5fbf5d4d98c54c0afd82|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-04-06 10:09:07 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index d2f17e6..938002c 100644
--- a/README.md
+++ b/README.md
@@ -154,7 +154,6 @@ The following table keeps track of which of the major managed Postgres services
 | [Alibaba Cloud](https://www.alibabacloud.com/help/doc-detail/150355.htm) | :heavy_check_mark: |
 | [Amazon RDS](https://aws.amazon.com/rds/postgresql/)     | :heavy_check_mark:      |          |
 | [Azure](https://azure.microsoft.com/en-us/services/postgresql/) | :heavy_check_mark:  |
-| [Citus Cloud](https://www.citusdata.com/product/cloud)  | :heavy_check_mark: |
 | [Crunchy Bridge](https://www.crunchydata.com/products/crunchy-bridge/?ref=producthunt) | :heavy_check_mark: |
 | [DigitalOcean](https://www.digitalocean.com/products/managed-databases/) | :heavy_check_mark: |
 | [Google Cloud](https://cloud.google.com/sql/postgresql/) | :heavy_check_mark: |

COMMIT_HASH:aee05478232fbbecc36383b3d3b5408f291f7eee|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-03-08 11:40:05 +0100|TITLE:Merge pull request #180 from mizhka/main|MESSAGE:
COMMIT_HASH:41c8f1fe4da3e97ec8ac4fe5489e919966519ef4|AUTHOR_NAME:Michael Zhilin|AUTHOR_EMAIL:mizhka@FreeBSD.org|DATE:2022-02-07 20:19:03 +0300|TITLE:Correct state of inactive task after state DONE|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 7d6fbb3..1a50e51 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -1755,6 +1755,8 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			 */
 			if (job != NULL && job->active)
 				InitializeCronTask(task, jobId);
+			else
+				task->state = CRON_TASK_WAITING;
 
 			/*
 			 * We keep the number of runs that should have started while

COMMIT_HASH:01471217387cb1c68995d30bcb177f1466c87497|AUTHOR_NAME:Michael Zhilin|AUTHOR_EMAIL:mizhka@FreeBSD.org|DATE:2022-02-07 12:37:02 +0300|TITLE:fix crash after unschedule during running task|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 965b8b7..7d6fbb3 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -1745,8 +1745,16 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 		default:
 		{
 			int currentPendingRunCount = task->pendingRunCount;
+			CronJob *job = GetCronJob(jobId);
 
-			InitializeCronTask(task, jobId);
+			/*
+			 * It may happen that job was unscheduled during task execution.
+			 * In this case we keep task as-is. Otherwise, we should
+			 * re-initialize task, i.e. reset fields to initial values including
+			 * status.
+			 */
+			if (job != NULL && job->active)
+				InitializeCronTask(task, jobId);
 
 			/*
 			 * We keep the number of runs that should have started while

COMMIT_HASH:17a069769bebc0d25baa94b51a6df600c385e307|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-01-11 17:28:05 +0100|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index d0040fd..d2f17e6 100644
--- a/README.md
+++ b/README.md
@@ -88,11 +88,18 @@ make && sudo PATH=$PATH make install
 
 To start the pg_cron background worker when PostgreSQL starts, you need to add pg_cron to `shared_preload_libraries` in postgresql.conf. Note that pg_cron does not run any jobs as a long a server is in [hot standby](https://www.postgresql.org/docs/current/static/hot-standby.html) mode, but it automatically starts when the server is promoted.
 
-By default, the pg_cron background worker expects its metadata tables to be created in the "postgres" database. However, you can configure this by setting the `cron.database_name` configuration parameter in postgresql.conf.
-
 ```
-# add to postgresql.conf:
+# add to postgresql.conf
+
+# required to load pg_cron background worker on start-up
 shared_preload_libraries = 'pg_cron'
+```
+
+By default, the pg_cron background worker expects its metadata tables to be created in the "postgres" database. However, you can configure this by setting the `cron.database_name` configuration parameter in postgresql.conf.
+```
+# add to postgresql.conf
+
+# optionally, specify the database in which the pg_cron background worker should run (defaults to postgres) 
 cron.database_name = 'postgres'
 ```
 

COMMIT_HASH:85eaf77e9774da3379d97551d21ced040d807edc|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2022-01-04 13:49:34 +0100|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index d644736..d0040fd 100644
--- a/README.md
+++ b/README.md
@@ -106,7 +106,23 @@ CREATE EXTENSION pg_cron;
 GRANT USAGE ON SCHEMA cron TO marco;
 ```
 
-**Important**: Internally, pg_cron uses libpq to open a new connection to the local database. It may be necessary to enable `trust` authentication for connections coming from localhost in [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html) for the user running the cron job. Alternatively, you can add the password to a [.pgpass file](https://www.postgresql.org/docs/current/static/libpq-pgpass.html), which libpq will use when opening a connection.
+**Important**: By default, pg_cron uses libpq to open a new connection to the local database, which needs to be allowed by [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html). 
+It may be necessary to enable `trust` authentication for connections coming from localhost in  for the user running the cron job, or you can add the password to a [.pgpass file](https://www.postgresql.org/docs/current/static/libpq-pgpass.html), which libpq will use when opening a connection. 
+
+Alternatively, pg_cron can be configured to use background workers. In that case, the number of concurrent jobs is limited by the `max_worker_processes` setting, so you may need to raise that.
+
+```
+# Schedule jobs via background workers instead of localhost connections
+cron.use_background_workers = on
+# Increase the number of available background workers from the default of 8
+max_worker_processes = 20
+```
+
+You can also use a unix domain socket directory as the hostname and enable `trust` authentication for local connections in [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html), which is normally safe:
+```
+# Connect via a unix domain socket
+cron.host = '/tmp'
+```
 
 For security, jobs are executed in the database in which the `cron.schedule` function is called with the same permissions as the current user. In addition, users are only able to see their own jobs in the `cron.job` table.
 

COMMIT_HASH:c558000017c1ae63c28fdf5be89e9817a93a7387|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2021-12-09 00:14:23 +0100|TITLE:Merge pull request #171 from hslightdb/main|MESSAGE:fixed a cron.max_running_jobs initialization bug
COMMIT_HASH:24e38a9fdef22ec3aedf36eb96d1e21dd90166ce|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2021-12-09 00:13:36 +0100|TITLE:Merge pull request #168 from robert-pang/patch-1|MESSAGE:Update Google Cloud SQL support for pg_cron
COMMIT_HASH:cb1ec9a6bfdeeb8f4539c8217b3768af34975498|AUTHOR_NAME:songhe36609|AUTHOR_EMAIL:songhe36609@hundsun.com|DATE:2021-12-06 17:28:19 +0800|TITLE:fixed a cron.max_running_jobs initialization bug|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index c0a2126..965b8b7 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -268,7 +268,7 @@ _PG_init(void)
 			gettext_noop("Maximum number of jobs that can run concurrently."),
 			NULL,
 			&MaxRunningTasks,
-			32,
+			(MaxConnections < 32) ? MaxConnections : 32,
 			0,
 			MaxConnections,
 			PGC_POSTMASTER,
@@ -280,7 +280,7 @@ _PG_init(void)
 			gettext_noop("Maximum number of jobs that can run concurrently."),
 			NULL,
 			&MaxRunningTasks,
-			5,
+			(max_worker_processes - 1 < 5) ? max_worker_processes - 1 : 5,
 			0,
 			max_worker_processes - 1,
 			PGC_POSTMASTER,

COMMIT_HASH:11f0390ba46015ec87f638f6f0c1609b28061a49|AUTHOR_NAME:Robert Pang|AUTHOR_EMAIL:59705596+robert-pang@users.noreply.github.com|DATE:2021-11-30 17:56:59 -0800|TITLE:Update Google Cloud SQL for PostgreSQL link|MESSAGE:
diff --git a/README.md b/README.md
index c0f3901..d644736 100644
--- a/README.md
+++ b/README.md
@@ -134,7 +134,7 @@ The following table keeps track of which of the major managed Postgres services
 | [Citus Cloud](https://www.citusdata.com/product/cloud)  | :heavy_check_mark: |
 | [Crunchy Bridge](https://www.crunchydata.com/products/crunchy-bridge/?ref=producthunt) | :heavy_check_mark: |
 | [DigitalOcean](https://www.digitalocean.com/products/managed-databases/) | :heavy_check_mark: |
-| [Google Cloud](https://cloud.google.com/sql/docs/postgres/) | :heavy_check_mark: |
+| [Google Cloud](https://cloud.google.com/sql/postgresql/) | :heavy_check_mark: |
 | [Heroku](https://elements.heroku.com/addons/heroku-postgresql) | :x: | |
 | [ScaleGrid](https://scalegrid.io/postgresql.html) | :heavy_check_mark:  |
 | [Scaleway](https://www.scaleway.com/en/database/) | :heavy_check_mark:  |

COMMIT_HASH:7612e3a7a82337b6a1567d7bfbcf0f4da37791ef|AUTHOR_NAME:Robert Pang|AUTHOR_EMAIL:59705596+robert-pang@users.noreply.github.com|DATE:2021-11-30 12:14:43 -0800|TITLE:Update Google Cloud SQL support for pg_cron|MESSAGE:The support for the pg_cron extension has been added to Google Cloud SQL ([release notes](https://cloud.google.com/sql/docs/postgres/release-notes#November_19_2021)).
diff --git a/README.md b/README.md
index 1601efd..c0f3901 100644
--- a/README.md
+++ b/README.md
@@ -134,7 +134,7 @@ The following table keeps track of which of the major managed Postgres services
 | [Citus Cloud](https://www.citusdata.com/product/cloud)  | :heavy_check_mark: |
 | [Crunchy Bridge](https://www.crunchydata.com/products/crunchy-bridge/?ref=producthunt) | :heavy_check_mark: |
 | [DigitalOcean](https://www.digitalocean.com/products/managed-databases/) | :heavy_check_mark: |
-| [Google Cloud](https://cloud.google.com/sql/docs/postgres/) | :x:      |
+| [Google Cloud](https://cloud.google.com/sql/docs/postgres/) | :heavy_check_mark: |
 | [Heroku](https://elements.heroku.com/addons/heroku-postgresql) | :x: | |
 | [ScaleGrid](https://scalegrid.io/postgresql.html) | :heavy_check_mark:  |
 | [Scaleway](https://www.scaleway.com/en/database/) | :heavy_check_mark:  |

COMMIT_HASH:f7d2dab8196b0a69feaa727c7e1c9158bf232a07|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2021-11-25 21:26:06 +0100|TITLE:Merge pull request #165 from citusdata/marcocitus/sequence-select|MESSAGE:
COMMIT_HASH:6da45a0e1698fef761568bd4514a2dc6d9009c9c|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2021-11-19 10:32:25 +0100|TITLE:Grant select to sequences to simplify pg_dump as non-superuser|MESSAGE:
diff --git a/pg_cron--1.4--1.4-1.sql b/pg_cron--1.4--1.4-1.sql
new file mode 100644
index 0000000..2d7ba18
--- /dev/null
+++ b/pg_cron--1.4--1.4-1.sql
@@ -0,0 +1,10 @@
+/* pg_cron--1.4--1.4-1.sql */
+
+/*
+ * pg_dump will read from these sequences. Grant everyone permission
+ * to read from the sequence. That way, a user with usage on the cron
+ * schema can also do pg_dump. This does not grant write/nextval
+ * permission.
+ */
+GRANT SELECT ON SEQUENCE cron.jobid_seq TO public;
+GRANT SELECT ON SEQUENCE cron.runid_seq TO public;
diff --git a/pg_cron.control b/pg_cron.control
index c245791..4b7f088 100644
--- a/pg_cron.control
+++ b/pg_cron.control
@@ -1,4 +1,4 @@
 comment = 'Job scheduler for PostgreSQL'
-default_version = '1.4'
+default_version = '1.4-1'
 module_pathname = '$libdir/pg_cron'
 relocatable = false

COMMIT_HASH:836002fc50cf8bfea844e7a524467a008bd73372|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2021-11-19 10:14:00 +0100|TITLE:Remove EXTVERSION from Makefile|MESSAGE:
diff --git a/Makefile b/Makefile
index cf8fef0..a87d1ba 100644
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,6 @@
 # src/test/modules/pg_cron/Makefile
 
 EXTENSION = pg_cron
-EXTVERSION = 1.3
 
 DATA_built = $(EXTENSION)--1.0.sql
 DATA = $(wildcard $(EXTENSION)--*--*.sql)

COMMIT_HASH:729028b7316a9ff039918759297ec62fcb2f9f3d|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2021-11-19 10:03:11 +0100|TITLE:Merge pull request #159 from credativ/32bit|MESSAGE:
COMMIT_HASH:e2d585d6e240980efa87eebb5a8b569857c996b0|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2021-11-19 10:02:54 +0100|TITLE:Merge pull request #161 from japinli/bugfix|MESSAGE:
COMMIT_HASH:52741ad45c1ce38dcacc497226adc5905f439d00|AUTHOR_NAME:Japin Li|AUTHOR_EMAIL:japinli@hotmail.com|DATE:2021-11-06 22:42:16 +0800|TITLE:Support PostgreSQL 15|MESSAGE:Since ProcessCompletedNotifies() is removed in 15, and there is no need
to call it for bgworker, so I think we can remove it.

Discussion: https://www.postgresql.org/message-id/flat/153243441449.1404.2274116228506175596%40wrigleys.postgresql.org
Commit: https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=2e4eae87d02fef51c42c2028b65d85b9e051f9eb

diff --git a/src/pg_cron.c b/src/pg_cron.c
index 839ce0d..c0a2126 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -2028,7 +2028,6 @@ CronBackgroundWorker(Datum main_arg)
 	/* Post-execution cleanup. */
 	disable_timeout(STATEMENT_TIMEOUT, false);
 	CommitTransactionCommand();
-	ProcessCompletedNotifies();
 	pgstat_report_activity(STATE_IDLE, command);
 	pgstat_report_stat(true);
 

COMMIT_HASH:597f730f2987fba720c6479642499c16a1770d48|AUTHOR_NAME:Christoph Berg|AUTHOR_EMAIL:christoph.berg@credativ.de|DATE:2021-11-03 14:10:49 +0100|TITLE:AlterJob: Fix error printf format on 32-bit architectures|MESSAGE:Spotted on arm, mips, and powerpc platforms on Debian.

diff --git a/src/job_metadata.c b/src/job_metadata.c
index 63533b6..23c9e83 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -1359,7 +1359,7 @@ AlterJob(int64 jobId, text *scheduleText, text *commandText, text *databaseText,
 	pfree(querybuf.data);
 
 	if (SPI_processed <= 0)
-		elog(ERROR, "Job %ld does not exist or you don't own it", jobId);
+		elog(ERROR, "Job " INT64_FORMAT " does not exist or you don't own it", jobId);
 
 	SPI_finish();
 	SetUserIdAndSecContext(savedUserId, savedSecurityContext);

COMMIT_HASH:4a82548e4e5ae1c0682283fee8559d4111e4c60d|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2021-10-05 12:04:06 +0200|TITLE:Merge pull request #158 from sebastianwebber/main|MESSAGE:
COMMIT_HASH:5c13847e18be0ad91036711bad0a07f09ef22869|AUTHOR_NAME:Sebastian Webber|AUTHOR_EMAIL:sebastian@swebber.me|DATE:2021-09-29 08:34:11 -0300|TITLE:feat: add regress options to run install|MESSAGE:This commit adds extra options to the pg_regress, enabling to the
support to create a functional postgres instance to run the tests
without a server running.

Also updated `.gitignore` file with the files created by the pg_regress.

Signed-off-by: Sebastian Webber <sebastian@swebber.me>
Co-authored-by: Guilherme Elias <elias@ongres.com>

diff --git a/.gitignore b/.gitignore
index a5a3a00..37bbe0d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -38,3 +38,7 @@ lib*.pc
 /src/Makefile.custom
 
 pg_cron--?.?.sql
+
+log/
+results/
+src/*.bc
diff --git a/Makefile b/Makefile
index cad2b84..cf8fef0 100644
--- a/Makefile
+++ b/Makefile
@@ -5,6 +5,8 @@ EXTVERSION = 1.3
 
 DATA_built = $(EXTENSION)--1.0.sql
 DATA = $(wildcard $(EXTENSION)--*--*.sql)
+
+REGRESS_OPTS =--temp-config=./pg_cron.conf --temp-instance=./tmp_check
 REGRESS = pg_cron-test 
 
 # compilation configuration
diff --git a/pg_cron.conf b/pg_cron.conf
new file mode 100644
index 0000000..6946a52
--- /dev/null
+++ b/pg_cron.conf
@@ -0,0 +1 @@
+shared_preload_libraries = 'pg_cron'

COMMIT_HASH:58134b1a3119096b1085453f20c48e818471ffe0|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2021-09-27 17:54:31 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 02cfeea..1601efd 100644
--- a/README.md
+++ b/README.md
@@ -114,7 +114,7 @@ For security, jobs are executed in the database in which the `cron.schedule` fun
 
 Articles showing possible ways of using pg_cron:
 
-* [Auto-partitioning using pg_partman](https://www.citusdata.com/blog/2018/01/24/citus-and-pg-partman-creating-a-scalable-time-series-database-on-PostgreSQL/)
+* [Auto-partitioning using pg_partman](https://www.citusdata.com/blog/2018/01/24/citus-and-pg-partman-creating-a-scalable-time-series-database-on-postgresql/)
 * [Computing rollups in an analytical dashboard](https://www.citusdata.com/blog/2017/12/27/real-time-analytics-dashboards-with-citus/)
 * [Deleting old data, vacuum](https://www.citusdata.com/blog/2016/09/09/pgcron-run-periodic-jobs-in-postgres/)
 * [Feeding cats](http://bonesmoses.org/2016/09/09/pg-phriday-irrelevant-inclinations/)

COMMIT_HASH:a78d20b2c059266248965b86c056f3e59f1a7c8b|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2021-09-25 19:08:55 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index f086091..02cfeea 100644
--- a/README.md
+++ b/README.md
@@ -119,6 +119,7 @@ Articles showing possible ways of using pg_cron:
 * [Deleting old data, vacuum](https://www.citusdata.com/blog/2016/09/09/pgcron-run-periodic-jobs-in-postgres/)
 * [Feeding cats](http://bonesmoses.org/2016/09/09/pg-phriday-irrelevant-inclinations/)
 * [Routinely invoking a function](https://fluca1978.github.io/2019/05/21/pgcron.html)
+* [Postgres as a cron server](https://supabase.io/blog/2021/03/05/postgres-as-a-cron-server)
 
 ## Managed services
 

COMMIT_HASH:d85b9d29e5de312df55461bfee05abdee4911689|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2021-09-25 19:07:00 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index d99755e..f086091 100644
--- a/README.md
+++ b/README.md
@@ -4,7 +4,7 @@
 
 ## What is pg_cron?
 
-pg_cron is a simple cron-based job scheduler for PostgreSQL (9.5 or higher) that runs inside the database as an extension. It uses the same syntax as regular cron, but it allows you to schedule PostgreSQL commands directly from the database:
+pg_cron is a simple cron-based job scheduler for PostgreSQL (10 or higher) that runs inside the database as an extension. It uses the same syntax as regular cron, but it allows you to schedule PostgreSQL commands directly from the database:
 
 ```sql
 -- Delete old data on Saturday at 3:30am (GMT)

COMMIT_HASH:005d20c54c7adb55fe7e55454881150d3f6038d1|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2021-09-25 19:55:16 +0300|TITLE:Add v1.4.1 to CHANGELOG|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 973dc9e..a09e849 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,7 @@
+### pg_cron v1.4.1 (September 25, 2021) ###
+
+* Fixes PostgreSQL 11- support
+
 ### pg_cron v1.4.0 (September 16, 2021) ###
 
 * Adds a cron.alter_job function to change job properties, by Bertrand Drouvot

COMMIT_HASH:5accb318e847a7716aee5fd5e4b258e291f5b030|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2021-09-25 19:51:44 +0300|TITLE:Fix PG11- support|MESSAGE:
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 2c92aac..63533b6 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -371,6 +371,7 @@ GetRoleOidIfCanLogin(char *username)
 {
 	HeapTuple   roletup;
 	Form_pg_authid rform;
+	Oid roleOid = InvalidOid;
 
 	roletup = SearchSysCache1(AUTHNAME, PointerGetDatum(username));
 	if (!HeapTupleIsValid(roletup))
@@ -386,8 +387,14 @@ GetRoleOidIfCanLogin(char *username)
 						username),
 				 errdetail("Jobs may only be run by roles that have the LOGIN attribute.")));
 
+#if (PG_VERSION_NUM < 120000)
+	roleOid = HeapTupleGetOid(roletup);
+#else
+	roleOid = rform->oid;
+#endif
+
 	ReleaseSysCache(roletup);
-	return rform->oid;
+	return roleOid;
 }
 
 /*

COMMIT_HASH:35187e8c0f257b12b3798329071edaafa4708f69|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2021-09-16 11:20:02 +0200|TITLE:Adjust CHANGELOG for v1.4.0|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 56fe35d..973dc9e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,7 @@
 ### pg_cron v1.4.0 (September 16, 2021) ###
 
 * Adds a cron.alter_job function to change job properties, by Bertrand Drouvot
+* Adds a cron.schedule_in_database function to schedule in a custom database, by Bertrand Drouvot
 * Adds a cron.log_min_messages setting to control log_min_messages in pg_cron launcher, by Bertrand Drouvot
 * Adds a cron.enable_superuser_jobs setting to disallow superuser jobs
 * Fixes a bug that could cause jobs to hang when using cron.use_background_workers, by Bertrand Drouvot

COMMIT_HASH:e6ac9c32ee7df0c3cd9f8435fd0b1e92c25c1425|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2021-09-16 11:17:26 +0200|TITLE:Rename schedule with additional arguments to schedule_in_database|MESSAGE:
diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index 5fca73a..a845929 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -110,12 +110,12 @@ revoke connect on database pgcron_dbno from public;
 create user pgcron_cront with password 'pwd';
 GRANT USAGE ON SCHEMA cron TO pgcron_cront;
 -- Schedule a job for this user on the database that does not accept connections
-SELECT cron.schedule(job_name:='can not connect', schedule:='0 11 * * *', command:='VACUUM',database:='pgcron_dbno',username:='pgcron_cront');
+SELECT cron.schedule_in_database(job_name:='can not connect', schedule:='0 11 * * *', command:='VACUUM',database:='pgcron_dbno',username:='pgcron_cront');
 ERROR:  User pgcron_cront does not have CONNECT privilege on pgcron_dbno
 -- Create a database that does allow connections
 create database pgcron_dbyes;
 -- Schedule a job on the database that does accept connections for a non existing user
-SELECT cron.schedule(job_name:='user does not exist', schedule:='0 11 * * *', command:='VACUUM',database:='pgcron_dbyes',username:='pgcron_useraqwxszedc');
+SELECT cron.schedule_in_database(job_name:='user does not exist', schedule:='0 11 * * *', command:='VACUUM',database:='pgcron_dbyes',username:='pgcron_useraqwxszedc');
 ERROR:  role "pgcron_useraqwxszedc" does not exist
 -- Alter an existing job on a database that does not accept connections
 SELECT cron.alter_job(job_id:=2,database:='pgcron_dbno',username:='pgcron_cront');
@@ -132,8 +132,8 @@ SELECT cron.schedule('My vacuum', '0 11 * * *', 'VACUUM');
 (1 row)
 
 -- Create a job for another user
-SELECT cron.schedule(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',username:='anotheruser');
-ERROR:  must be superuser to create a job for another role
+SELECT cron.schedule_in_database(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',database:=current_database(),username:='anotheruser');
+ERROR:  permission denied for function schedule_in_database
 -- Change the username of an existing job that the user own
 select cron.alter_job(job_id:=6,username:='anotheruser');
 ERROR:  must be superuser to alter username
@@ -178,10 +178,10 @@ SELECT username FROM cron.job where jobid=2;
 (1 row)
 
 -- Create a job for another user
-SELECT cron.schedule(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',username:='pgcron_cront');
- schedule 
-----------
-        7
+SELECT cron.schedule_in_database(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',database:=current_database(), username:='pgcron_cront');
+ schedule_in_database 
+----------------------
+                    7
 (1 row)
 
 SELECT username FROM cron.job where jobid=7;
@@ -199,10 +199,10 @@ SELECT cron.alter_job(7, username := current_user);
 ERROR:  cannot schedule jobs as superuser
 DETAIL:  Scheduling jobs as superuser is disallowed when cron.enable_superuser_jobs is set to off.
 -- Scheduling as other users is allowed as superuser
-SELECT cron.schedule(job_name:='more vacuum', schedule:='0 12 * * *', command:='VACUUM', username:='pgcron_cront');
- schedule 
-----------
-        8
+SELECT cron.schedule_in_database(job_name:='more vacuum', schedule:='0 12 * * *', command:='VACUUM', database:=current_database(), username:='pgcron_cront');
+ schedule_in_database 
+----------------------
+                    8
 (1 row)
 
 SELECT cron.alter_job(7, username := 'pgcron_cront');
diff --git a/pg_cron--1.3--1.4.sql b/pg_cron--1.3--1.4.sql
index 3c4af9a..300c7ef 100644
--- a/pg_cron--1.3--1.4.sql
+++ b/pg_cron--1.3--1.4.sql
@@ -1,5 +1,16 @@
 /* pg_cron--1.3--1.4.sql */
 
+/* cron_schedule_named expects job name to be text */
+DROP FUNCTION cron.schedule(name,text,text);
+CREATE FUNCTION cron.schedule(job_name text,
+                              schedule text,
+                              command text)
+RETURNS bigint
+LANGUAGE C
+AS 'MODULE_PATHNAME', $$cron_schedule_named$$;
+COMMENT ON FUNCTION cron.schedule(text,text,text)
+IS 'schedule a pg_cron job';
+
 CREATE FUNCTION cron.alter_job(job_id bigint,
 								schedule text default null,
 								command text default null,
@@ -16,15 +27,18 @@ IS 'Alter the job identified by job_id. Any option left as NULL will not be modi
 /* admin should decide whether alter_job is safe by explicitly granting execute */
 REVOKE ALL ON FUNCTION cron.alter_job(bigint,text,text,text,text,boolean) FROM public;
 
-CREATE FUNCTION cron.schedule(job_name text,
-								schedule text,
-								command text,
-								database text default null,
-								username text default null,
-								active boolean default 'true')
+CREATE FUNCTION cron.schedule_in_database(job_name text,
+										  schedule text,
+										  command text,
+										  database text,
+										  username text default null,
+										  active boolean default 'true')
 RETURNS bigint
 LANGUAGE C
 AS 'MODULE_PATHNAME', $$cron_schedule_named$$;
 
-COMMENT ON FUNCTION cron.schedule(text,text,text,text,text,boolean)
+COMMENT ON FUNCTION cron.schedule_in_database(text,text,text,text,text,boolean)
 IS 'schedule a pg_cron job';
+
+/* admin should decide whether cron.schedule_in_database is safe by explicitly granting execute */
+REVOKE ALL ON FUNCTION cron.schedule_in_database(text,text,text,text,text,boolean) FROM public;
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index 5030984..3bc9cba 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -57,13 +57,13 @@ create user pgcron_cront with password 'pwd';
 GRANT USAGE ON SCHEMA cron TO pgcron_cront;
 
 -- Schedule a job for this user on the database that does not accept connections
-SELECT cron.schedule(job_name:='can not connect', schedule:='0 11 * * *', command:='VACUUM',database:='pgcron_dbno',username:='pgcron_cront');
+SELECT cron.schedule_in_database(job_name:='can not connect', schedule:='0 11 * * *', command:='VACUUM',database:='pgcron_dbno',username:='pgcron_cront');
 
 -- Create a database that does allow connections
 create database pgcron_dbyes;
 
 -- Schedule a job on the database that does accept connections for a non existing user
-SELECT cron.schedule(job_name:='user does not exist', schedule:='0 11 * * *', command:='VACUUM',database:='pgcron_dbyes',username:='pgcron_useraqwxszedc');
+SELECT cron.schedule_in_database(job_name:='user does not exist', schedule:='0 11 * * *', command:='VACUUM',database:='pgcron_dbyes',username:='pgcron_useraqwxszedc');
 
 -- Alter an existing job on a database that does not accept connections
 SELECT cron.alter_job(job_id:=2,database:='pgcron_dbno',username:='pgcron_cront');
@@ -78,7 +78,7 @@ SET SESSION AUTHORIZATION pgcron_cront;
 SELECT cron.schedule('My vacuum', '0 11 * * *', 'VACUUM');
 
 -- Create a job for another user
-SELECT cron.schedule(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',username:='anotheruser');
+SELECT cron.schedule_in_database(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',database:=current_database(),username:='anotheruser');
 
 -- Change the username of an existing job that the user own
 select cron.alter_job(job_id:=6,username:='anotheruser');
@@ -102,7 +102,7 @@ select cron.alter_job(job_id:=2,username:='pgcron_cront');
 SELECT username FROM cron.job where jobid=2;
 
 -- Create a job for another user
-SELECT cron.schedule(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',username:='pgcron_cront');
+SELECT cron.schedule_in_database(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',database:=current_database(), username:='pgcron_cront');
 SELECT username FROM cron.job where jobid=7;
 
 -- Try to schedule a job as superuser when it is not allowed
@@ -112,7 +112,7 @@ SELECT cron.schedule(job_name:='disallowed-superuser', schedule:='* * * * *', co
 SELECT cron.alter_job(7, username := current_user);
 
 -- Scheduling as other users is allowed as superuser
-SELECT cron.schedule(job_name:='more vacuum', schedule:='0 12 * * *', command:='VACUUM', username:='pgcron_cront');
+SELECT cron.schedule_in_database(job_name:='more vacuum', schedule:='0 12 * * *', command:='VACUUM', database:=current_database(), username:='pgcron_cront');
 SELECT cron.alter_job(7, username := 'pgcron_cront');
 
 -- cleaning
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 92f73ee..2c92aac 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -485,14 +485,17 @@ cron_schedule_named(PG_FUNCTION_ARGS)
 	else
 		commandText = PG_GETARG_TEXT_P(2);
 
-	if (!PG_ARGISNULL(3))
-		databaseText = PG_GETARG_TEXT_P(3);
+	if (PG_NARGS() > 3)
+	{
+		if (!PG_ARGISNULL(3))
+			databaseText = PG_GETARG_TEXT_P(3);
 
-	if (!PG_ARGISNULL(4))
-		usernameText = PG_GETARG_TEXT_P(4);
+		if (!PG_ARGISNULL(4))
+			usernameText = PG_GETARG_TEXT_P(4);
 
-	if (!PG_ARGISNULL(5))
-		active = PG_GETARG_BOOL(5);
+		if (!PG_ARGISNULL(5))
+			active = PG_GETARG_BOOL(5);
+	}
 
 	jobId = ScheduleCronJob(scheduleText, commandText, databaseText,
 							usernameText, active, jobnameText);

COMMIT_HASH:da41863bc97995ba29468ec8b5419cbc664af16a|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2021-09-16 10:34:39 +0200|TITLE:Add v1.4.0 to CHANGELOG.md|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index d89cf84..56fe35d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,12 @@
+### pg_cron v1.4.0 (September 16, 2021) ###
+
+* Adds a cron.alter_job function to change job properties, by Bertrand Drouvot
+* Adds a cron.log_min_messages setting to control log_min_messages in pg_cron launcher, by Bertrand Drouvot
+* Adds a cron.enable_superuser_jobs setting to disallow superuser jobs
+* Fixes a bug that could cause jobs to hang when using cron.use_background_workers, by Bertrand Drouvot
+* Fixes a small memory allocation bug, by @mrdrivingduck
+* PostgreSQL 14 is supported (no changes were needed)
+
 ### pg_cron v1.3.1 (March 29, 2021) ###
 
 * Fixes a memory leak

COMMIT_HASH:feefadb1e0540bcd2ff6a486be6fd3ac153cdc92|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2021-09-16 10:20:11 +0200|TITLE:Merge pull request #153 from citusdata/marcocitus/enable-superuser-jobs|MESSAGE:Add cron.enable_superuser_jobs option to disallow superuser jobs
COMMIT_HASH:e2c7e8d6fb8bd7350508e28cf6a328fab3790708|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2021-09-16 10:19:19 +0200|TITLE:Merge pull request #154 from citusdata/marcocitus/revoke-alter|MESSAGE:Revoke execute on alter_job from public by default
COMMIT_HASH:dd5aee084e45d2406f3f650edd7a9e36e69ec97e|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2021-09-14 20:09:22 +0200|TITLE:Merge pull request #152 from bdrouvotAWS/full_mq|MESSAGE:
COMMIT_HASH:5e7524d8a719781938a3fc84b500c821067b2a80|AUTHOR_NAME:bdrouvotAWS|AUTHOR_EMAIL:bdrouvot@amazon.com|DATE:2021-09-14 10:17:42 +0000|TITLE:Fix hung state when cron.use_background_workers = true and the message queue is full.|MESSAGE:With cron.use_background_workers = true, a running job can be
in a hung state waiting for the MessageQueuePutMessage wait event.
This state is reached if the message queue is FULL and the job is still running.
Indeed, currently, we are not reading the message queue if the job is still running.

This fix is reading the queue periodically and display intermediate messages (if any) in the audit table.

diff --git a/src/pg_cron.c b/src/pg_cron.c
index a3afe4a..e7b588b 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -138,7 +138,7 @@ static void ManageCronTasks(List *taskList, TimestampTz currentTime);
 static void ManageCronTask(CronTask *task, TimestampTz currentTime);
 static void ExecuteSqlString(const char *sql);
 static void GetTaskFeedback(PGresult *result, CronTask *task);
-static void GetBgwTaskFeedback(shm_mq_handle *responseq, CronTask *task);
+static void GetBgwTaskFeedback(shm_mq_handle *responseq, CronTask *task, bool running);
 
 static bool jobCanceled(CronTask *task);
 static bool jobStartupTimeout(CronTask *task, TimestampTz currentTime);
@@ -1664,10 +1664,6 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				break;
 			}
 
-			/* still waiting for job to complete */
-			if (GetBackgroundWorkerPid(&task->handle, &pid) != BGWH_STOPPED)
-				break;
-
 			toc = shm_toc_attach(PG_CRON_MAGIC, dsm_segment_address(task->seg));
 			#if PG_VERSION_NUM < 100000
 				mq = shm_toc_lookup(toc, PG_CRON_KEY_QUEUE);
@@ -1675,7 +1671,16 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				mq = shm_toc_lookup(toc, PG_CRON_KEY_QUEUE, false);
 			#endif
 			responseq = shm_mq_attach(mq, task->seg, NULL);
-			GetBgwTaskFeedback(responseq, task);
+
+			/* still waiting for job to complete */
+			if (GetBackgroundWorkerPid(&task->handle, &pid) != BGWH_STOPPED)
+			{
+				GetBgwTaskFeedback(responseq, task, true);
+				shm_mq_detach(responseq);
+				break;
+			}
+
+			GetBgwTaskFeedback(responseq, task, false);
 
 			task->state = CRON_TASK_DONE;
 			dsm_detach(task->seg);
@@ -1840,7 +1845,7 @@ GetTaskFeedback(PGresult *result, CronTask *task)
 }
 
 static void
-GetBgwTaskFeedback(shm_mq_handle *responseq, CronTask *task)
+GetBgwTaskFeedback(shm_mq_handle *responseq, CronTask *task, bool running)
 {
 
 	TimestampTz end_time;
@@ -1887,9 +1892,10 @@ GetBgwTaskFeedback(shm_mq_handle *responseq, CronTask *task)
 
 						if (edata.elevel >= ERROR)
 							UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_FAILED), display_msg.data, NULL, &end_time);
+						else if (running)
+							UpdateJobRunDetail(task->runId, NULL, NULL, display_msg.data, NULL, NULL);
 						else
 							UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_SUCCEEDED), display_msg.data, NULL, &end_time);
-
 					}
 
 					ereport(LOG, (errmsg("cron job " INT64_FORMAT ": %s",

COMMIT_HASH:d2e5fa39e3f4f188fc9dde5c7f07c4f359bfd036|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2021-09-14 13:37:19 +0200|TITLE:Revoke execute on alter_job from public by default|MESSAGE:
diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index 7f90789..e9727df 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -119,6 +119,8 @@ ERROR:  role "pgcron_useraqwxszedc" does not exist
 -- Alter an existing job on a database that does not accept connections
 SELECT cron.alter_job(job_id:=2,database:='pgcron_dbno',username:='pgcron_cront');
 ERROR:  User pgcron_cront does not have CONNECT privilege on pgcron_dbno
+-- Make sure pgcron_cront can execute alter_job
+GRANT EXECUTE ON FUNCTION cron.alter_job(bigint,text,text,text,text,boolean) TO public;
 -- Second as non superuser
 SET SESSION AUTHORIZATION pgcron_cront;
 -- Create a job
diff --git a/pg_cron--1.3--1.4.sql b/pg_cron--1.3--1.4.sql
index 266e7f0..3c4af9a 100644
--- a/pg_cron--1.3--1.4.sql
+++ b/pg_cron--1.3--1.4.sql
@@ -13,6 +13,9 @@ AS 'MODULE_PATHNAME', $$cron_alter_job$$;
 COMMENT ON FUNCTION cron.alter_job(bigint,text,text,text,text,boolean)
 IS 'Alter the job identified by job_id. Any option left as NULL will not be modified.';
 
+/* admin should decide whether alter_job is safe by explicitly granting execute */
+REVOKE ALL ON FUNCTION cron.alter_job(bigint,text,text,text,text,boolean) FROM public;
+
 CREATE FUNCTION cron.schedule(job_name text,
 								schedule text,
 								command text,
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index ca2938c..66838fe 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -66,6 +66,9 @@ SELECT cron.schedule(job_name:='user does not exist', schedule:='0 11 * * *', co
 -- Alter an existing job on a database that does not accept connections
 SELECT cron.alter_job(job_id:=2,database:='pgcron_dbno',username:='pgcron_cront');
 
+-- Make sure pgcron_cront can execute alter_job
+GRANT EXECUTE ON FUNCTION cron.alter_job(bigint,text,text,text,text,boolean) TO public;
+
 -- Second as non superuser
 SET SESSION AUTHORIZATION pgcron_cront;
 

COMMIT_HASH:f6576ff3773a1aae972eb7dc3fa1260e9f8e0bcb|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2021-09-14 13:28:36 +0200|TITLE:Add cron.enable_superuser_jobs option to disallow superuser jobs|MESSAGE:
diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index 7f90789..3619b87 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -12,6 +12,7 @@ SELECT extversion FROM pg_extension WHERE extname='pg_cron';
  1.4
 (1 row)
 
+SET cron.enable_superuser_jobs TO on;
 -- Vacuum every day at 10:00am (GMT)
 SELECT cron.schedule('0 10 * * *', 'VACUUM');
  schedule 
@@ -187,6 +188,27 @@ SELECT username FROM cron.job where jobid=7;
  pgcron_cront
 (1 row)
 
+-- Try to schedule a job as superuser when it is not allowed
+SET cron.enable_superuser_jobs TO off;
+SELECT cron.schedule(job_name:='disallowed-superuser', schedule:='* * * * *', command:='drop database pg_crondbno');
+ERROR:  cannot schedule jobs as superuser
+DETAIL:  Scheduling jobs as superuser is disallowed when cron.enable_superuser_jobs is set to off.
+SELECT cron.alter_job(7, username := current_user);
+ERROR:  cannot schedule jobs as superuser
+DETAIL:  Scheduling jobs as superuser is disallowed when cron.enable_superuser_jobs is set to off.
+-- Scheduling as other users is allowed as superuser
+SELECT cron.schedule(job_name:='more vacuum', schedule:='0 12 * * *', command:='VACUUM', username:='pgcron_cront');
+ schedule 
+----------
+        8
+(1 row)
+
+SELECT cron.alter_job(7, username := 'pgcron_cront');
+ alter_job 
+-----------
+ 
+(1 row)
+
 -- cleaning
 DROP EXTENSION pg_cron;
 drop user pgcron_cront;
diff --git a/include/job_metadata.h b/include/job_metadata.h
index 7870668..c0fe18a 100644
--- a/include/job_metadata.h
+++ b/include/job_metadata.h
@@ -46,6 +46,7 @@ typedef struct CronJob
 /* global settings */
 extern char *CronHost;
 extern bool CronJobCacheValid;
+extern bool EnableSuperuserJobs;
 
 
 /* functions for retrieving job metadata */
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index ca2938c..e6d9821 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -3,6 +3,8 @@ SELECT extversion FROM pg_extension WHERE extname='pg_cron';
 ALTER EXTENSION pg_cron UPDATE TO '1.4';
 SELECT extversion FROM pg_extension WHERE extname='pg_cron';
 
+SET cron.enable_superuser_jobs TO on;
+
 -- Vacuum every day at 10:00am (GMT)
 SELECT cron.schedule('0 10 * * *', 'VACUUM');
 
@@ -100,6 +102,16 @@ SELECT username FROM cron.job where jobid=2;
 SELECT cron.schedule(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',username:='pgcron_cront');
 SELECT username FROM cron.job where jobid=7;
 
+-- Try to schedule a job as superuser when it is not allowed
+SET cron.enable_superuser_jobs TO off;
+
+SELECT cron.schedule(job_name:='disallowed-superuser', schedule:='* * * * *', command:='drop database pg_crondbno');
+SELECT cron.alter_job(7, username := current_user);
+
+-- Scheduling as other users is allowed as superuser
+SELECT cron.schedule(job_name:='more vacuum', schedule:='0 12 * * *', command:='VACUUM', username:='pgcron_cront');
+SELECT cron.alter_job(7, username := 'pgcron_cront');
+
 -- cleaning
 DROP EXTENSION pg_cron;
 drop user pgcron_cront;
diff --git a/src/job_metadata.c b/src/job_metadata.c
index ca18e2b..92f73ee 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -104,6 +104,7 @@ static HTAB *CronJobHash = NULL;
 static Oid CachedCronJobRelationId = InvalidOid;
 bool CronJobCacheValid = false;
 char *CronHost = "localhost";
+bool EnableSuperuserJobs = true;
 
 
 /*
@@ -286,6 +287,15 @@ ScheduleCronJob(text *scheduleText, text *commandText, text *databaseText,
 	/* use the GUC */
 		database_name = CronTableDatabaseName;
 
+	/* first do a crude check to see whether superuser jobs are allowed */
+	if (!EnableSuperuserJobs && superuser_arg(userIdcheckacl))
+	{
+		ereport(ERROR, (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
+						errmsg("cannot schedule jobs as superuser"),
+						errdetail("Scheduling jobs as superuser is disallowed when "
+								  "cron.enable_superuser_jobs is set to off.")));
+	}
+
 	/* ensure the user that is used in the job can connect to the database */
 	aclresult = pg_database_aclcheck(get_database_oid(database_name, false),
 										userIdcheckacl, ACL_CONNECT);
@@ -842,11 +852,29 @@ LoadCronJobList(void)
 	{
 		MemoryContext oldContext = NULL;
 		CronJob *job = NULL;
+		Oid jobOwnerId = InvalidOid;
 
 		oldContext = MemoryContextSwitchTo(CronJobContext);
 
 		job = TupleToCronJob(tupleDescriptor, heapTuple);
-		jobList = lappend(jobList, job);
+
+		jobOwnerId = get_role_oid(job->userName, false);
+		if (!EnableSuperuserJobs && superuser_arg(jobOwnerId))
+		{
+			/*
+			 * Someone inserted a superuser into the metadata. Skip over the
+			 * job when cron.enable_superuser_jobs is disabled. The memory
+			 * will be cleaned up when CronJobContext is reset.
+			 */
+			ereport(WARNING, (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
+							  errmsg("skipping job " INT64_FORMAT " since superuser jobs "
+									 "are currently disallowed",
+									 job->jobId)));
+		}
+		else
+		{
+			jobList = lappend(jobList, job);
+		}
 
 		MemoryContextSwitchTo(oldContext);
 
@@ -1211,7 +1239,17 @@ AlterJob(int64 jobId, text *scheduleText, text *commandText, text *databaseText,
 		userIdcheckacl = GetRoleOidIfCanLogin(username);
 	}
 	else
+	{
 		username = currentuser;
+	}
+
+	if (!EnableSuperuserJobs && superuser_arg(userIdcheckacl))
+	{
+		ereport(ERROR, (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
+						errmsg("cannot schedule jobs as superuser"),
+						errdetail("Scheduling jobs as superuser is disallowed when "
+								  "cron.enable_superuser_jobs is set to off.")));
+	}
 
 	/* add the fields to be updated */
 	/* database has been provided */
diff --git a/src/pg_cron.c b/src/pg_cron.c
index a3afe4a..8401a76 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -232,6 +232,16 @@ _PG_init(void)
 		GUC_SUPERUSER_ONLY,
 		NULL, NULL, NULL);
 
+	DefineCustomBoolVariable(
+		"cron.enable_superuser_jobs",
+		gettext_noop("Allow jobs to be scheduled as superuser"),
+		NULL,
+		&EnableSuperuserJobs,
+		true,
+		PGC_USERSET,
+		GUC_SUPERUSER_ONLY,
+		NULL, NULL, NULL);
+
 	DefineCustomStringVariable(
 		"cron.host",
 		gettext_noop("Hostname to connect to postgres."),

COMMIT_HASH:56b81febd182f81e0292754e01e1969c3066f732|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@microsoft.com|DATE:2021-08-24 14:19:06 +0200|TITLE:Merge pull request #146 from mrdrivingduck/main|MESSAGE:Palloc for pointer array instead of struct array
COMMIT_HASH:df3a8ecc4f9d88f13dab054087d2103d7653f663|AUTHOR_NAME:mrdrivingduck|AUTHOR_EMAIL:562655624@qq.com|DATE:2021-08-19 23:37:12 +0800|TITLE:Palloc for pointer array instead of struct array|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 8acf9d8..a3afe4a 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -1017,7 +1017,7 @@ PollForTasks(List *taskList)
 	int activeTaskCount = 0;
 	ListCell *taskCell = NULL;
 
-	polledTasks = (CronTask **) palloc0(taskCount * sizeof(CronTask));
+	polledTasks = (CronTask **) palloc0(taskCount * sizeof(CronTask *));
 	pollFDs = (struct pollfd *) palloc0(taskCount * sizeof(struct pollfd));
 
 	currentTime = GetCurrentTimestamp();

COMMIT_HASH:9d8f81731db341f1bf9dc11b84743db1b93d69bf|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2021-08-03 14:45:28 +0200|TITLE:Merge pull request #143 from lornajane/add-aiven-cloud-provider|MESSAGE:Add Aiven to the list of cloud providers with pg_cron support
COMMIT_HASH:5ee33d5ce6e5a702e2ea95fb07ce4591c11d185e|AUTHOR_NAME:Lorna Mitchell|AUTHOR_EMAIL:lornajane@aiven.io|DATE:2021-07-27 11:27:20 +0100|TITLE:Add Aiven to the list of cloud providers with pg_cron support|MESSAGE:
diff --git a/README.md b/README.md
index 5e736b4..d99755e 100644
--- a/README.md
+++ b/README.md
@@ -126,6 +126,7 @@ The following table keeps track of which of the major managed Postgres services
 
 | Service       | Supported     |
 | ------------- |:-------------:|
+| [Aiven](https://aiven.io/postgresql) | :heavy_check_mark: |
 | [Alibaba Cloud](https://www.alibabacloud.com/help/doc-detail/150355.htm) | :heavy_check_mark: |
 | [Amazon RDS](https://aws.amazon.com/rds/postgresql/)     | :heavy_check_mark:      |          |
 | [Azure](https://azure.microsoft.com/en-us/services/postgresql/) | :heavy_check_mark:  |

COMMIT_HASH:5a4ca65678a12b62ca44977a49b4ec9c1107b7d2|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2021-06-25 16:10:26 +0200|TITLE:Merge pull request #126 from bdrouvotAWS/log_min_messages|MESSAGE:
COMMIT_HASH:deba43cd08b0af9be7fff51716b35ea2d9b148e8|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2021-05-31 11:09:47 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index bfc215d..5e736b4 100644
--- a/README.md
+++ b/README.md
@@ -134,4 +134,6 @@ The following table keeps track of which of the major managed Postgres services
 | [DigitalOcean](https://www.digitalocean.com/products/managed-databases/) | :heavy_check_mark: |
 | [Google Cloud](https://cloud.google.com/sql/docs/postgres/) | :x:      |
 | [Heroku](https://elements.heroku.com/addons/heroku-postgresql) | :x: | |
+| [ScaleGrid](https://scalegrid.io/postgresql.html) | :heavy_check_mark:  |
+| [Scaleway](https://www.scaleway.com/en/database/) | :heavy_check_mark:  |
 | [Supabase](https://supabase.io/docs/guides/database) | :heavy_check_mark:  |

COMMIT_HASH:a94927022ff40a7d32e1ceb937aee80e7385dadd|AUTHOR_NAME:bdrouvotAWS|AUTHOR_EMAIL:bdrouvot@amazon.com|DATE:2021-02-03 09:40:58 +0000|TITLE:adding cron.log_min_messages|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 460b22d..8acf9d8 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -149,6 +149,7 @@ static void bgw_generate_returned_message(StringInfoData *display_msg, ErrorData
 char *CronTableDatabaseName = "postgres";
 static bool CronLogStatement = true;
 static bool CronLogRun = true;
+static bool CronReloadConfig = false;
 
 /* flags set by signal handlers */
 static volatile sig_atomic_t got_sigterm = false;
@@ -159,8 +160,27 @@ static const int MaxWait = 1000; /* maximum time in ms that poll() can block */
 static bool RebootJobsScheduled = false;
 static int RunningTaskCount = 0;
 static int MaxRunningTasks = 0;
+static int CronLogMinMessages = WARNING;
 static bool UseBackgroundWorkers = false;
 
+static const struct config_enum_entry cron_message_level_options[] = {
+	{"debug5", DEBUG5, false},
+	{"debug4", DEBUG4, false},
+	{"debug3", DEBUG3, false},
+	{"debug2", DEBUG2, false},
+	{"debug1", DEBUG1, false},
+	{"debug", DEBUG2, true},
+	{"info", INFO, false},
+	{"notice", NOTICE, false},
+	{"warning", WARNING, false},
+	{"error", ERROR, false},
+	{"log", LOG, false},
+	{"fatal", FATAL, false},
+	{"panic", PANIC, false},
+	{NULL, 0, false}
+};
+
+static const char *cron_error_severity(int elevel);
 
 /*
  * _PG_init gets called when the extension is loaded.
@@ -257,6 +277,17 @@ _PG_init(void)
 			GUC_SUPERUSER_ONLY,
 			NULL, NULL, NULL);
 
+	DefineCustomEnumVariable(
+		"cron.log_min_messages",
+		gettext_noop("log_min_messages for the launcher bgworker."),
+		NULL,
+		&CronLogMinMessages,
+		WARNING,
+		cron_message_level_options,
+		PGC_SIGHUP,
+		GUC_SUPERUSER_ONLY,
+		NULL, NULL, NULL);
+
 	/* set up common data for all our workers */
 	worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
 	worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
@@ -302,6 +333,7 @@ static void
 pg_cron_sighup(SIGNAL_ARGS)
 {
 	CronJobCacheValid = false;
+	CronReloadConfig = true;
 
 	if (MyProc != NULL)
 	{
@@ -366,6 +398,60 @@ interpret_error:
         return "";
 }
 
+/*
+ * cron_error_severity --- get string representing elevel
+ */
+static const char *
+cron_error_severity(int elevel)
+{
+	const char *elevel_char;
+
+	switch (elevel)
+	{
+		case DEBUG1:
+			elevel_char = "DEBUG1";
+			break;
+		case DEBUG2:
+			elevel_char = "DEBUG2";
+			break;
+		case DEBUG3:
+			elevel_char = "DEBUG3";
+			break;
+		case DEBUG4:
+			elevel_char = "DEBUG4";
+			break;
+		case DEBUG5:
+			elevel_char = "DEBUG5";
+			break;
+		case LOG:
+			elevel_char = "LOG";
+			break;
+		case INFO:
+			elevel_char = "INFO";
+			break;
+		case NOTICE:
+			elevel_char = "NOTICE";
+			break;
+		case WARNING:
+			elevel_char = "WARNING";
+			break;
+		case ERROR:
+			elevel_char = "ERROR";
+			break;
+		case FATAL:
+			elevel_char = "FATAL";
+			break;
+		case PANIC:
+			elevel_char = "PANIC";
+			break;
+		default:
+			elevel_char = "???";
+			break;
+	}
+
+	return elevel_char;
+}
+
 /*
  * bgw_generate_returned_message -
  *      generates the message to be inserted into the job_run_details table
@@ -521,6 +607,10 @@ PgCronLauncherMain(Datum arg)
 
 	ereport(LOG, (errmsg("pg_cron scheduler started")));
 
+	/* set the desired log_min_messages */
+	SetConfigOption("log_min_messages", cron_error_severity(CronLogMinMessages),
+										PGC_POSTMASTER, PGC_S_OVERRIDE);
+
 	MemoryContextSwitchTo(CronLoopContext);
 
 	while (!got_sigterm)
@@ -535,6 +625,15 @@ PgCronLauncherMain(Datum arg)
 			RefreshTaskHash();
 		}
 
+		if (CronReloadConfig)
+		{
+			/* set the desired log_min_messages */
+			ProcessConfigFile(PGC_SIGHUP);
+			SetConfigOption("log_min_messages", cron_error_severity(CronLogMinMessages),
+												PGC_POSTMASTER, PGC_S_OVERRIDE);
+			CronReloadConfig = false;
+		}
+
 		taskList = CurrentTaskList();
 		currentTime = GetCurrentTimestamp();
 

COMMIT_HASH:a0feb427bf0b44da1a7f8ae36a63502fdda7fa0e|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2021-03-29 11:24:32 +0200|TITLE:Update changelog entry for v1.3.1|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 21839d3..d89cf84 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,7 @@
+### pg_cron v1.3.1 (March 29, 2021) ###
+
+* Fixes a memory leak
+
 ### pg_cron v1.3.0 (September 30, 2020) ###
 
 * Background worker support by Bertrand Drouvot

COMMIT_HASH:aeaf824e9f8adf2f3c37a78b9585eccc4d412fa4|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2021-03-29 11:15:48 +0200|TITLE:Merge pull request #133 from citusdata/marcocitus/fix-memory-leak|MESSAGE:Always reset memory context in job_metadata functions
COMMIT_HASH:537007b4075a94d362445e41be3810c4037cafd4|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2021-03-29 11:09:44 +0200|TITLE:Always reset memory context in job_metadata functions|MESSAGE:
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 2e1b1f8..ca18e2b 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -505,6 +505,7 @@ NextRunId(void)
 	Datum jobIdDatum = 0;
 	int64 jobId = 0;
 	bool failOK = true;
+	MemoryContext originalContext = CurrentMemoryContext;
 
 	StartTransactionCommand();
 	PushActiveSnapshot(GetTransactionSnapshot());
@@ -513,6 +514,7 @@ NextRunId(void)
 	{
 		PopActiveSnapshot();
 		CommitTransactionCommand();
+		MemoryContextSwitchTo(originalContext);
 
 		/* if the job_run_details table is not yet created, the run ID is not used */
 		return 0;
@@ -537,6 +539,7 @@ NextRunId(void)
 
 	PopActiveSnapshot();
 	CommitTransactionCommand();
+	MemoryContextSwitchTo(originalContext);
 
 	return jobId;
 }
@@ -820,6 +823,7 @@ LoadCronJobList(void)
 	{
 		PopActiveSnapshot();
 		CommitTransactionCommand();
+		MemoryContextSwitchTo(originalContext);
 		pgstat_report_activity(STATE_IDLE, NULL);
 
 		return NIL;
@@ -854,9 +858,8 @@ LoadCronJobList(void)
 
 	PopActiveSnapshot();
 	CommitTransactionCommand();
-	pgstat_report_activity(STATE_IDLE, NULL);
-
 	MemoryContextSwitchTo(originalContext);
+	pgstat_report_activity(STATE_IDLE, NULL);
 
 	return jobList;
 }
@@ -992,6 +995,7 @@ InsertJobRunDetail(int64 runId, int64 *jobId, char *database, char *username, ch
 	const int argCount = 6;
 	Oid argTypes[6];
 	Datum argValues[6];
+	MemoryContext originalContext = CurrentMemoryContext;
 
 	SetCurrentStatementStartTimestamp();
 	StartTransactionCommand();
@@ -1001,6 +1005,7 @@ InsertJobRunDetail(int64 runId, int64 *jobId, char *database, char *username, ch
 	{
 		PopActiveSnapshot();
 		CommitTransactionCommand();
+		MemoryContextSwitchTo(originalContext);
 		return;
 	}
 
@@ -1050,6 +1055,7 @@ InsertJobRunDetail(int64 runId, int64 *jobId, char *database, char *username, ch
 	SPI_finish();
 	PopActiveSnapshot();
 	CommitTransactionCommand();
+	MemoryContextSwitchTo(originalContext);
 	pgstat_report_activity(STATE_IDLE, NULL);
 }
 
@@ -1061,6 +1067,7 @@ UpdateJobRunDetail(int64 runId, int32 *job_pid, char *status, char *return_messa
 	Oid argTypes[6];
 	Datum argValues[6];
 	int i;
+	MemoryContext originalContext = CurrentMemoryContext;
 
 	SetCurrentStatementStartTimestamp();
 	StartTransactionCommand();
@@ -1070,6 +1077,7 @@ UpdateJobRunDetail(int64 runId, int32 *job_pid, char *status, char *return_messa
 	{
 		PopActiveSnapshot();
 		CommitTransactionCommand();
+		MemoryContextSwitchTo(originalContext);
 		return;
 	}
 
@@ -1151,6 +1159,7 @@ UpdateJobRunDetail(int64 runId, int32 *job_pid, char *status, char *return_messa
 	SPI_finish();
 	PopActiveSnapshot();
 	CommitTransactionCommand();
+	MemoryContextSwitchTo(originalContext);
 	pgstat_report_activity(STATE_IDLE, NULL);
 }
 
@@ -1313,6 +1322,7 @@ void
 MarkPendingRunsAsFailed(void)
 {
 	StringInfoData querybuf;
+	MemoryContext originalContext = CurrentMemoryContext;
 
 	SetCurrentStatementStartTimestamp();
 	StartTransactionCommand();
@@ -1322,6 +1332,7 @@ MarkPendingRunsAsFailed(void)
 	{
 		PopActiveSnapshot();
 		CommitTransactionCommand();
+		MemoryContextSwitchTo(originalContext);
 		return;
 	}
 
@@ -1347,6 +1358,7 @@ MarkPendingRunsAsFailed(void)
 	SPI_finish();
 	PopActiveSnapshot();
 	CommitTransactionCommand();
+	MemoryContextSwitchTo(originalContext);
 	pgstat_report_activity(STATE_IDLE, NULL);
 }
 

COMMIT_HASH:46c2bbc8e11f4e21251b9f78d02f37555e08aa4e|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2021-02-16 11:18:01 +0100|TITLE:Merge pull request #120 from bdrouvotAWS/new_api|MESSAGE:add alter_job() and update schedule() with more options
COMMIT_HASH:e916f359878d9c8fd50eecc8d3868e0366094f11|AUTHOR_NAME:Bjørnar Ness|AUTHOR_EMAIL:bjornar.ness@gmail.com|DATE:2021-02-04 15:55:23 +0100|TITLE:Make it possible to specify custom PG_CONFIG path (#124)|MESSAGE:
diff --git a/Makefile b/Makefile
index 13c02b6..cad2b84 100644
--- a/Makefile
+++ b/Makefile
@@ -18,7 +18,7 @@ endif
 SHLIB_LINK = $(libpq)
 EXTRA_CLEAN += $(addprefix src/,*.gcno *.gcda) # clean up after profiling runs
 
-PG_CONFIG = pg_config
+PG_CONFIG ?= pg_config
 PGXS := $(shell $(PG_CONFIG) --pgxs)
 include $(PGXS)
 

COMMIT_HASH:3b8f2ed21ad2cec72d69ca2d9a5b66dc8d89037e|AUTHOR_NAME:bdrouvotAWS|AUTHOR_EMAIL:bdrouvot@amazon.com|DATE:2021-01-08 09:17:30 +0000|TITLE:add alter_job() and update schedule() with more options|MESSAGE:
diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index 9f8f3cc..7f90789 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -5,11 +5,11 @@ SELECT extversion FROM pg_extension WHERE extname='pg_cron';
  1.0
 (1 row)
 
-ALTER EXTENSION pg_cron UPDATE TO '1.3';
+ALTER EXTENSION pg_cron UPDATE TO '1.4';
 SELECT extversion FROM pg_extension WHERE extname='pg_cron';
  extversion 
 ------------
- 1.3
+ 1.4
 (1 row)
 
 -- Vacuum every day at 10:00am (GMT)
@@ -93,4 +93,102 @@ SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
      2 |         | @restart | ALTER EXTENSION pg_cron UPDATE
 (1 row)
 
+-- Testing version >= 1.4 new APIs
+-- First as superuser
+-- Update a job without one job attribute to change
+SELECT cron.alter_job(2);
+ERROR:  no updates specified
+HINT:  You must specify at least one job attribute to change when calling alter_job
+-- Update to a non existing database
+select cron.alter_job(job_id:=2,database:='hopedoesnotexist');
+ERROR:  database "hopedoesnotexist" does not exist
+-- Create a database that does not allow connection
+create database pgcron_dbno;
+revoke connect on database pgcron_dbno from public;
+-- create a test user
+create user pgcron_cront with password 'pwd';
+GRANT USAGE ON SCHEMA cron TO pgcron_cront;
+-- Schedule a job for this user on the database that does not accept connections
+SELECT cron.schedule(job_name:='can not connect', schedule:='0 11 * * *', command:='VACUUM',database:='pgcron_dbno',username:='pgcron_cront');
+ERROR:  User pgcron_cront does not have CONNECT privilege on pgcron_dbno
+-- Create a database that does allow connections
+create database pgcron_dbyes;
+-- Schedule a job on the database that does accept connections for a non existing user
+SELECT cron.schedule(job_name:='user does not exist', schedule:='0 11 * * *', command:='VACUUM',database:='pgcron_dbyes',username:='pgcron_useraqwxszedc');
+ERROR:  role "pgcron_useraqwxszedc" does not exist
+-- Alter an existing job on a database that does not accept connections
+SELECT cron.alter_job(job_id:=2,database:='pgcron_dbno',username:='pgcron_cront');
+ERROR:  User pgcron_cront does not have CONNECT privilege on pgcron_dbno
+-- Second as non superuser
+SET SESSION AUTHORIZATION pgcron_cront;
+-- Create a job
+SELECT cron.schedule('My vacuum', '0 11 * * *', 'VACUUM');
+ schedule 
+----------
+        6
+(1 row)
+
+-- Create a job for another user
+SELECT cron.schedule(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',username:='anotheruser');
+ERROR:  must be superuser to create a job for another role
+-- Change the username of an existing job that the user own
+select cron.alter_job(job_id:=6,username:='anotheruser');
+ERROR:  must be superuser to alter username
+-- Update a job that the user does not own
+select cron.alter_job(job_id:=2,database:='pgcron_dbyes');
+ERROR:  Job 2 does not exist or you don't own it
+-- change the database for a job that the user own and can connect to
+select cron.alter_job(job_id:=6,database:='pgcron_dbyes');
+ alter_job 
+-----------
+ 
+(1 row)
+
+SELECT database FROM cron.job;
+   database   
+--------------
+ pgcron_dbyes
+(1 row)
+
+-- change the database for a job that the user own but can not connect to
+select cron.alter_job(job_id:=6,database:='pgcron_dbno');
+ERROR:  User pgcron_cront does not have CONNECT privilege on pgcron_dbno
+SELECT database FROM cron.job;
+   database   
+--------------
+ pgcron_dbyes
+(1 row)
+
+-- back to superuser
+RESET SESSION AUTHORIZATION;
+-- Change the username of an existing job
+select cron.alter_job(job_id:=2,username:='pgcron_cront');
+ alter_job 
+-----------
+ 
+(1 row)
+
+SELECT username FROM cron.job where jobid=2;
+   username   
+--------------
+ pgcron_cront
+(1 row)
+
+-- Create a job for another user
+SELECT cron.schedule(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',username:='pgcron_cront');
+ schedule 
+----------
+        7
+(1 row)
+
+SELECT username FROM cron.job where jobid=7;
+   username   
+--------------
+ pgcron_cront
+(1 row)
+
+-- cleaning
 DROP EXTENSION pg_cron;
+drop user pgcron_cront;
+drop database pgcron_dbno;
+drop database pgcron_dbyes;
diff --git a/pg_cron--1.3--1.4.sql b/pg_cron--1.3--1.4.sql
new file mode 100644
index 0000000..266e7f0
--- /dev/null
+++ b/pg_cron--1.3--1.4.sql
@@ -0,0 +1,27 @@
+/* pg_cron--1.3--1.4.sql */
+
+CREATE FUNCTION cron.alter_job(job_id bigint,
+								schedule text default null,
+								command text default null,
+								database text default null,
+								username text default null,
+								active boolean default null)
+RETURNS void
+LANGUAGE C
+AS 'MODULE_PATHNAME', $$cron_alter_job$$;
+
+COMMENT ON FUNCTION cron.alter_job(bigint,text,text,text,text,boolean)
+IS 'Alter the job identified by job_id. Any option left as NULL will not be modified.';
+
+CREATE FUNCTION cron.schedule(job_name text,
+								schedule text,
+								command text,
+								database text default null,
+								username text default null,
+								active boolean default 'true')
+RETURNS bigint
+LANGUAGE C
+AS 'MODULE_PATHNAME', $$cron_schedule_named$$;
+
+COMMENT ON FUNCTION cron.schedule(text,text,text,text,text,boolean)
+IS 'schedule a pg_cron job';
diff --git a/pg_cron.control b/pg_cron.control
index 5f63843..c245791 100644
--- a/pg_cron.control
+++ b/pg_cron.control
@@ -1,4 +1,4 @@
 comment = 'Job scheduler for PostgreSQL'
-default_version = '1.3'
+default_version = '1.4'
 module_pathname = '$libdir/pg_cron'
 relocatable = false
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index 345a101..ca2938c 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -1,6 +1,6 @@
 CREATE EXTENSION pg_cron VERSION '1.0';
 SELECT extversion FROM pg_extension WHERE extname='pg_cron';
-ALTER EXTENSION pg_cron UPDATE TO '1.3';
+ALTER EXTENSION pg_cron UPDATE TO '1.4';
 SELECT extversion FROM pg_extension WHERE extname='pg_cron';
 
 -- Vacuum every day at 10:00am (GMT)
@@ -37,4 +37,71 @@ SELECT cron.unschedule('myvacuum');
 
 SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
 
+-- Testing version >= 1.4 new APIs
+-- First as superuser
+
+-- Update a job without one job attribute to change
+SELECT cron.alter_job(2);
+
+-- Update to a non existing database
+select cron.alter_job(job_id:=2,database:='hopedoesnotexist');
+
+-- Create a database that does not allow connection
+create database pgcron_dbno;
+revoke connect on database pgcron_dbno from public;
+
+-- create a test user
+create user pgcron_cront with password 'pwd';
+GRANT USAGE ON SCHEMA cron TO pgcron_cront;
+
+-- Schedule a job for this user on the database that does not accept connections
+SELECT cron.schedule(job_name:='can not connect', schedule:='0 11 * * *', command:='VACUUM',database:='pgcron_dbno',username:='pgcron_cront');
+
+-- Create a database that does allow connections
+create database pgcron_dbyes;
+
+-- Schedule a job on the database that does accept connections for a non existing user
+SELECT cron.schedule(job_name:='user does not exist', schedule:='0 11 * * *', command:='VACUUM',database:='pgcron_dbyes',username:='pgcron_useraqwxszedc');
+
+-- Alter an existing job on a database that does not accept connections
+SELECT cron.alter_job(job_id:=2,database:='pgcron_dbno',username:='pgcron_cront');
+
+-- Second as non superuser
+SET SESSION AUTHORIZATION pgcron_cront;
+
+-- Create a job
+SELECT cron.schedule('My vacuum', '0 11 * * *', 'VACUUM');
+
+-- Create a job for another user
+SELECT cron.schedule(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',username:='anotheruser');
+
+-- Change the username of an existing job that the user own
+select cron.alter_job(job_id:=6,username:='anotheruser');
+
+-- Update a job that the user does not own
+select cron.alter_job(job_id:=2,database:='pgcron_dbyes');
+
+-- change the database for a job that the user own and can connect to
+select cron.alter_job(job_id:=6,database:='pgcron_dbyes');
+SELECT database FROM cron.job;
+
+-- change the database for a job that the user own but can not connect to
+select cron.alter_job(job_id:=6,database:='pgcron_dbno');
+SELECT database FROM cron.job;
+
+-- back to superuser
+RESET SESSION AUTHORIZATION;
+
+-- Change the username of an existing job
+select cron.alter_job(job_id:=2,username:='pgcron_cront');
+SELECT username FROM cron.job where jobid=2;
+
+-- Create a job for another user
+SELECT cron.schedule(job_name:='his vacuum', schedule:='0 11 * * *', command:='VACUUM',username:='pgcron_cront');
+SELECT username FROM cron.job where jobid=7;
+
+-- cleaning
 DROP EXTENSION pg_cron;
+drop user pgcron_cront;
+drop database pgcron_dbno;
+drop database pgcron_dbyes;
diff --git a/src/job_metadata.c b/src/job_metadata.c
index e523d30..2e1b1f8 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -50,6 +50,8 @@
 
 #include "executor/spi.h"
 #include "catalog/pg_type.h"
+#include "commands/dbcommands.h"
+#include "catalog/pg_authid.h"
 
 #if (PG_VERSION_NUM < 120000)
 #define table_open(r, l) heap_open(r, l)
@@ -68,7 +70,9 @@
 /* forward declarations */
 static HTAB * CreateCronJobHash(void);
 
-static int64 ScheduleCronJob(Name jobName, char *schedule, char *command);
+static int64 ScheduleCronJob(text *scheduleText, text *commandText,
+								text *databaseText, text *usernameText,
+								bool active, text *jobnameText);
 static Oid CronExtensionOwner(void);
 static void EnsureDeletePermission(Relation cronJobsTable, HeapTuple heapTuple);
 static void InvalidateJobCacheCallback(Datum argument, Oid relationId);
@@ -78,7 +82,12 @@ static Oid CronJobRelationId(void);
 static CronJob * TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple);
 static bool PgCronHasBeenLoaded(void);
 static bool JobRunDetailsTableExists(void);
+static bool JobTableExists(void);
 
+static void AlterJob(int64 jobId, text *scheduleText, text *commandText,
+						text *databaseText, text *usernameText, bool *active);
+
+static Oid GetRoleOidIfCanLogin(char *username);
 
 /* SQL-callable functions */
 PG_FUNCTION_INFO_V1(cron_schedule);
@@ -86,6 +95,7 @@ PG_FUNCTION_INFO_V1(cron_schedule_named);
 PG_FUNCTION_INFO_V1(cron_unschedule);
 PG_FUNCTION_INFO_V1(cron_unschedule_named);
 PG_FUNCTION_INFO_V1(cron_job_cache_invalidate);
+PG_FUNCTION_INFO_V1(cron_alter_job);
 
 
 /* global variables */
@@ -167,59 +177,28 @@ GetCronJob(int64 jobId)
 	return job;
 }
 
-
-/*
- * cron_schedule schedules an unnamed cron job.
- */
-Datum
-cron_schedule(PG_FUNCTION_ARGS)
-{
-	text *scheduleText = PG_GETARG_TEXT_P(0);
-	text *commandText = PG_GETARG_TEXT_P(1);
-
-	Name jobName = NULL;
-	char *schedule = text_to_cstring(scheduleText);
-	char *command = text_to_cstring(commandText);
-
-	int64 jobId = ScheduleCronJob(jobName, schedule, command);
-
-	PG_RETURN_INT64(jobId);
-}
-
-
-/*
- * cron_schedule_named schedules a named cron job
- */
-Datum
-cron_schedule_named(PG_FUNCTION_ARGS)
-{
-	Name jobName = PG_GETARG_NAME(0);
-	text *scheduleText = PG_GETARG_TEXT_P(1);
-	text *commandText = PG_GETARG_TEXT_P(2);
-
-	char *schedule = text_to_cstring(scheduleText);
-	char *command = text_to_cstring(commandText);
-
-	int64 jobId = ScheduleCronJob(jobName, schedule, command);
-
-	PG_RETURN_INT64(jobId);
-}
-
-
 /*
  * ScheduleCronJob schedules a cron job with the given name.
  */
 static int64
-ScheduleCronJob(Name jobName, char *schedule, char *command)
+ScheduleCronJob(text *scheduleText, text *commandText, text *databaseText,
+					text *usernameText, bool active, text *jobnameText)
 {
 	entry *parsedSchedule = NULL;
+	char *schedule;
+	char *command;
+	char *database_name;
+	char *jobName;
+	char *username;
+	AclResult aclresult;
+	Oid userIdcheckacl;
 
 	int64 jobId = 0;
 	Datum jobIdDatum = 0;
 
 	StringInfoData querybuf;
-	Oid argTypes[7];
-	Datum argValues[7];
+	Oid argTypes[8];
+	Datum argValues[8];
 	int argCount = 0;
 
 	Oid savedUserId = InvalidOid;
@@ -230,9 +209,13 @@ ScheduleCronJob(Name jobName, char *schedule, char *command)
 	bool returnedJobIdIsNull = false;
 
 	Oid userId = GetUserId();
-	char *userName = GetUserNameFromId(userId, false);
+	userIdcheckacl = GetUserId();
+	username = GetUserNameFromId(userId, false);
 
+	/* check schedule is valid */
+	schedule = text_to_cstring(scheduleText);
 	parsedSchedule = parse_cron_entry(schedule);
+
 	if (parsedSchedule == NULL)
 	{
 		ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
@@ -244,19 +227,19 @@ ScheduleCronJob(Name jobName, char *schedule, char *command)
 	initStringInfo(&querybuf);
 
 	appendStringInfo(&querybuf,
-		"insert into %s (schedule, command, nodename, nodeport, database, username",
+		"insert into %s (schedule, command, nodename, nodeport, database, username, active",
 		quote_qualified_identifier(CRON_SCHEMA_NAME, JOBS_TABLE_NAME));
 
-	if (jobName != NULL)
+	if (jobnameText != NULL)
 	{
 		appendStringInfo(&querybuf, ", jobname");
 	}
 
-	appendStringInfo(&querybuf, ") values ($1, $2, $3, $4, $5, $6");
+	appendStringInfo(&querybuf, ") values ($1, $2, $3, $4, $5, $6, $7");
 
-	if (jobName != NULL)
+	if (jobnameText != NULL)
 	{
-		appendStringInfo(&querybuf, ", $7) ");
+		appendStringInfo(&querybuf, ", $8) ");
 		appendStringInfo(&querybuf, "on conflict on constraint jobname_username_uniq ");
 		appendStringInfo(&querybuf, "do update set ");
 		appendStringInfo(&querybuf, "schedule = EXCLUDED.schedule, ");
@@ -274,6 +257,7 @@ ScheduleCronJob(Name jobName, char *schedule, char *command)
 	argCount++;
 
 	argTypes[1] = TEXTOID;
+	command = text_to_cstring(commandText);
 	argValues[1] = CStringGetTextDatum(command);
 	argCount++;
 
@@ -285,18 +269,48 @@ ScheduleCronJob(Name jobName, char *schedule, char *command)
 	argValues[3] = Int32GetDatum(PostPortNumber);
 	argCount++;
 
+	/* username has been provided */
+	if (usernameText != NULL)
+	{
+		if (!superuser())
+			elog(ERROR, "must be superuser to create a job for another role");
+
+		username = text_to_cstring(usernameText);
+		userIdcheckacl = GetRoleOidIfCanLogin(username);
+	}
+
+	/* database has been provided */
+	if (databaseText != NULL)
+		database_name = text_to_cstring(databaseText);
+	else
+	/* use the GUC */
+		database_name = CronTableDatabaseName;
+
+	/* ensure the user that is used in the job can connect to the database */
+	aclresult = pg_database_aclcheck(get_database_oid(database_name, false),
+										userIdcheckacl, ACL_CONNECT);
+
+	if (aclresult != ACLCHECK_OK)
+		elog(ERROR, "User %s does not have CONNECT privilege on %s",
+				GetUserNameFromId(userIdcheckacl, false), database_name);
+
 	argTypes[4] = TEXTOID;
-	argValues[4] = CStringGetTextDatum(CronTableDatabaseName);
+	argValues[4] = CStringGetTextDatum(database_name);
 	argCount++;
 
 	argTypes[5] = TEXTOID;
-	argValues[5] = CStringGetTextDatum(userName);
+	argValues[5] = CStringGetTextDatum(username);
+	argCount++;
+
+	argTypes[6] = BOOLOID;
+	argValues[6] = BoolGetDatum(active);
 	argCount++;
 
-	if (jobName != NULL)
+	if (jobnameText != NULL)
 	{
-		argTypes[6] = NAMEOID;
-		argValues[6] = NameGetDatum(jobName);
+		argTypes[7] = TEXTOID;
+		jobName = text_to_cstring(jobnameText);
+		argValues[7] = CStringGetTextDatum(jobName);
 		argCount++;
 	}
 
@@ -338,7 +352,143 @@ ScheduleCronJob(Name jobName, char *schedule, char *command)
 	return jobId;
 }
 
+/*
+ * GetRoleOidIfCanLogin
+ * Checks user exist and can log in
+ */
+static Oid
+GetRoleOidIfCanLogin(char *username)
+{
+	HeapTuple   roletup;
+	Form_pg_authid rform;
+
+	roletup = SearchSysCache1(AUTHNAME, PointerGetDatum(username));
+	if (!HeapTupleIsValid(roletup))
+		ereport(ERROR,
+				(errmsg("role \"%s\" does not exist",
+						username)));
+
+	rform = (Form_pg_authid) GETSTRUCT(roletup);
+
+	if (!rform->rolcanlogin)
+		ereport(ERROR,
+				(errmsg("role \"%s\" can not log in",
+						username),
+				 errdetail("Jobs may only be run by roles that have the LOGIN attribute.")));
+
+	ReleaseSysCache(roletup);
+	return rform->oid;
+}
 
+/*
+ * cron_alter_job alter a job
+ */
+Datum
+cron_alter_job(PG_FUNCTION_ARGS)
+{
+	int64 jobId;
+	text *scheduleText = NULL;
+	text *commandText = NULL;
+	text *databaseText = NULL;
+	text *usernameText = NULL;
+	bool active;
+
+	if (PG_ARGISNULL(0))
+		ereport(ERROR, (errmsg("job_id can not be NULL")));
+	else
+		jobId = PG_GETARG_INT64(0);
+
+	if (!PG_ARGISNULL(1))
+		scheduleText = PG_GETARG_TEXT_P(1);
+
+	if (!PG_ARGISNULL(2))
+		commandText = PG_GETARG_TEXT_P(2);
+
+	if (!PG_ARGISNULL(3))
+		databaseText = PG_GETARG_TEXT_P(3);
+
+	if (!PG_ARGISNULL(4))
+		usernameText = PG_GETARG_TEXT_P(4);
+
+	if (!PG_ARGISNULL(5))
+		active = PG_GETARG_BOOL(5);
+
+	AlterJob(jobId, scheduleText, commandText, databaseText, usernameText,
+				PG_ARGISNULL(5) ? NULL : &active);
+
+	PG_RETURN_VOID();
+}
+
+
+/*
+ * cron_schedule schedule a job
+ */
+Datum
+cron_schedule(PG_FUNCTION_ARGS)
+{
+	text *scheduleText = NULL;
+	text *commandText = NULL;
+	int64 jobId;
+
+	if (PG_ARGISNULL(0))
+		ereport(ERROR, (errmsg("schedule can not be NULL")));
+	else
+		scheduleText = PG_GETARG_TEXT_P(0);
+
+	if (PG_ARGISNULL(1))
+		ereport(ERROR, (errmsg("command can not be NULL")));
+	else
+		commandText = PG_GETARG_TEXT_P(1);
+
+	jobId = ScheduleCronJob(scheduleText, commandText, NULL,
+							NULL, true, NULL);
+
+	PG_RETURN_INT64(jobId);
+}
+
+/*
+ * cron_schedule schedule a named job
+ */
+Datum
+cron_schedule_named(PG_FUNCTION_ARGS)
+{
+	text *scheduleText = NULL;
+	text *commandText = NULL;
+	text *databaseText = NULL;
+	text *usernameText = NULL;
+	bool active = true;
+	text *jobnameText = NULL;
+	int64 jobId;
+
+	if (PG_ARGISNULL(0))
+		ereport(ERROR, (errmsg("job_name can not be NULL")));
+	else
+		jobnameText = PG_GETARG_TEXT_P(0);
+
+	if (PG_ARGISNULL(1))
+		ereport(ERROR, (errmsg("schedule can not be NULL")));
+	else
+		scheduleText = PG_GETARG_TEXT_P(1);
+
+	if (PG_ARGISNULL(2))
+		ereport(ERROR, (errmsg("command can not be NULL")));
+	else
+		commandText = PG_GETARG_TEXT_P(2);
+
+	if (!PG_ARGISNULL(3))
+		databaseText = PG_GETARG_TEXT_P(3);
+
+	if (!PG_ARGISNULL(4))
+		usernameText = PG_GETARG_TEXT_P(4);
+
+	if (!PG_ARGISNULL(5))
+		active = PG_GETARG_BOOL(5);
+
+	jobId = ScheduleCronJob(scheduleText, commandText, databaseText,
+							usernameText, active, jobnameText);
+
+	PG_RETURN_INT64(jobId);
+}
 /*
  * NextRunId draws a new run ID from cron.runid_seq.
  */
@@ -1004,6 +1154,161 @@ UpdateJobRunDetail(int64 runId, int32 *job_pid, char *status, char *return_messa
 	pgstat_report_activity(STATE_IDLE, NULL);
 }
 
+
+static void
+AlterJob(int64 jobId, text *scheduleText, text *commandText, text *databaseText, text *usernameText, bool *active)
+{
+	StringInfoData querybuf;
+	Oid argTypes[7];
+	Datum argValues[7];
+	int i;
+	AclResult aclresult;
+	Oid userId;
+	Oid userIdcheckacl;
+	Oid savedUserId;
+	int savedSecurityContext;
+	char *database_name;
+	char *schedule;
+	char *command;
+	char *username;
+	char *currentuser;
+	entry *parsedSchedule = NULL;
+
+	userId = GetUserId();
+	userIdcheckacl = GetUserId();
+
+	currentuser = GetUserNameFromId(userId, false);
+	savedUserId = InvalidOid;
+	savedSecurityContext = 0;
+
+	if (!PgCronHasBeenLoaded() || RecoveryInProgress() || !JobTableExists())
+	{
+		return;
+	}
+
+	initStringInfo(&querybuf);
+	i = 0;
+
+	appendStringInfo(&querybuf,
+		"update %s.%s set", CRON_SCHEMA_NAME, JOBS_TABLE_NAME);
+
+	/* username has been provided */
+	if (usernameText != NULL)
+	{
+		if (!superuser())
+			elog(ERROR, "must be superuser to alter username");
+
+		username = text_to_cstring(usernameText);
+		userIdcheckacl = GetRoleOidIfCanLogin(username);
+	}
+	else
+		username = currentuser;
+
+	/* add the fields to be updated */
+	/* database has been provided */
+	if (databaseText != NULL)
+	{
+		database_name = text_to_cstring(databaseText);
+		/* ensure the user that is used in the job can connect to the database */
+		aclresult = pg_database_aclcheck(get_database_oid(database_name, false), userIdcheckacl, ACL_CONNECT);
+
+		if (aclresult != ACLCHECK_OK)
+			elog(ERROR, "User %s does not have CONNECT privilege on %s", GetUserNameFromId(userIdcheckacl, false), database_name);
+
+		argTypes[i] = TEXTOID;
+		argValues[i] = CStringGetTextDatum(database_name);
+		i++;
+		appendStringInfo(&querybuf, " database = $%d,", i);
+	}
+
+	/* ensure schedule is valid */
+	if (scheduleText != NULL)
+	{
+		schedule = text_to_cstring(scheduleText);
+		parsedSchedule = parse_cron_entry(schedule);
+
+		if (parsedSchedule == NULL)
+		{
+			ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+					errmsg("invalid schedule: %s", schedule)));
+		}
+
+		free_entry(parsedSchedule);
+
+		argTypes[i] = TEXTOID;
+		argValues[i] = CStringGetTextDatum(schedule);
+		i++;
+		appendStringInfo(&querybuf, " schedule = $%d,", i);
+	}
+
+	if (commandText != NULL)
+	{
+		argTypes[i] = TEXTOID;
+		command = text_to_cstring(commandText);
+		argValues[i] = CStringGetTextDatum(command);
+		i++;
+		appendStringInfo(&querybuf, " command = $%d,", i);
+	}
+
+	if (usernameText != NULL)
+	{
+		argTypes[i] = TEXTOID;
+		argValues[i] = CStringGetTextDatum(username);
+		i++;
+		appendStringInfo(&querybuf, " username = $%d,", i);
+	}
+
+	if (active != NULL)
+	{
+		argTypes[i] = BOOLOID;
+		argValues[i] = BoolGetDatum(*active);
+		i++;
+		appendStringInfo(&querybuf, " active = $%d,", i);
+	}
+
+	/* remove the last comma */
+	querybuf.len--;
+	querybuf.data[querybuf.len] = '\0';
+
+	/* and add the where clause */
+	argTypes[i] = INT8OID;
+	argValues[i] = Int64GetDatum(jobId);
+	i++;
+
+	appendStringInfo(&querybuf, " where jobid = $%d", i);
+
+	/* ensure the caller owns the row */
+	argTypes[i] = TEXTOID;
+	argValues[i] = CStringGetTextDatum(currentuser);
+	i++;
+
+	if (!superuser())
+		appendStringInfo(&querybuf, " and username = $%d", i);
+
+	if (i <= 2)
+		ereport(ERROR, (errmsg("no updates specified"),
+						errhint("You must specify at least one job attribute to change when calling alter_job")));
+
+	GetUserIdAndSecContext(&savedUserId, &savedSecurityContext);
+	SetUserIdAndSecContext(CronExtensionOwner(), SECURITY_LOCAL_USERID_CHANGE);
+
+	/* Open SPI context. */
+	if (SPI_connect() != SPI_OK_CONNECT)
+		elog(ERROR, "SPI_connect failed");
+	if(SPI_execute_with_args(querybuf.data,
+		i, argTypes, argValues, NULL, false, 1) != SPI_OK_UPDATE)
+		elog(ERROR, "SPI_exec failed: %s", querybuf.data);
+
+	pfree(querybuf.data);
+
+	if (SPI_processed <= 0)
+		elog(ERROR, "Job %ld does not exist or you don't own it", jobId);
+
+	SPI_finish();
+	SetUserIdAndSecContext(savedUserId, savedSecurityContext);
+	InvalidateJobCache();
+}
+
 void
 MarkPendingRunsAsFailed(void)
 {
@@ -1089,3 +1394,16 @@ JobRunDetailsTableExists(void)
 
 	return jobRunDetailsTableOid != InvalidOid;
 }
+
+/*
+ * JobTableExists returns whether the job table exists.
+ */
+static bool
+JobTableExists(void)
+{
+	Oid cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
+	Oid jobTableOid = get_relname_relid(JOBS_TABLE_NAME,
+												cronSchemaId);
+
+	return jobTableOid != InvalidOid;
+}

COMMIT_HASH:f5ab1b8f222fea2b2b450ac6b559c9e01a2a989e|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2021-01-23 10:24:35 +0100|TITLE:Merge pull request #122 from bossartn/patch-1|MESSAGE:Mark "Amazon RDS" as supporting pg_cron.
COMMIT_HASH:e8c5c3c1af454bc97ca8fc11dfa0bc1bd32d5669|AUTHOR_NAME:Nathan Bossart|AUTHOR_EMAIL:bossartn@amazon.com|DATE:2021-01-12 14:05:33 -0800|TITLE:Mark "Amazon RDS" as supporting pg_cron.|MESSAGE:https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL_pg_cron.html
diff --git a/README.md b/README.md
index 70227a3..bfc215d 100644
--- a/README.md
+++ b/README.md
@@ -127,7 +127,7 @@ The following table keeps track of which of the major managed Postgres services
 | Service       | Supported     |
 | ------------- |:-------------:|
 | [Alibaba Cloud](https://www.alibabacloud.com/help/doc-detail/150355.htm) | :heavy_check_mark: |
-| [Amazon RDS](https://aws.amazon.com/rds/postgresql/)     | :x:      |          |
+| [Amazon RDS](https://aws.amazon.com/rds/postgresql/)     | :heavy_check_mark:      |          |
 | [Azure](https://azure.microsoft.com/en-us/services/postgresql/) | :heavy_check_mark:  |
 | [Citus Cloud](https://www.citusdata.com/product/cloud)  | :heavy_check_mark: |
 | [Crunchy Bridge](https://www.crunchydata.com/products/crunchy-bridge/?ref=producthunt) | :heavy_check_mark: |

COMMIT_HASH:f5d5d2f03bca2e03863c51fce59a448a42aa7492|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2021-01-05 17:38:45 +0100|TITLE:Merge pull request #119 from bookvik/main|MESSAGE:Update pg_cron.c
COMMIT_HASH:982d5a9dd23a0776ebee4a59bc655f455e20b5eb|AUTHOR_NAME:Vitaliy Katorgin|AUTHOR_EMAIL:vitalykatorgin@gmail.com|DATE:2020-12-16 16:19:31 +0300|TITLE:Update pg_cron.c|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index e0ca973..460b22d 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -36,9 +36,14 @@
 #include "task_states.h"
 #include "job_metadata.h"
 
-#include "poll.h"
+
+#ifdef HAVE_POLL_H
+#include <poll.h>
+#elif defined(HAVE_SYS_POLL_H)
+#include <sys/poll.h>
+#endif
+
 #include "sys/time.h"
-#include "sys/poll.h"
 #include "time.h"
 
 #include "access/genam.h"

COMMIT_HASH:3da3f1f844e250912c4d7058ffb69235b5c91f4e|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2020-12-10 22:17:28 +0100|TITLE:Merge pull request #118 from timgates42/bugfix_typo_implemented|MESSAGE:docs: fix simple typo, implmented -> implemented
COMMIT_HASH:9430c0c16bbf6b65391638760c0d052834812472|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2020-12-10 22:17:11 +0100|TITLE:Merge pull request #117 from cdock1029/main|MESSAGE:add Supabase.io to managed services
COMMIT_HASH:3e44ce769eeef5483247bf1b1c26bc98709ac548|AUTHOR_NAME:Tim Gates|AUTHOR_EMAIL:tim.gates@iress.com|DATE:2020-12-10 22:14:43 +1100|TITLE:docs: fix simple typo, implmented -> implemented|MESSAGE:There is a small typo in src/entry.c.

Should read `implemented` rather than `implmented`.

diff --git a/src/entry.c b/src/entry.c
index 79dc9df..717a2c9 100644
--- a/src/entry.c
+++ b/src/entry.c
@@ -381,7 +381,7 @@ get_range(bits, low, high, names, ch, file)
 	/* range. set all elements from num1 to num2, stepping
 	 * by num3.  (the step is a downward-compatible extension
 	 * proposed conceptually by bob@acornrc, syntactically
-	 * designed then implmented by paul vixie).
+	 * designed then implemented by paul vixie).
 	 */
 	for (i = num1;  i <= num2;  i += num3)
 		if (EOF == set_element(bits, low, high, i))

COMMIT_HASH:da27c7bd577604587be41e3a6b47d8a8d2a732b6|AUTHOR_NAME:Conor Dockry|AUTHOR_EMAIL:conordockry@gmail.com|DATE:2020-12-09 17:45:54 -0500|TITLE:add Supabase.io to managed services|MESSAGE:
diff --git a/README.md b/README.md
index e0e896c..70227a3 100644
--- a/README.md
+++ b/README.md
@@ -134,3 +134,4 @@ The following table keeps track of which of the major managed Postgres services
 | [DigitalOcean](https://www.digitalocean.com/products/managed-databases/) | :heavy_check_mark: |
 | [Google Cloud](https://cloud.google.com/sql/docs/postgres/) | :x:      |
 | [Heroku](https://elements.heroku.com/addons/heroku-postgresql) | :x: | |
+| [Supabase](https://supabase.io/docs/guides/database) | :heavy_check_mark:  |

COMMIT_HASH:4fdb4676781c56ea837058d336287f41909e56c6|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2020-10-29 16:31:09 +0100|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index fba8326..e0e896c 100644
--- a/README.md
+++ b/README.md
@@ -60,12 +60,9 @@ The code in pg_cron that handles parsing and scheduling comes directly from the
 
 ## Installing pg_cron
 
-Install on Red Hat, CentOS, Fedora, Amazon Linux with PostgreSQL 12:
+Install on Red Hat, CentOS, Fedora, Amazon Linux with PostgreSQL 12 using [PGDG](https://yum.postgresql.org/repopackages/):
 
 ```bash
-# Add Citus Data package repository
-curl https://install.citusdata.com/community/rpm.sh | sudo bash
-
 # Install the pg_cron extension
 sudo yum install -y pg_cron_12
 ```

COMMIT_HASH:87202c353544b12779a4264dfe68e5b6991845b9|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2020-10-26 21:22:27 +0100|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index b41c45c..fba8326 100644
--- a/README.md
+++ b/README.md
@@ -60,21 +60,21 @@ The code in pg_cron that handles parsing and scheduling comes directly from the
 
 ## Installing pg_cron
 
-Install on Red Hat, CentOS, Fedora, Amazon Linux with PostgreSQL 11:
+Install on Red Hat, CentOS, Fedora, Amazon Linux with PostgreSQL 12:
 
 ```bash
 # Add Citus Data package repository
 curl https://install.citusdata.com/community/rpm.sh | sudo bash
 
 # Install the pg_cron extension
-sudo yum install -y pg_cron_11
+sudo yum install -y pg_cron_12
 ```
 
-Install on Debian, Ubuntu with PostgreSQL 11 using [apt.postgresql.org](https://wiki.postgresql.org/wiki/Apt):
+Install on Debian, Ubuntu with PostgreSQL 12 using [apt.postgresql.org](https://wiki.postgresql.org/wiki/Apt):
 
 ```bash
 # Install the pg_cron extension
-sudo apt-get -y install postgresql-11-cron
+sudo apt-get -y install postgresql-12-cron
 ```
 
 You can also install pg_cron by building it from source:
@@ -83,7 +83,7 @@ You can also install pg_cron by building it from source:
 git clone https://github.com/citusdata/pg_cron.git
 cd pg_cron
 # Ensure pg_config is in your path, e.g.
-export PATH=/usr/pgsql-11/bin:$PATH
+export PATH=/usr/pgsql-12/bin:$PATH
 make && sudo PATH=$PATH make install
 ```
 

COMMIT_HASH:12de7b64a56ea607386b6777ccaf3e41e0e82bf6|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2020-10-06 22:14:41 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 86bd1f3..b41c45c 100644
--- a/README.md
+++ b/README.md
@@ -14,13 +14,25 @@ SELECT cron.schedule('30 3 * * 6', $$DELETE FROM events WHERE event_time < now()
        42
 
 -- Vacuum every day at 10:00am (GMT)
-SELECT cron.schedule('0 10 * * *', 'VACUUM');
+SELECT cron.schedule('nightly-vacuum', '0 10 * * *', 'VACUUM');
  schedule
 ----------
        43
 
--- Stop scheduling a job
-SELECT cron.unschedule(43);
+-- Change to vacuum at 3:00am (GMT)
+SELECT cron.schedule('nightly-vacuum', '0 3 * * *', 'VACUUM');
+ schedule
+----------
+       43
+
+-- Stop scheduling jobs
+SELECT cron.unschedule('nightly-vacuum' );
+ unschedule 
+------------
+ t
+(1 row)
+
+SELECT cron.unschedule(42);
  unschedule
 ------------
           t

COMMIT_HASH:19d570a2584d8cb7e9ec899da662485c8c0caa38|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2020-10-06 21:53:32 +0200|TITLE:Fix SPI argument count issue|MESSAGE:
diff --git a/src/job_metadata.c b/src/job_metadata.c
index a61dfc8..e523d30 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -63,7 +63,6 @@
 #define JOB_ID_SEQUENCE_NAME "cron.jobid_seq"
 #define JOB_RUN_DETAILS_TABLE_NAME "job_run_details"
 #define RUN_ID_SEQUENCE_NAME "cron.runid_seq"
-#define MAX_NUMBER_SPI_EXEC_ARGS 6
 
 
 /* forward declarations */
@@ -219,8 +218,8 @@ ScheduleCronJob(Name jobName, char *schedule, char *command)
 	Datum jobIdDatum = 0;
 
 	StringInfoData querybuf;
-	Oid argTypes[MAX_NUMBER_SPI_EXEC_ARGS];
-	Datum argValues[MAX_NUMBER_SPI_EXEC_ARGS];
+	Oid argTypes[7];
+	Datum argValues[7];
 	int argCount = 0;
 
 	Oid savedUserId = InvalidOid;
@@ -840,8 +839,9 @@ void
 InsertJobRunDetail(int64 runId, int64 *jobId, char *database, char *username, char *command, char *status)
 {
 	StringInfoData querybuf;
-	Oid argTypes[MAX_NUMBER_SPI_EXEC_ARGS];
-	Datum argValues[MAX_NUMBER_SPI_EXEC_ARGS];
+	const int argCount = 6;
+	Oid argTypes[6];
+	Datum argValues[6];
 
 	SetCurrentStatementStartTimestamp();
 	StartTransactionCommand();
@@ -892,7 +892,7 @@ InsertJobRunDetail(int64 runId, int64 *jobId, char *database, char *username, ch
 	pgstat_report_activity(STATE_RUNNING, querybuf.data);
 
 	if(SPI_execute_with_args(querybuf.data,
-		MAX_NUMBER_SPI_EXEC_ARGS, argTypes, argValues, NULL, false, 1) != SPI_OK_INSERT)
+		argCount, argTypes, argValues, NULL, false, 1) != SPI_OK_INSERT)
 		elog(ERROR, "SPI_exec failed: %s", querybuf.data);
 
 	pfree(querybuf.data);
@@ -908,8 +908,8 @@ UpdateJobRunDetail(int64 runId, int32 *job_pid, char *status, char *return_messa
                                                                         TimestampTz *end_time)
 {
 	StringInfoData querybuf;
-	Oid argTypes[MAX_NUMBER_SPI_EXEC_ARGS];
-	Datum argValues[MAX_NUMBER_SPI_EXEC_ARGS];
+	Oid argTypes[6];
+	Datum argValues[6];
 	int i;
 
 	SetCurrentStatementStartTimestamp();

COMMIT_HASH:6ced82d13f6211870a41e8d6369e7369c311a27b|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2020-09-23 15:09:44 +0200|TITLE:Make jobname unique per user|MESSAGE:
diff --git a/pg_cron--1.2--1.3.sql b/pg_cron--1.2--1.3.sql
index d2a4e18..a86e4d1 100644
--- a/pg_cron--1.2--1.3.sql
+++ b/pg_cron--1.2--1.3.sql
@@ -22,7 +22,10 @@ CREATE POLICY cron_job_run_details_policy ON cron.job_run_details USING (usernam
 SELECT pg_catalog.pg_extension_config_dump('cron.job_run_details', '');
 SELECT pg_catalog.pg_extension_config_dump('cron.runid_seq', '');
 
-ALTER TABLE cron.job ADD COLUMN jobname name UNIQUE;
+ALTER TABLE cron.job ADD COLUMN jobname name;
+
+CREATE UNIQUE INDEX jobname_username_idx ON cron.job (jobname, username);
+ALTER TABLE cron.job ADD CONSTRAINT jobname_username_uniq UNIQUE USING INDEX jobname_username_idx;
 
 CREATE FUNCTION cron.schedule(job_name name, schedule text, command text)
     RETURNS bigint
diff --git a/src/job_metadata.c b/src/job_metadata.c
index bbdcd83..a61dfc8 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -257,7 +257,9 @@ ScheduleCronJob(Name jobName, char *schedule, char *command)
 
 	if (jobName != NULL)
 	{
-		appendStringInfo(&querybuf, ", $7) on conflict (jobname) do update set ");
+		appendStringInfo(&querybuf, ", $7) ");
+		appendStringInfo(&querybuf, "on conflict on constraint jobname_username_uniq ");
+		appendStringInfo(&querybuf, "do update set ");
 		appendStringInfo(&querybuf, "schedule = EXCLUDED.schedule, ");
 		appendStringInfo(&querybuf, "command = EXCLUDED.command");
 	}
@@ -491,10 +493,14 @@ cron_unschedule_named(PG_FUNCTION_ARGS)
 	Datum jobNameDatum = PG_GETARG_DATUM(0);
 	Name jobName = DatumGetName(jobNameDatum);
 
+	Oid userId = GetUserId();
+	char *userName = GetUserNameFromId(userId, false);
+	Datum userNameDatum = CStringGetTextDatum(userName);
+
 	Relation cronJobsTable = NULL;
 	SysScanDesc scanDescriptor = NULL;
-	ScanKeyData scanKey[1];
-	int scanKeyCount = 1;
+	ScanKeyData scanKey[2];
+	int scanKeyCount = 2;
 	bool indexOK = false;
 	HeapTuple heapTuple = NULL;
 
@@ -502,6 +508,8 @@ cron_unschedule_named(PG_FUNCTION_ARGS)
 
 	ScanKeyInit(&scanKey[0], Anum_cron_job_jobname,
 				BTEqualStrategyNumber, F_NAMEEQ, jobNameDatum);
+	ScanKeyInit(&scanKey[1], Anum_cron_job_username,
+				BTEqualStrategyNumber, F_TEXTEQ, userNameDatum);
 
 	scanDescriptor = systable_beginscan(cronJobsTable, InvalidOid, indexOK,
 										NULL, scanKeyCount, scanKey);

COMMIT_HASH:e2732cdf3f9bae1d24291146318a99090371300e|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2020-09-23 15:01:31 +0200|TITLE:Grant DELETE on job_run_details to job owners|MESSAGE:
diff --git a/pg_cron--1.2--1.3.sql b/pg_cron--1.2--1.3.sql
index 47970dd..d2a4e18 100644
--- a/pg_cron--1.2--1.3.sql
+++ b/pg_cron--1.2--1.3.sql
@@ -15,6 +15,7 @@ CREATE TABLE cron.job_run_details (
 );
 
 GRANT SELECT ON cron.job_run_details TO public;
+GRANT DELETE ON cron.job_run_details TO public;
 ALTER TABLE cron.job_run_details ENABLE ROW LEVEL SECURITY;
 CREATE POLICY cron_job_run_details_policy ON cron.job_run_details USING (username = current_user);
 

COMMIT_HASH:63b483600c24c27378d1f0f79bf3d9c817f6c749|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2020-09-23 14:51:31 +0200|TITLE:Update CHANGELOG.md|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7695b8a..21839d3 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,13 @@
+### pg_cron v1.3.0 (September 30, 2020) ###
+
+* Background worker support by Bertrand Drouvot
+* Audit table support by Bertrand Drouvot
+* PostgreSQL 13 support by Alexander Kukushkin
+* Schedule jobs by name
+* Fixes a bug that could cause cron.schedule to crash with long schedules
+* Fixes a bug that could cause cron.schedule to get into an infinite loop
+* Fixes a bug that caused overlapping runs not to start
+
 ### pg_cron v1.2.0 (August 30, 2019) ###
 
 * PostgreSQL 12 support by dverite

COMMIT_HASH:8f8784ec35e5e2b3df807eeec7601d8241bcd5f5|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2020-09-23 14:44:22 +0200|TITLE:Merge pull request #82 from citusdata/job_name|MESSAGE:Allow jobs to be scheduled by name
COMMIT_HASH:1ac5c0f45baf1cabafbae7de1f52a030f2ec823a|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2019-08-28 14:48:38 +0200|TITLE:Allow jobs to be scheduled by name|MESSAGE:
diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index f978648..9f8f3cc 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -5,11 +5,11 @@ SELECT extversion FROM pg_extension WHERE extname='pg_cron';
  1.0
 (1 row)
 
-ALTER EXTENSION pg_cron UPDATE TO '1.1';
+ALTER EXTENSION pg_cron UPDATE TO '1.3';
 SELECT extversion FROM pg_extension WHERE extname='pg_cron';
  extversion 
 ------------
- 1.1
+ 1.3
 (1 row)
 
 -- Vacuum every day at 10:00am (GMT)
@@ -38,4 +38,59 @@ SELECT cron.schedule('@restart', 'ALTER EXTENSION pg_cron UPDATE');
         2
 (1 row)
 
+-- Vacuum every day at 10:00am (GMT)
+SELECT cron.schedule('myvacuum', '0 10 * * *', 'VACUUM');
+ schedule 
+----------
+        3
+(1 row)
+
+SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
+ jobid | jobname  |  schedule  |            command             
+-------+----------+------------+--------------------------------
+     2 |          | @restart   | ALTER EXTENSION pg_cron UPDATE
+     3 | myvacuum | 0 10 * * * | VACUUM
+(2 rows)
+
+-- Make that 11:00am (GMT)
+SELECT cron.schedule('myvacuum', '0 11 * * *', 'VACUUM');
+ schedule 
+----------
+        3
+(1 row)
+
+SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
+ jobid | jobname  |  schedule  |            command             
+-------+----------+------------+--------------------------------
+     2 |          | @restart   | ALTER EXTENSION pg_cron UPDATE
+     3 | myvacuum | 0 11 * * * | VACUUM
+(2 rows)
+
+-- Make that VACUUM FULL
+SELECT cron.schedule('myvacuum', '0 11 * * *', 'VACUUM FULL');
+ schedule 
+----------
+        3
+(1 row)
+
+SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
+ jobid | jobname  |  schedule  |            command             
+-------+----------+------------+--------------------------------
+     2 |          | @restart   | ALTER EXTENSION pg_cron UPDATE
+     3 | myvacuum | 0 11 * * * | VACUUM FULL
+(2 rows)
+
+-- Stop scheduling a job
+SELECT cron.unschedule('myvacuum');
+ unschedule 
+------------
+ t
+(1 row)
+
+SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
+ jobid | jobname | schedule |            command             
+-------+---------+----------+--------------------------------
+     2 |         | @restart | ALTER EXTENSION pg_cron UPDATE
+(1 row)
+
 DROP EXTENSION pg_cron;
diff --git a/include/cron_job.h b/include/cron_job.h
index 8eb6b5e..3d1e96e 100644
--- a/include/cron_job.h
+++ b/include/cron_job.h
@@ -27,6 +27,7 @@ typedef struct FormData_cron_job
 	text database;
 	text userName;
 	bool active;
+	Name jobName;
 #endif
 } FormData_cron_job;
 
@@ -41,7 +42,7 @@ typedef FormData_cron_job *Form_cron_job;
  *      compiler constants for cron_job
  * ----------------
  */
-#define Natts_cron_job 8
+#define Natts_cron_job 9
 #define Anum_cron_job_jobid 1
 #define Anum_cron_job_schedule 2
 #define Anum_cron_job_command 3
@@ -50,6 +51,7 @@ typedef FormData_cron_job *Form_cron_job;
 #define Anum_cron_job_database 6
 #define Anum_cron_job_username 7
 #define Anum_cron_job_active 8
+#define Anum_cron_job_jobname 9
 
 typedef struct FormData_job_run_details
 {
diff --git a/include/job_metadata.h b/include/job_metadata.h
index 8287ecc..7870668 100644
--- a/include/job_metadata.h
+++ b/include/job_metadata.h
@@ -39,6 +39,7 @@ typedef struct CronJob
 	char *database;
 	char *userName;
 	bool active;
+	Name jobName;
 } CronJob;
 
 
diff --git a/pg_cron--1.2--1.3.sql b/pg_cron--1.2--1.3.sql
index 611fcb8..47970dd 100644
--- a/pg_cron--1.2--1.3.sql
+++ b/pg_cron--1.2--1.3.sql
@@ -20,3 +20,19 @@ CREATE POLICY cron_job_run_details_policy ON cron.job_run_details USING (usernam
 
 SELECT pg_catalog.pg_extension_config_dump('cron.job_run_details', '');
 SELECT pg_catalog.pg_extension_config_dump('cron.runid_seq', '');
+
+ALTER TABLE cron.job ADD COLUMN jobname name UNIQUE;
+
+CREATE FUNCTION cron.schedule(job_name name, schedule text, command text)
+    RETURNS bigint
+    LANGUAGE C STRICT
+    AS 'MODULE_PATHNAME', $$cron_schedule_named$$;
+COMMENT ON FUNCTION cron.schedule(name,text,text)
+    IS 'schedule a pg_cron job';
+
+CREATE FUNCTION cron.unschedule(job_name name)
+    RETURNS bool
+    LANGUAGE C STRICT
+    AS 'MODULE_PATHNAME', $$cron_unschedule_named$$;
+COMMENT ON FUNCTION cron.unschedule(name)
+    IS 'unschedule a pg_cron job';
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index 5ac3cd1..345a101 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -1,6 +1,6 @@
 CREATE EXTENSION pg_cron VERSION '1.0';
 SELECT extversion FROM pg_extension WHERE extname='pg_cron';
-ALTER EXTENSION pg_cron UPDATE TO '1.1';
+ALTER EXTENSION pg_cron UPDATE TO '1.3';
 SELECT extversion FROM pg_extension WHERE extname='pg_cron';
 
 -- Vacuum every day at 10:00am (GMT)
@@ -9,6 +9,7 @@ SELECT cron.schedule('0 10 * * *', 'VACUUM');
 -- Stop scheduling a job
 SELECT cron.unschedule(1);
 
+
 -- Invalid input: input too long
 SELECT cron.schedule(repeat('a', 1000), '');
 
@@ -16,4 +17,24 @@ SELECT cron.schedule(repeat('a', 1000), '');
 SELECT cron.schedule('@restar', 'ALTER EXTENSION pg_cron UPDATE');
 SELECT cron.schedule('@restart', 'ALTER EXTENSION pg_cron UPDATE');
 
+-- Vacuum every day at 10:00am (GMT)
+SELECT cron.schedule('myvacuum', '0 10 * * *', 'VACUUM');
+
+SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
+
+-- Make that 11:00am (GMT)
+SELECT cron.schedule('myvacuum', '0 11 * * *', 'VACUUM');
+
+SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
+
+-- Make that VACUUM FULL
+SELECT cron.schedule('myvacuum', '0 11 * * *', 'VACUUM FULL');
+
+SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
+
+-- Stop scheduling a job
+SELECT cron.unschedule('myvacuum');
+
+SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
+
 DROP EXTENSION pg_cron;
diff --git a/src/job_metadata.c b/src/job_metadata.c
index ae9fbc2..bbdcd83 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -69,8 +69,9 @@
 /* forward declarations */
 static HTAB * CreateCronJobHash(void);
 
-static int64 NextJobId(void);
+static int64 ScheduleCronJob(Name jobName, char *schedule, char *command);
 static Oid CronExtensionOwner(void);
+static void EnsureDeletePermission(Relation cronJobsTable, HeapTuple heapTuple);
 static void InvalidateJobCacheCallback(Datum argument, Oid relationId);
 static void InvalidateJobCache(void);
 static Oid CronJobRelationId(void);
@@ -82,7 +83,9 @@ static bool JobRunDetailsTableExists(void);
 
 /* SQL-callable functions */
 PG_FUNCTION_INFO_V1(cron_schedule);
+PG_FUNCTION_INFO_V1(cron_schedule_named);
 PG_FUNCTION_INFO_V1(cron_unschedule);
+PG_FUNCTION_INFO_V1(cron_unschedule_named);
 PG_FUNCTION_INFO_V1(cron_job_cache_invalidate);
 
 
@@ -167,7 +170,7 @@ GetCronJob(int64 jobId)
 
 
 /*
- * cluster_schedule schedules a cron job.
+ * cron_schedule schedules an unnamed cron job.
  */
 Datum
 cron_schedule(PG_FUNCTION_ARGS)
@@ -175,21 +178,57 @@ cron_schedule(PG_FUNCTION_ARGS)
 	text *scheduleText = PG_GETARG_TEXT_P(0);
 	text *commandText = PG_GETARG_TEXT_P(1);
 
+	Name jobName = NULL;
 	char *schedule = text_to_cstring(scheduleText);
 	char *command = text_to_cstring(commandText);
+
+	int64 jobId = ScheduleCronJob(jobName, schedule, command);
+
+	PG_RETURN_INT64(jobId);
+}
+
+
+/*
+ * cron_schedule_named schedules a named cron job
+ */
+Datum
+cron_schedule_named(PG_FUNCTION_ARGS)
+{
+	Name jobName = PG_GETARG_NAME(0);
+	text *scheduleText = PG_GETARG_TEXT_P(1);
+	text *commandText = PG_GETARG_TEXT_P(2);
+
+	char *schedule = text_to_cstring(scheduleText);
+	char *command = text_to_cstring(commandText);
+
+	int64 jobId = ScheduleCronJob(jobName, schedule, command);
+
+	PG_RETURN_INT64(jobId);
+}
+
+
+/*
+ * ScheduleCronJob schedules a cron job with the given name.
+ */
+static int64
+ScheduleCronJob(Name jobName, char *schedule, char *command)
+{
 	entry *parsedSchedule = NULL;
 
 	int64 jobId = 0;
 	Datum jobIdDatum = 0;
 
-	Oid cronSchemaId = InvalidOid;
-	Oid cronJobsRelationId = InvalidOid;
+	StringInfoData querybuf;
+	Oid argTypes[MAX_NUMBER_SPI_EXEC_ARGS];
+	Datum argValues[MAX_NUMBER_SPI_EXEC_ARGS];
+	int argCount = 0;
 
-	Relation cronJobsTable = NULL;
-	TupleDesc tupleDescriptor = NULL;
-	HeapTuple heapTuple = NULL;
-	Datum values[Natts_cron_job];
-	bool isNulls[Natts_cron_job];
+	Oid savedUserId = InvalidOid;
+	int savedSecurityContext = 0;
+
+	TupleDesc returnedRowDescriptor = NULL;
+	HeapTuple returnedRow = NULL;
+	bool returnedJobIdIsNull = false;
 
 	Oid userId = GetUserId();
 	char *userName = GetUserNameFromId(userId, false);
@@ -203,85 +242,105 @@ cron_schedule(PG_FUNCTION_ARGS)
 
 	free_entry(parsedSchedule);
 
-	/* form new job tuple */
-	memset(values, 0, sizeof(values));
-	memset(isNulls, false, sizeof(isNulls));
+	initStringInfo(&querybuf);
 
-	jobId = NextJobId();
-	jobIdDatum = Int64GetDatum(jobId);
+	appendStringInfo(&querybuf,
+		"insert into %s (schedule, command, nodename, nodeport, database, username",
+		quote_qualified_identifier(CRON_SCHEMA_NAME, JOBS_TABLE_NAME));
 
-	values[Anum_cron_job_jobid - 1] = jobIdDatum;
-	values[Anum_cron_job_schedule - 1] = CStringGetTextDatum(schedule);
-	values[Anum_cron_job_command - 1] = CStringGetTextDatum(command);
-	values[Anum_cron_job_nodename - 1] = CStringGetTextDatum(CronHost);
-	values[Anum_cron_job_nodeport - 1] = Int32GetDatum(PostPortNumber);
-	values[Anum_cron_job_database - 1] = CStringGetTextDatum(CronTableDatabaseName);
-	values[Anum_cron_job_username - 1] = CStringGetTextDatum(userName);
-	values[Anum_cron_job_active - 1] = BoolGetDatum(true);
+	if (jobName != NULL)
+	{
+		appendStringInfo(&querybuf, ", jobname");
+	}
 
-	cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
-	cronJobsRelationId = get_relname_relid(JOBS_TABLE_NAME, cronSchemaId);
+	appendStringInfo(&querybuf, ") values ($1, $2, $3, $4, $5, $6");
 
-	/* open jobs relation and insert new tuple */
-	cronJobsTable = table_open(cronJobsRelationId, RowExclusiveLock);
+	if (jobName != NULL)
+	{
+		appendStringInfo(&querybuf, ", $7) on conflict (jobname) do update set ");
+		appendStringInfo(&querybuf, "schedule = EXCLUDED.schedule, ");
+		appendStringInfo(&querybuf, "command = EXCLUDED.command");
+	}
+	else
+	{
+		appendStringInfo(&querybuf, ")");
+	}
 
-	tupleDescriptor = RelationGetDescr(cronJobsTable);
-	heapTuple = heap_form_tuple(tupleDescriptor, values, isNulls);
+	appendStringInfo(&querybuf, " returning jobid");
 
-#if (PG_VERSION_NUM >= 100000)
-	CatalogTupleInsert(cronJobsTable, heapTuple);
-#else
-	simple_heap_insert(cronJobsTable, heapTuple);
-	CatalogUpdateIndexes(cronJobsTable, heapTuple);
-#endif
-	CommandCounterIncrement();
+	argTypes[0] = TEXTOID;
+	argValues[0] = CStringGetTextDatum(schedule);
+	argCount++;
 
-	/* close relation and invalidate previous cache entry */
-	table_close(cronJobsTable, NoLock);
+	argTypes[1] = TEXTOID;
+	argValues[1] = CStringGetTextDatum(command);
+	argCount++;
 
-	InvalidateJobCache();
+	argTypes[2] = TEXTOID;
+	argValues[2] = CStringGetTextDatum(CronHost);
+	argCount++;
 
-	PG_RETURN_INT64(jobId);
-}
+	argTypes[3] = INT4OID;
+	argValues[3] = Int32GetDatum(PostPortNumber);
+	argCount++;
 
+	argTypes[4] = TEXTOID;
+	argValues[4] = CStringGetTextDatum(CronTableDatabaseName);
+	argCount++;
 
-/*
- * NextJobId returns a new, unique job ID using the job ID sequence.
- */
-static int64
-NextJobId(void)
-{
-	text *sequenceName = NULL;
-	Oid sequenceId = InvalidOid;
-	List *sequenceNameList = NIL;
-	RangeVar *sequenceVar = NULL;
-	Datum sequenceIdDatum = InvalidOid;
-	Oid savedUserId = InvalidOid;
-	int savedSecurityContext = 0;
-	Datum jobIdDatum = 0;
-	int64 jobId = 0;
-	bool failOK = true;
+	argTypes[5] = TEXTOID;
+	argValues[5] = CStringGetTextDatum(userName);
+	argCount++;
 
-	/* resolve relationId from passed in schema and relation name */
-	sequenceName = cstring_to_text(JOB_ID_SEQUENCE_NAME);
-	sequenceNameList = textToQualifiedNameList(sequenceName);
-	sequenceVar = makeRangeVarFromNameList(sequenceNameList);
-	sequenceId = RangeVarGetRelid(sequenceVar, NoLock, failOK);
-	sequenceIdDatum = ObjectIdGetDatum(sequenceId);
+	if (jobName != NULL)
+	{
+		argTypes[6] = NAMEOID;
+		argValues[6] = NameGetDatum(jobName);
+		argCount++;
+	}
 
 	GetUserIdAndSecContext(&savedUserId, &savedSecurityContext);
 	SetUserIdAndSecContext(CronExtensionOwner(), SECURITY_LOCAL_USERID_CHANGE);
 
-	/* generate new and unique colocation id from sequence */
-	jobIdDatum = DirectFunctionCall1(nextval_oid, sequenceIdDatum);
+	/* Open SPI context. */
+	if (SPI_connect() != SPI_OK_CONNECT)
+	{
+		elog(ERROR, "SPI_connect failed");
+	}
 
-	SetUserIdAndSecContext(savedUserId, savedSecurityContext);
+	if (SPI_execute_with_args(querybuf.data, argCount, argTypes, argValues, NULL,
+							  false, 1) != SPI_OK_INSERT_RETURNING)
+	{
+		elog(ERROR, "SPI_exec failed: %s", querybuf.data);
+	}
+
+	if (SPI_processed <= 0)
+	{
+		elog(ERROR, "query did not return any rows: %s", querybuf.data);
+	}
 
+	returnedRowDescriptor = SPI_tuptable->tupdesc;
+	returnedRow = SPI_tuptable->vals[0];
+
+	jobIdDatum = SPI_getbinval(returnedRow, returnedRowDescriptor, 1,
+							   &returnedJobIdIsNull);
 	jobId = DatumGetInt64(jobIdDatum);
 
+	pfree(querybuf.data);
+
+	SPI_finish();
+
+	SetUserIdAndSecContext(savedUserId, savedSecurityContext);
+
+	InvalidateJobCache();
+
 	return jobId;
 }
 
+
+/*
+ * NextRunId draws a new run ID from cron.runid_seq.
+ */
 int64
 NextRunId(void)
 {
@@ -373,7 +432,7 @@ CronExtensionOwner(void)
 
 
 /*
- * cluster_unschedule removes a cron job.
+ * cron_unschedule removes a cron job.
  */
 Datum
 cron_unschedule(PG_FUNCTION_ARGS)
@@ -388,13 +447,7 @@ cron_unschedule(PG_FUNCTION_ARGS)
 	ScanKeyData scanKey[1];
 	int scanKeyCount = 1;
 	bool indexOK = true;
-	TupleDesc tupleDescriptor = NULL;
 	HeapTuple heapTuple = NULL;
-	bool isNull = false;
-	Oid userId = InvalidOid;
-	char *userName = NULL;
-	Datum ownerNameDatum = 0;
-	char *ownerName = NULL;
 
 	cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
 	cronJobIndexId = get_relname_relid(JOB_ID_INDEX_NAME, cronSchemaId);
@@ -408,8 +461,6 @@ cron_unschedule(PG_FUNCTION_ARGS)
 										cronJobIndexId, indexOK,
 										NULL, scanKeyCount, scanKey);
 
-	tupleDescriptor = RelationGetDescr(cronJobsTable);
-
 	heapTuple = systable_getnext(scanDescriptor);
 	if (!HeapTupleIsValid(heapTuple))
 	{
@@ -417,13 +468,82 @@ cron_unschedule(PG_FUNCTION_ARGS)
 							   INT64_FORMAT, jobId)));
 	}
 
+	EnsureDeletePermission(cronJobsTable, heapTuple);
+
+	simple_heap_delete(cronJobsTable, &heapTuple->t_self);
+
+	systable_endscan(scanDescriptor);
+	table_close(cronJobsTable, NoLock);
+
+	CommandCounterIncrement();
+	InvalidateJobCache();
+
+	PG_RETURN_BOOL(true);
+}
+
+
+/*
+ * cron_unschedule_named removes a cron job by name.
+ */
+Datum
+cron_unschedule_named(PG_FUNCTION_ARGS)
+{
+	Datum jobNameDatum = PG_GETARG_DATUM(0);
+	Name jobName = DatumGetName(jobNameDatum);
+
+	Relation cronJobsTable = NULL;
+	SysScanDesc scanDescriptor = NULL;
+	ScanKeyData scanKey[1];
+	int scanKeyCount = 1;
+	bool indexOK = false;
+	HeapTuple heapTuple = NULL;
+
+	cronJobsTable = table_open(CronJobRelationId(), RowExclusiveLock);
+
+	ScanKeyInit(&scanKey[0], Anum_cron_job_jobname,
+				BTEqualStrategyNumber, F_NAMEEQ, jobNameDatum);
+
+	scanDescriptor = systable_beginscan(cronJobsTable, InvalidOid, indexOK,
+										NULL, scanKeyCount, scanKey);
+
+	heapTuple = systable_getnext(scanDescriptor);
+	if (!HeapTupleIsValid(heapTuple))
+	{
+		ereport(ERROR, (errmsg("could not find valid entry for job '%s'",
+							   NameStr(*jobName))));
+	}
+
+	EnsureDeletePermission(cronJobsTable, heapTuple);
+
+	simple_heap_delete(cronJobsTable, &heapTuple->t_self);
+
+	systable_endscan(scanDescriptor);
+	table_close(cronJobsTable, NoLock);
+
+	CommandCounterIncrement();
+	InvalidateJobCache();
+
+	PG_RETURN_BOOL(true);
+}
+
+
+/*
+ * EnsureDeletePermission throws an error if the current user does
+ * not have permission to delete the given cron.job tuple.
+ */
+static void
+EnsureDeletePermission(Relation cronJobsTable, HeapTuple heapTuple)
+{
+	TupleDesc tupleDescriptor = RelationGetDescr(cronJobsTable);
+
 	/* check if the current user owns the row */
-	userId = GetUserId();
-	userName = GetUserNameFromId(userId, false);
+	Oid userId = GetUserId();
+	char *userName = GetUserNameFromId(userId, false);
 
-	ownerNameDatum = heap_getattr(heapTuple, Anum_cron_job_username,
-								  tupleDescriptor, &isNull);
-	ownerName = TextDatumGetCString(ownerNameDatum);
+	bool isNull = false;
+	Datum ownerNameDatum = heap_getattr(heapTuple, Anum_cron_job_username,
+										tupleDescriptor, &isNull);
+	char *ownerName = TextDatumGetCString(ownerNameDatum);
 	if (pg_strcasecmp(userName, ownerName) != 0)
 	{
 		/* otherwise, allow if the user has DELETE permission */
@@ -440,16 +560,6 @@ cron_unschedule(PG_FUNCTION_ARGS)
 						   get_rel_name(CronJobRelationId()));
 		}
 	}
-
-	simple_heap_delete(cronJobsTable, &heapTuple->t_self);
-
-	systable_endscan(scanDescriptor);
-	table_close(cronJobsTable, NoLock);
-
-	CommandCounterIncrement();
-	InvalidateJobCache();
-
-	PG_RETURN_BOOL(true);
 }
 
 
@@ -623,8 +733,6 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 	Datum userName = heap_getattr(heapTuple, Anum_cron_job_username,
 								  tupleDescriptor, &isNull);
 
-	Assert(!HeapTupleHasNulls(heapTuple));
-
 	jobKey = DatumGetInt64(jobId);
 	job = hash_search(CronJobHash, &jobKey, HASH_ENTER, &isPresent);
 
@@ -648,6 +756,21 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 		job->active = true;
 	}
 
+	if (tupleDescriptor->natts >= Anum_cron_job_jobname)
+	{
+		bool isJobNameNull = false;
+		Datum jobName = heap_getattr(heapTuple, Anum_cron_job_jobname,
+									 tupleDescriptor, &isJobNameNull);
+		if (!isJobNameNull)
+		{
+			job->jobName = DatumGetName(jobName);
+		}
+		else
+		{
+			job->jobName = NULL;
+		}
+	}
+
 	parsedSchedule = parse_cron_entry(job->scheduleText);
 	if (parsedSchedule != NULL)
 	{

COMMIT_HASH:6f7018f1e9a7a61fae7209094832dfde55e1149c|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2020-09-23 14:05:42 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index ea9d22a..86bd1f3 100644
--- a/README.md
+++ b/README.md
@@ -117,6 +117,7 @@ The following table keeps track of which of the major managed Postgres services
 
 | Service       | Supported     |
 | ------------- |:-------------:|
+| [Alibaba Cloud](https://www.alibabacloud.com/help/doc-detail/150355.htm) | :heavy_check_mark: |
 | [Amazon RDS](https://aws.amazon.com/rds/postgresql/)     | :x:      |          |
 | [Azure](https://azure.microsoft.com/en-us/services/postgresql/) | :heavy_check_mark:  |
 | [Citus Cloud](https://www.citusdata.com/product/cloud)  | :heavy_check_mark: |

COMMIT_HASH:841f8e17f17811485c07d0b8ee3585bd6c03003a|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2020-09-23 14:04:54 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 2d588ad..ea9d22a 100644
--- a/README.md
+++ b/README.md
@@ -117,10 +117,10 @@ The following table keeps track of which of the major managed Postgres services
 
 | Service       | Supported     |
 | ------------- |:-------------:|
-| [Citus Cloud](https://www.citusdata.com/product/cloud)  | :heavy_check_mark: |
 | [Amazon RDS](https://aws.amazon.com/rds/postgresql/)     | :x:      |          |
-| [Azure](https://azure.microsoft.com/en-us/services/postgresql/) | :heavy_check_mark: for Hyperscale (Citus)   |
+| [Azure](https://azure.microsoft.com/en-us/services/postgresql/) | :heavy_check_mark:  |
+| [Citus Cloud](https://www.citusdata.com/product/cloud)  | :heavy_check_mark: |
+| [Crunchy Bridge](https://www.crunchydata.com/products/crunchy-bridge/?ref=producthunt) | :heavy_check_mark: |
 | [DigitalOcean](https://www.digitalocean.com/products/managed-databases/) | :heavy_check_mark: |
 | [Google Cloud](https://cloud.google.com/sql/docs/postgres/) | :x:      |
 | [Heroku](https://elements.heroku.com/addons/heroku-postgresql) | :x: | |
-| [Crunchy Bridge](https://www.crunchydata.com/products/crunchy-bridge/?ref=producthunt) | :heavy_check_mark: |

COMMIT_HASH:f3b3b2977d4e876406afe5f0f61db151d63cb967|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2020-09-23 14:01:23 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 574ee45..2d588ad 100644
--- a/README.md
+++ b/README.md
@@ -111,17 +111,6 @@ Articles showing possible ways of using pg_cron:
 * [Feeding cats](http://bonesmoses.org/2016/09/09/pg-phriday-irrelevant-inclinations/)
 * [Routinely invoking a function](https://fluca1978.github.io/2019/05/21/pgcron.html)
 
-## Advanced usage
-
-Since pg_cron uses libpq, you can also run periodic jobs on other databases or other machines. If you are superuser, then you can manually modify the `cron.job` table and use custom values for nodename and nodeport to connect to a different machine:
-
-```sql
-INSERT INTO cron.job (schedule, command, nodename, nodeport, database, username)
-VALUES ('0 4 * * *', 'VACUUM', 'node-1', 5432, 'postgres', 'marco');
-```
-
-You can use [.pgpass](https://www.postgresql.org/docs/current/static/libpq-pgpass.html) to allow pg_cron to authenticate with the remote server.
-
 ## Managed services
 
 The following table keeps track of which of the major managed Postgres services support pg_cron.

COMMIT_HASH:26b127072e935f09c98aed243fad02842f315a85|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2020-09-22 11:31:17 +0200|TITLE:Fix bug causing overlapping runs to not start|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 4e82bdd..e0ca973 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -1625,7 +1625,16 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 		case CRON_TASK_DONE:
 		default:
 		{
+			int currentPendingRunCount = task->pendingRunCount;
+
 			InitializeCronTask(task, jobId);
+
+			/*
+			 * We keep the number of runs that should have started while
+			 * the task was still running. If >0, this will trigger another
+			 * run immediately.
+			 */
+			task->pendingRunCount = currentPendingRunCount;
 		}
 	}
 }

COMMIT_HASH:478f3044eb7a3aff1cb8e5478d3c0bd4b7041714|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2020-09-18 14:41:41 +0200|TITLE:Remove outdated comment from README|MESSAGE:
diff --git a/README.md b/README.md
index e791f96..574ee45 100644
--- a/README.md
+++ b/README.md
@@ -93,10 +93,6 @@ After restarting PostgreSQL, you can create the pg_cron functions and metadata t
 -- run as superuser:
 CREATE EXTENSION pg_cron;
 
--- on PostgreSQL 9.x, do this instead:
-CREATE EXTENSION pg_cron VERSION '1.0';
-ALTER EXTENSION pg_cron UPDATE;
-
 -- optionally, grant usage to regular users:
 GRANT USAGE ON SCHEMA cron TO marco;
 ```

COMMIT_HASH:bfb3c4f250bc2bf0dd83f3bf4ce6a289d91c9189|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2020-09-18 14:35:24 +0200|TITLE:Add a restart syntax test|MESSAGE:
diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index d0ca140..f978648 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -29,4 +29,13 @@ SELECT cron.unschedule(1);
 -- Invalid input: input too long
 SELECT cron.schedule(repeat('a', 1000), '');
 ERROR:  invalid schedule: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+-- Try to update pg_cron on restart
+SELECT cron.schedule('@restar', 'ALTER EXTENSION pg_cron UPDATE');
+ERROR:  invalid schedule: @restar
+SELECT cron.schedule('@restart', 'ALTER EXTENSION pg_cron UPDATE');
+ schedule 
+----------
+        2
+(1 row)
+
 DROP EXTENSION pg_cron;
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index 3eb0c96..5ac3cd1 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -12,4 +12,8 @@ SELECT cron.unschedule(1);
 -- Invalid input: input too long
 SELECT cron.schedule(repeat('a', 1000), '');
 
+-- Try to update pg_cron on restart
+SELECT cron.schedule('@restar', 'ALTER EXTENSION pg_cron UPDATE');
+SELECT cron.schedule('@restart', 'ALTER EXTENSION pg_cron UPDATE');
+
 DROP EXTENSION pg_cron;

COMMIT_HASH:3c7318ca16c490e128f61ff4bff0bbe6b15414e3|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2020-09-18 14:04:49 +0200|TITLE:Accept restart as an alias for reboot|MESSAGE:
diff --git a/src/entry.c b/src/entry.c
index eae4516..79dc9df 100644
--- a/src/entry.c
+++ b/src/entry.c
@@ -123,7 +123,7 @@ parse_cron_entry(char *schedule)
 		 * HINT
 		 */
 		ch = get_string(cmd, MAX_COMMAND, file, " \t\n");
-		if (!strcmp("reboot", cmd)) {
+		if (!strcmp("reboot", cmd) || !strcmp("restart", cmd)) {
 			e->flags |= WHEN_REBOOT;
 		} else if (!strcmp("yearly", cmd) || !strcmp("annually", cmd)){
 			bit_set(e->minute, 0);

COMMIT_HASH:e4989dbe2cabb68ce8158ec9bbf4876f1235774f|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2020-09-18 14:04:40 +0200|TITLE:Fix infinite loop when using invalid schedule starting with @|MESSAGE:
diff --git a/src/misc.c b/src/misc.c
index d28d9b8..bf7e2b3 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -54,6 +54,11 @@ get_char(file)
 	else if (buffer->pointer == buffer->length)
 	{
 		ch = '\0';
+		buffer->pointer++;
+	}
+	else if (buffer->pointer > buffer->length)
+	{
+		ch = EOF;
 	}
 	else
 	{

COMMIT_HASH:39fcfaa715f7abe6cd3c617771c03b2ea6b6140c|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2020-09-18 13:33:32 +0200|TITLE:Guard against running 1.3 binaries on older schema|MESSAGE:
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 0e24133..ae9fbc2 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -77,6 +77,7 @@ static Oid CronJobRelationId(void);
 
 static CronJob * TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple);
 static bool PgCronHasBeenLoaded(void);
+static bool JobRunDetailsTableExists(void);
 
 
 /* SQL-callable functions */
@@ -295,10 +296,18 @@ NextRunId(void)
 	int64 jobId = 0;
 	bool failOK = true;
 
-	SetCurrentStatementStartTimestamp();
 	StartTransactionCommand();
 	PushActiveSnapshot(GetTransactionSnapshot());
 
+	if (!JobRunDetailsTableExists())
+	{
+		PopActiveSnapshot();
+		CommitTransactionCommand();
+
+		/* if the job_run_details table is not yet created, the run ID is not used */
+		return 0;
+	}
+
 	/* resolve relationId from passed in schema and relation name */
 	sequenceName = cstring_to_text(RUN_ID_SEQUENCE_NAME);
 	sequenceNameList = textToQualifiedNameList(sequenceName);
@@ -316,6 +325,9 @@ NextRunId(void)
 
 	jobId = DatumGetInt64(jobIdDatum);
 
+	PopActiveSnapshot();
+	CommitTransactionCommand();
+
 	return jobId;
 }
 
@@ -704,11 +716,10 @@ InsertJobRunDetail(int64 runId, int64 *jobId, char *database, char *username, ch
 	StartTransactionCommand();
 	PushActiveSnapshot(GetTransactionSnapshot());
 
-	if (!PgCronHasBeenLoaded() || RecoveryInProgress())
+	if (!PgCronHasBeenLoaded() || RecoveryInProgress() || !JobRunDetailsTableExists())
 	{
 		PopActiveSnapshot();
 		CommitTransactionCommand();
-		ereport(LOG,(errmsg("pg_cron not loaded/present or recovery in progress")));
 		return;
 	}
 
@@ -774,11 +785,10 @@ UpdateJobRunDetail(int64 runId, int32 *job_pid, char *status, char *return_messa
 	StartTransactionCommand();
 	PushActiveSnapshot(GetTransactionSnapshot());
 
-	if (!PgCronHasBeenLoaded() || RecoveryInProgress())
+	if (!PgCronHasBeenLoaded() || RecoveryInProgress() || !JobRunDetailsTableExists())
 	{
 		PopActiveSnapshot();
 		CommitTransactionCommand();
-		ereport(LOG,(errmsg("pg_cron not loaded/present or recovery in progress")));
 		return;
 	}
 
@@ -872,7 +882,7 @@ MarkPendingRunsAsFailed(void)
 	StartTransactionCommand();
 	PushActiveSnapshot(GetTransactionSnapshot());
 
-	if (!PgCronHasBeenLoaded() || RecoveryInProgress())
+	if (!PgCronHasBeenLoaded() || RecoveryInProgress() || !JobRunDetailsTableExists())
 	{
 		PopActiveSnapshot();
 		CommitTransactionCommand();
@@ -934,3 +944,17 @@ GetCronStatus(CronStatus cronstatus)
 	}
 	return statusDesc;
 }
+
+
+/*
+ * JobRunDetailsTableExists returns whether the job_run_details table exists.
+ */
+static bool
+JobRunDetailsTableExists(void)
+{
+	Oid cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
+	Oid jobRunDetailsTableOid = get_relname_relid(JOB_RUN_DETAILS_TABLE_NAME,
+												  cronSchemaId);
+
+	return jobRunDetailsTableOid != InvalidOid;
+}
diff --git a/src/pg_cron.c b/src/pg_cron.c
index f289d31..4e82bdd 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -1136,8 +1136,6 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 			/* Add new entry to audit table. */
 			task->runId = NextRunId();
-			PopActiveSnapshot();
-			CommitTransactionCommand();
 			if (CronLogRun)
 				InsertJobRunDetail(task->runId, &cronJob->jobId,
 										cronJob->database,

COMMIT_HASH:b001d7855e72d685110a5d398e59524d46fa4f31|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2020-09-15 00:21:22 +0200|TITLE:Fix PG13 compilation issues|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 3ccf6a6..f289d31 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -1997,7 +1997,7 @@ ExecuteSqlString(const char *sql)
 		#if PG_VERSION_NUM < 130000
 			set_ps_display(commandTag, false);
 		#else
-			set_ps_display(GetCommandTagName(commandTag), false);
+			set_ps_display(GetCommandTagName(commandTag));
 		#endif
 
 		BeginCommand(commandTag, DestNone);
@@ -2023,7 +2023,11 @@ ExecuteSqlString(const char *sql)
 			querytree_list = pg_analyze_and_rewrite(parsetree, sql, NULL, 0);
 		#endif
 
-		plantree_list = pg_plan_queries(querytree_list, 0, NULL);
+		#if PG_VERSION_NUM < 130000
+			plantree_list = pg_plan_queries(querytree_list, 0, NULL);
+		#else
+			plantree_list = pg_plan_queries(querytree_list, sql, 0, NULL);
+		#endif
 
 		/* Done with the snapshot used for parsing/planning */
 		if (snapshot_set)

COMMIT_HASH:003a17b0eac8ebaa05206c26539a86676178dd4a|AUTHOR_NAME:bdt|AUTHOR_EMAIL:bdt|DATE:2020-09-08 06:37:05 +0000|TITLE:SPI, retry on BGW registration, display all messages, split task feedback, adapt max running tasks|MESSAGE:
diff --git a/include/job_metadata.h b/include/job_metadata.h
index 9f4df8a..8287ecc 100644
--- a/include/job_metadata.h
+++ b/include/job_metadata.h
@@ -17,6 +17,15 @@
 #include "datatype/timestamp.h"
 #endif
 
+typedef enum
+{
+	CRON_STATUS_STARTING,
+	CRON_STATUS_RUNNING,
+	CRON_STATUS_SENDING,
+	CRON_STATUS_CONNECTING,
+	CRON_STATUS_SUCCEEDED,
+	CRON_STATUS_FAILED
+} CronStatus;
 
 /* job metadata data structure */
 typedef struct CronJob
@@ -44,11 +53,11 @@ extern void ResetJobMetadataCache(void);
 extern List * LoadCronJobList(void);
 extern CronJob * GetCronJob(int64 jobId);
 
-extern bool InsertOrUpdateJobRunDetail(int64 runId, int64 *jobId, int32 *job_pid,
-									char *database, char *username, char *command,
-									char *status, char *return_message, TimestampTz *start_time,
+extern void InsertJobRunDetail(int64 runId, int64 *jobId, char *database, char *username, char *command, char *status);
+extern void UpdateJobRunDetail(int64 runId, int32 *job_pid, char *status, char *return_message, TimestampTz *start_time,
 									TimestampTz *end_time);
 extern int64 NextRunId(void);
-extern void CleanAuditTable(void);
+extern void MarkPendingRunsAsFailed(void);
+extern char *GetCronStatus(CronStatus cronstatus);
 
 #endif
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 3405dce..0e24133 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -48,6 +48,9 @@
 #include "utils/varlena.h"
 #endif
 
+#include "executor/spi.h"
+#include "catalog/pg_type.h"
+
 #if (PG_VERSION_NUM < 120000)
 #define table_open(r, l) heap_open(r, l)
 #define table_close(r, l) heap_close(r, l)
@@ -60,7 +63,7 @@
 #define JOB_ID_SEQUENCE_NAME "cron.jobid_seq"
 #define JOB_RUN_DETAILS_TABLE_NAME "job_run_details"
 #define RUN_ID_SEQUENCE_NAME "cron.runid_seq"
-#define JOB_RUN_DETAILS_INDEX_NAME "job_run_details_pkey"
+#define MAX_NUMBER_SPI_EXEC_ARGS 6
 
 
 /* forward declarations */
@@ -71,7 +74,6 @@ static Oid CronExtensionOwner(void);
 static void InvalidateJobCacheCallback(Datum argument, Oid relationId);
 static void InvalidateJobCache(void);
 static Oid CronJobRelationId(void);
-static Oid JobRunDetailsRelationId(void);
 
 static CronJob * TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple);
 static bool PgCronHasBeenLoaded(void);
@@ -89,7 +91,6 @@ static HTAB *CronJobHash = NULL;
 static Oid CachedCronJobRelationId = InvalidOid;
 bool CronJobCacheValid = false;
 char *CronHost = "localhost";
-static Oid CachedJobRunDetailsRelationId = InvalidOid;
 
 
 /*
@@ -294,6 +295,10 @@ NextRunId(void)
 	int64 jobId = 0;
 	bool failOK = true;
 
+	SetCurrentStatementStartTimestamp();
+	StartTransactionCommand();
+	PushActiveSnapshot(GetTransactionSnapshot());
+
 	/* resolve relationId from passed in schema and relation name */
 	sequenceName = cstring_to_text(RUN_ID_SEQUENCE_NAME);
 	sequenceNameList = textToQualifiedNameList(sequenceName);
@@ -505,19 +510,6 @@ CronJobRelationId(void)
 	return CachedCronJobRelationId;
 }
 
-static Oid
-JobRunDetailsRelationId(void)
-{
-	if (CachedJobRunDetailsRelationId == InvalidOid)
-	{
-		Oid cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
-
-		CachedJobRunDetailsRelationId = get_relname_relid(JOB_RUN_DETAILS_TABLE_NAME, cronSchemaId);
-	}
-
-	return CachedJobRunDetailsRelationId;
-}
-
 /*
  * LoadCronJobList loads the current list of jobs from the
  * cron.job table and adds each job to the CronJobHash.
@@ -701,237 +693,244 @@ PgCronHasBeenLoaded(void)
 	return extensionLoaded;
 }
 
-bool
-InsertOrUpdateJobRunDetail(int64 runId, int64 *jobId, int32 *job_pid,
-								char *database, char *username, char *command,
-								char *status, char *return_message, TimestampTz *start_time,
-								TimestampTz *end_time)
+void
+InsertJobRunDetail(int64 runId, int64 *jobId, char *database, char *username, char *command, char *status)
 {
-	Relation jobRunDetailTable;
-	SysScanDesc scanDescriptor;
-	ScanKeyData scanKey[1];
-	HeapTuple heapTuple;
-	TupleDesc tupleDescriptor;
-	Datum values[Natts_job_run_details];
-	bool isNulls[Natts_job_run_details];
-	bool repl[Natts_job_run_details];
-	Oid schemaId;
-	Oid indexId;
+	StringInfoData querybuf;
+	Oid argTypes[MAX_NUMBER_SPI_EXEC_ARGS];
+	Datum argValues[MAX_NUMBER_SPI_EXEC_ARGS];
 
 	SetCurrentStatementStartTimestamp();
 	StartTransactionCommand();
 	PushActiveSnapshot(GetTransactionSnapshot());
 
-	/*
-	 * If the pg_job_scheduler extension has not been created yet or
-	 * we are on a hot standby, the job table is treated as
-	 * being empty.
-	 */
 	if (!PgCronHasBeenLoaded() || RecoveryInProgress())
 	{
 		PopActiveSnapshot();
 		CommitTransactionCommand();
-		pgstat_report_activity(STATE_IDLE, NULL);
-		return false;
+		ereport(LOG,(errmsg("pg_cron not loaded/present or recovery in progress")));
+		return;
 	}
 
-	memset(values, 0, sizeof(values));
-	memset(isNulls, false, sizeof(isNulls));
-	memset(repl, false, sizeof(repl));
+	initStringInfo(&querybuf);
 
-	values[Anum_job_run_details_runid - 1] = Int64GetDatum(runId);
+	/* Open SPI context. */
+	if (SPI_connect() != SPI_OK_CONNECT)
+		elog(ERROR, "SPI_connect failed");
 
-	if (jobId == NULL)
-		isNulls[Anum_job_run_details_jobid - 1] = true;
-	else
-	{
-		values[Anum_job_run_details_jobid - 1] = Int64GetDatum(*jobId);
-		repl[Anum_job_run_details_jobid - 1] = true;
-	}
 
-	if (job_pid == NULL)
-		isNulls[Anum_job_run_details_job_pid - 1] = true;
-	else
-	{
-		values[Anum_job_run_details_job_pid - 1] = Int32GetDatum(*job_pid);
-		repl[Anum_job_run_details_job_pid - 1] = true;
-	}
+	appendStringInfo(&querybuf,
+		"insert into %s.%s (jobid, runid, database, username, command, status) values ($1,$2,$3,$4,$5,$6)",
+		CRON_SCHEMA_NAME, JOB_RUN_DETAILS_TABLE_NAME);
 
-	if (database == NULL)
-		isNulls[Anum_job_run_details_database - 1] = true;
-	else
-	{
-		values[Anum_job_run_details_database - 1] = CStringGetTextDatum(database);
-		repl[Anum_job_run_details_database - 1] = true;
-	}
+	/* jobId */
+	argTypes[0] = INT8OID;
+	argValues[0] = Int64GetDatum(*jobId);
 
-	if (username == NULL)
-		isNulls[Anum_job_run_details_username - 1] = true;
-	else
+	/* runId */
+	argTypes[1] = INT8OID;
+	argValues[1] = Int64GetDatum(runId);
+
+	/* database */
+	argTypes[2] = TEXTOID;
+	argValues[2] = CStringGetTextDatum(database);
+
+	/* username */
+	argTypes[3] = TEXTOID;
+	argValues[3] = CStringGetTextDatum(username);
+
+	/* command */
+	argTypes[4] = TEXTOID;
+	argValues[4] = CStringGetTextDatum(command);
+
+	/* status */
+	argTypes[5] = TEXTOID;
+	argValues[5] = CStringGetTextDatum(status);
+
+	pgstat_report_activity(STATE_RUNNING, querybuf.data);
+
+	if(SPI_execute_with_args(querybuf.data,
+		MAX_NUMBER_SPI_EXEC_ARGS, argTypes, argValues, NULL, false, 1) != SPI_OK_INSERT)
+		elog(ERROR, "SPI_exec failed: %s", querybuf.data);
+
+	pfree(querybuf.data);
+
+	SPI_finish();
+	PopActiveSnapshot();
+	CommitTransactionCommand();
+	pgstat_report_activity(STATE_IDLE, NULL);
+}
+
+void
+UpdateJobRunDetail(int64 runId, int32 *job_pid, char *status, char *return_message, TimestampTz *start_time,
+                                                                        TimestampTz *end_time)
+{
+	StringInfoData querybuf;
+	Oid argTypes[MAX_NUMBER_SPI_EXEC_ARGS];
+	Datum argValues[MAX_NUMBER_SPI_EXEC_ARGS];
+	int i;
+
+	SetCurrentStatementStartTimestamp();
+	StartTransactionCommand();
+	PushActiveSnapshot(GetTransactionSnapshot());
+
+	if (!PgCronHasBeenLoaded() || RecoveryInProgress())
 	{
-		values[Anum_job_run_details_username - 1] = CStringGetTextDatum(username);
-		repl[Anum_job_run_details_username - 1] = true;
+		PopActiveSnapshot();
+		CommitTransactionCommand();
+		ereport(LOG,(errmsg("pg_cron not loaded/present or recovery in progress")));
+		return;
 	}
 
-	if (command == NULL)
-		isNulls[Anum_job_run_details_command - 1] = true;
-	else
-	{
-		values[Anum_job_run_details_command - 1] = CStringGetTextDatum(command);
-		repl[Anum_job_run_details_command - 1] = true;
+	initStringInfo(&querybuf);
+	i = 0;
+
+	/* Open SPI context. */
+	if (SPI_connect() != SPI_OK_CONNECT)
+		elog(ERROR, "SPI_connect failed");
+
+
+	appendStringInfo(&querybuf,
+		"update %s.%s set", CRON_SCHEMA_NAME, JOB_RUN_DETAILS_TABLE_NAME);
+
+
+	/* add the fields to be updated */
+	if (job_pid != NULL) {
+		argTypes[i] = INT4OID;
+		argValues[i] = Int32GetDatum(*job_pid);
+		i++;
+		appendStringInfo(&querybuf, " job_pid = $%d,", i);
 	}
 
-	if (status == NULL)
-		isNulls[Anum_job_run_details_status - 1] = true;
-	else
+	if (status != NULL)
 	{
-		values[Anum_job_run_details_status - 1] = CStringGetTextDatum(status);
-		repl[Anum_job_run_details_status - 1] = true;
+		argTypes[i] = TEXTOID;
+		argValues[i] = CStringGetTextDatum(status);
+		i++;
+
+		appendStringInfo(&querybuf, " status = $%d,", i);
 	}
 
-	if (return_message == NULL)
-		isNulls[Anum_job_run_details_return_message - 1] = true;
-	else
+        if (return_message != NULL)
 	{
-		values[Anum_job_run_details_return_message - 1] = CStringGetTextDatum(return_message);
-		repl[Anum_job_run_details_return_message - 1] = true;
+		argTypes[i] = TEXTOID;
+		argValues[i] = CStringGetTextDatum(return_message);
+		i++;
+
+		appendStringInfo(&querybuf, " return_message = $%d,", i);
 	}
 
-	if (start_time == NULL)
-		isNulls[Anum_job_run_details_start_time - 1] = true;
-	else
+        if (start_time != NULL)
 	{
-		values[Anum_job_run_details_start_time - 1] = TimestampTzGetDatum(*start_time);
-		repl[Anum_job_run_details_start_time - 1] = true;
+		argTypes[i] = TIMESTAMPTZOID;
+		argValues[i] = TimestampTzGetDatum(*start_time);
+		i++;
+
+		appendStringInfo(&querybuf, " start_time = $%d,", i);
 	}
 
-	if (end_time == NULL)
-		isNulls[Anum_job_run_details_end_time - 1] = true;
-	else
+        if (end_time != NULL)
 	{
-		values[Anum_job_run_details_end_time - 1] = TimestampTzGetDatum(*end_time);
-		repl[Anum_job_run_details_end_time - 1] = true;
-	}
+		argTypes[i] = TIMESTAMPTZOID;
+		argValues[i] = TimestampTzGetDatum(*end_time);
+		i++;
 
-	schemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
-	indexId = get_relname_relid(JOB_RUN_DETAILS_INDEX_NAME, schemaId);
+		appendStringInfo(&querybuf, " end_time = $%d,", i);
+	}
 
-	jobRunDetailTable = table_open(JobRunDetailsRelationId(), RowExclusiveLock);
+	argTypes[i] = INT8OID;
+	argValues[i] = Int64GetDatum(runId);
+	i++;
 
-	ScanKeyInit(&scanKey[0], Anum_job_run_details_runid,
-							BTEqualStrategyNumber, F_INT8EQ, Int64GetDatum(runId));
+	/* remove the last comma */
+	querybuf.len--;
+	querybuf.data[querybuf.len] = '\0';
 
-	scanDescriptor = systable_beginscan(jobRunDetailTable, indexId, true,
-									NULL, 1, scanKey);
+	/* and add the where clause */
+	appendStringInfo(&querybuf, " where runid = $%d", i);
 
-	tupleDescriptor = RelationGetDescr(jobRunDetailTable);
+	pgstat_report_activity(STATE_RUNNING, querybuf.data);
 
-	heapTuple = systable_getnext(scanDescriptor);
-	if (!HeapTupleIsValid(heapTuple))
-	{
-		heapTuple = heap_form_tuple(tupleDescriptor, values, isNulls);
-		#if PG_VERSION_NUM < 100000
-			simple_heap_insert(jobRunDetailTable, heapTuple);
-			CatalogUpdateIndexes(jobRunDetailTable, heapTuple);
-		#else
-			CatalogTupleInsert(jobRunDetailTable, heapTuple);
-		#endif
-		heap_freetuple(heapTuple);
-	}
-	else
-	{
-		HeapTuple newtuple;
-
-		newtuple = heap_modify_tuple(heapTuple, tupleDescriptor, values, isNulls, repl);
-		#if PG_VERSION_NUM < 100000
-			simple_heap_update(jobRunDetailTable, &newtuple->t_self, newtuple);
-			CatalogUpdateIndexes(jobRunDetailTable, newtuple);
-		#else
-			CatalogTupleUpdate(jobRunDetailTable, &newtuple->t_self, newtuple);
-		#endif
-		heap_freetuple(newtuple);
-	}
+	if(SPI_execute_with_args(querybuf.data,
+		i, argTypes, argValues, NULL, false, 1) != SPI_OK_UPDATE)
+		elog(ERROR, "SPI_exec failed: %s", querybuf.data);
 
-	systable_endscan(scanDescriptor);
-	table_close(jobRunDetailTable, NoLock);
+	pfree(querybuf.data);
 
+	SPI_finish();
 	PopActiveSnapshot();
 	CommitTransactionCommand();
-
-	return true;
+	pgstat_report_activity(STATE_IDLE, NULL);
 }
 
 void
-CleanAuditTable(void)
+MarkPendingRunsAsFailed(void)
 {
-	Relation jobRunDetailTable;
-	SysScanDesc scanDescriptor;
-	HeapTuple heapTuple;
-	TupleDesc tupleDescriptor;
-	Datum values[Natts_job_run_details];
-	bool isNulls[Natts_job_run_details];
-	bool repl[Natts_job_run_details];
+	StringInfoData querybuf;
 
 	SetCurrentStatementStartTimestamp();
 	StartTransactionCommand();
 	PushActiveSnapshot(GetTransactionSnapshot());
 
-	/*
-	 * If the pg_job_scheduler extension has not been created yet or
-	 * we are on a hot standby, the job table is treated as
-	 * being empty.
-	 */
 	if (!PgCronHasBeenLoaded() || RecoveryInProgress())
 	{
 		PopActiveSnapshot();
 		CommitTransactionCommand();
-		pgstat_report_activity(STATE_IDLE, NULL);
 		return;
 	}
 
-	memset(values, 0, sizeof(values));
-	memset(isNulls, false, sizeof(isNulls));
-	memset(repl, false, sizeof(repl));
+	initStringInfo(&querybuf);
 
-	values[Anum_job_run_details_status - 1] = CStringGetTextDatum("failed");
-	repl[Anum_job_run_details_status - 1] = true;
+	/* Open SPI context. */
+	if (SPI_connect() != SPI_OK_CONNECT)
+		elog(ERROR, "SPI_connect failed");
 
-	values[Anum_job_run_details_return_message - 1] = CStringGetTextDatum("server restarted");
-	repl[Anum_job_run_details_return_message - 1] = true;
 
-	get_namespace_oid(CRON_SCHEMA_NAME, false);
-	jobRunDetailTable = table_open(JobRunDetailsRelationId(), RowExclusiveLock);
+	appendStringInfo(&querybuf,
+		"update %s.%s set status = '%s', return_message = 'server restarted' where status in ('%s','%s')"
+		, CRON_SCHEMA_NAME, JOB_RUN_DETAILS_TABLE_NAME, GetCronStatus(CRON_STATUS_FAILED), GetCronStatus(CRON_STATUS_STARTING), GetCronStatus(CRON_STATUS_RUNNING));
 
-	scanDescriptor = systable_beginscan(jobRunDetailTable, InvalidOid, false,
-                                                                              NULL, 0, NULL);
-	tupleDescriptor = RelationGetDescr(jobRunDetailTable);
 
-	while (HeapTupleIsValid(heapTuple = systable_getnext(scanDescriptor)))
-	{
-		HeapTuple newtuple;
-		Datum status;
-		bool isNull;
-
-		status = heap_getattr(heapTuple, Anum_job_run_details_status, tupleDescriptor, &isNull);
-
-		if (!isNull &&
-			strcmp("starting", TextDatumGetCString(status)) != 0 &&
-			strcmp("running", TextDatumGetCString(status)) != 0)
-			continue;
-
-		newtuple = heap_modify_tuple(heapTuple, tupleDescriptor, values, isNulls, repl);
-		#if PG_VERSION_NUM < 100000
-			simple_heap_update(jobRunDetailTable, &newtuple->t_self, newtuple);
-			CatalogUpdateIndexes(jobRunDetailTable, newtuple);
-		#else
-			CatalogTupleUpdate(jobRunDetailTable, &newtuple->t_self, newtuple);
-		#endif
-		heap_freetuple(newtuple);
-	}
+	pgstat_report_activity(STATE_RUNNING, querybuf.data);
 
-	systable_endscan(scanDescriptor);
-	table_close(jobRunDetailTable, NoLock);
+	if (SPI_exec(querybuf.data, 0) != SPI_OK_UPDATE)
+		elog(ERROR, "SPI_exec failed: %s", querybuf.data);
+
+	pfree(querybuf.data);
 
+	SPI_finish();
 	PopActiveSnapshot();
 	CommitTransactionCommand();
+	pgstat_report_activity(STATE_IDLE, NULL);
+}
+
+char *
+GetCronStatus(CronStatus cronstatus)
+{
+	char *statusDesc = "unknown status";
+
+	switch (cronstatus)
+	{
+	case CRON_STATUS_STARTING:
+		statusDesc = "starting";
+		break;
+	case CRON_STATUS_RUNNING:
+		statusDesc = "running";
+		break;
+	case CRON_STATUS_SENDING:
+		statusDesc = "sending";
+		break;
+	case CRON_STATUS_CONNECTING:
+		statusDesc = "connecting";
+		break;
+	case CRON_STATUS_SUCCEEDED:
+		statusDesc = "succeeded";
+		break;
+	case CRON_STATUS_FAILED:
+		statusDesc = "failed";
+		break;
+	default:
+		break;
+	}
+	return statusDesc;
 }
diff --git a/src/pg_cron.c b/src/pg_cron.c
index db2ceef..3ccf6a6 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -132,11 +132,13 @@ static bool CanStartTask(CronTask *task);
 static void ManageCronTasks(List *taskList, TimestampTz currentTime);
 static void ManageCronTask(CronTask *task, TimestampTz currentTime);
 static void ExecuteSqlString(const char *sql);
-static void GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task);
+static void GetTaskFeedback(PGresult *result, CronTask *task);
+static void GetBgwTaskFeedback(shm_mq_handle *responseq, CronTask *task);
 
 static bool jobCanceled(CronTask *task);
 static bool jobStartupTimeout(CronTask *task, TimestampTz currentTime);
 static char* pg_cron_cmdTuples(char *msg);
+static void bgw_generate_returned_message(StringInfoData *display_msg, ErrorData edata);
 
 /* global settings */
 char *CronTableDatabaseName = "postgres";
@@ -205,18 +207,6 @@ _PG_init(void)
 		GUC_SUPERUSER_ONLY,
 		NULL, NULL, NULL);
 
-	DefineCustomIntVariable(
-		"cron.max_running_jobs",
-		gettext_noop("Maximum number of jobs that can run concurrently."),
-		NULL,
-		&MaxRunningTasks,
-		32,
-		0,
-		MaxConnections,
-		PGC_POSTMASTER,
-		GUC_SUPERUSER_ONLY,
-		NULL, NULL, NULL);
-
 	DefineCustomStringVariable(
 		"cron.host",
 		gettext_noop("Hostname to connect to postgres."),
@@ -237,6 +227,31 @@ _PG_init(void)
 		GUC_SUPERUSER_ONLY,
 		NULL, NULL, NULL);
 
+	if (!UseBackgroundWorkers)
+		DefineCustomIntVariable(
+			"cron.max_running_jobs",
+			gettext_noop("Maximum number of jobs that can run concurrently."),
+			NULL,
+			&MaxRunningTasks,
+			32,
+			0,
+			MaxConnections,
+			PGC_POSTMASTER,
+			GUC_SUPERUSER_ONLY,
+			NULL, NULL, NULL);
+	else
+		DefineCustomIntVariable(
+			"cron.max_running_jobs",
+			gettext_noop("Maximum number of jobs that can run concurrently."),
+			NULL,
+			&MaxRunningTasks,
+			5,
+			0,
+			max_worker_processes - 1,
+			PGC_POSTMASTER,
+			GUC_SUPERUSER_ONLY,
+			NULL, NULL, NULL);
+
 	/* set up common data for all our workers */
 	worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
 	worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
@@ -346,6 +361,65 @@ interpret_error:
         return "";
 }
 
+/*
+ * bgw_generate_returned_message -
+ *      generates the message to be inserted into the job_run_details table
+ *      first part is comming from error_severity (elog.c)
+ */
+static void
+bgw_generate_returned_message(StringInfoData *display_msg, ErrorData edata)
+{
+	const char *prefix;
+
+	switch (edata.elevel)
+	{
+		case DEBUG1:
+		case DEBUG2:
+		case DEBUG3:
+		case DEBUG4:
+		case DEBUG5:
+			prefix = gettext_noop("DEBUG");
+			break;
+		case LOG:
+#if (PG_VERSION_NUM >= 100000)
+		case LOG_SERVER_ONLY:
+#endif
+			prefix = gettext_noop("LOG");
+			break;
+		case INFO:
+			prefix = gettext_noop("INFO");
+			break;
+		case NOTICE:
+			prefix = gettext_noop("NOTICE");
+			break;
+		case WARNING:
+			prefix = gettext_noop("WARNING");
+			break;
+		case ERROR:
+			prefix = gettext_noop("ERROR");
+			break;
+		case FATAL:
+			prefix = gettext_noop("FATAL");
+			break;
+		case PANIC:
+			prefix = gettext_noop("PANIC");
+			break;
+		default:
+			prefix = "???";
+			break;
+	}
+
+	appendStringInfo(display_msg, "%s: %s", prefix, edata.message);
+	if (edata.detail != NULL)
+		appendStringInfo(display_msg, "\nDETAIL: %s", edata.detail);
+
+	if (edata.hint != NULL)
+		appendStringInfo(display_msg, "\nHINT: %s", edata.hint);
+
+	if (edata.context != NULL)
+		appendStringInfo(display_msg, "\nCONTEXT: %s", edata.context);
+}
+
 /*
  * Signal handler for SIGTERM for background workers
  * 		When we receive a SIGTERM, we set InterruptPending and ProcDiePending
@@ -402,7 +476,7 @@ PgCronLauncherMain(Datum arg)
 	 * Mark anything that was in progress before the database restarted as
 	 * failed.
 	 */
-	CleanAuditTable();
+	MarkPendingRunsAsFailed();
 
 	/* Determine how many tasks we can run concurrently */
 	if (MaxConnections < MaxRunningTasks)
@@ -421,6 +495,11 @@ PgCronLauncherMain(Datum arg)
 		MaxRunningTasks = limit.rlim_cur;
 	}
 
+	if (UseBackgroundWorkers && max_worker_processes - 1 < MaxRunningTasks)
+	{
+		MaxRunningTasks = max_worker_processes - 1;
+	}
+
 	if (MaxRunningTasks <= 0)
 	{
 		MaxRunningTasks = 1;
@@ -1028,7 +1107,6 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 	CronJob *cronJob = GetCronJob(jobId);
 	PGconn *connection = task->connection;
 	ConnStatusType connectionStatus = CONNECTION_BAD;
-	bool result;
 	TimestampTz start_time;
 
 	switch (checkState)
@@ -1057,21 +1135,14 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			RunningTaskCount++;
 
 			/* Add new entry to audit table. */
-			SetCurrentStatementStartTimestamp();
-			StartTransactionCommand();
-			PushActiveSnapshot(GetTransactionSnapshot());
 			task->runId = NextRunId();
 			PopActiveSnapshot();
 			CommitTransactionCommand();
 			if (CronLogRun)
-			{
-				result = InsertOrUpdateJobRunDetail(task->runId, &cronJob->jobId,
-												NULL, cronJob->database,
-												cronJob->userName,
-												cronJob->command, "starting",
-												NULL, NULL, NULL);
-				Assert(result);
-			}
+				InsertJobRunDetail(task->runId, &cronJob->jobId,
+										cronJob->database,
+										cronJob->userName,
+										cronJob->command, GetCronStatus(CRON_STATUS_STARTING));
 		}
 
 		case CRON_TASK_START:
@@ -1111,8 +1182,8 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				{
 					char *command = cronJob->command;
 
-					ereport(LOG, (errmsg("cron job " INT64_FORMAT " starting: %s",
-									 jobId, command)));
+					ereport(LOG, (errmsg("cron job " INT64_FORMAT " %s: %s",
+									 jobId, GetCronStatus(CRON_STATUS_STARTING), command)));
 				}
 
 				connection = PQconnectStartParams(keywordArray, valueArray, false);
@@ -1139,12 +1210,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				task->state = CRON_TASK_CONNECTING;
 
 				if (CronLogRun)
-				{
-					result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
-												NULL, NULL, "connecting", NULL,
-												NULL, NULL);
-					Assert(result);
-				}
+					UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_CONNECTING), NULL, NULL, NULL);
 
 				break;
 			}
@@ -1165,6 +1231,8 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			Size segsize;
 			BackgroundWorkerHandle *handle;
 			BgwHandleStatus status;
+			bool registered;
+			TimestampTz startDeadline = 0;
 
 			/* break in the previous case has not been reached
 			 * checking just for extra precaution
@@ -1198,6 +1266,9 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				task->errorMessage = "unable to create a DSM segment; more "
 								"details may be available in the server log";
 
+				ereport(WARNING,
+					(errmsg("max number of DSM segments may has been reached")));
+
 				break;
 			}
 
@@ -1225,6 +1296,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			 * there trying to write the queue long after we've gone away.)
 			 */
 			oldcontext = MemoryContextSwitchTo(TopMemoryContext);
+			shm_mq_attach(mq, task->seg, NULL);
 			MemoryContextSwitchTo(oldcontext);
 
 			/*
@@ -1249,19 +1321,37 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			 */
 			if (CronLogStatement)
 			{
-				ereport(LOG, (errmsg("cron job " INT64_FORMAT " starting: %s",
-										 jobId, command)));
+				ereport(LOG, (errmsg("cron job " INT64_FORMAT " %s: %s",
+										 jobId, GetCronStatus(CRON_STATUS_STARTING), command)));
+			}
+
+			/* If no no background worker slots are currently available
+			 * let's try until we reach jobStartupTimeout
+			 */
+			startDeadline = TimestampTzPlusMilliseconds(currentTime,
+										CronTaskStartTimeout);
+			task->startDeadline = startDeadline;
+			do
+			{
+				registered = RegisterDynamicBackgroundWorker(&worker, &handle);
 			}
-			if (!RegisterDynamicBackgroundWorker(&worker, &handle))
+			while (!registered && !jobStartupTimeout(task, GetCurrentTimestamp()));
+
+			if (!registered)
 			{
 				dsm_detach(task->seg);
 				task->seg = NULL;
 				task->state = CRON_TASK_ERROR;
 				task->errorMessage = "could not start background process; more "
 									 "details may be available in the server log";
+				ereport(WARNING,
+					(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),
+					errmsg("out of background worker slots"),
+					errhint("You might need to increase max_worker_processes.")));
 				break;
 			}
 
+			task->startDeadline = 0;
 			task->handle = *handle;
 			status = WaitForBackgroundWorkerStartup(&task->handle, &pid);
 			if (status != BGWH_STARTED && status != BGWH_STOPPED)
@@ -1277,12 +1367,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			start_time = GetCurrentTimestamp();
 
 			if (CronLogRun)
-			{
-				result = InsertOrUpdateJobRunDetail(task->runId, NULL, &pid, NULL,
-												NULL, NULL, "running", NULL,
-												&start_time, NULL);
-				Assert(result);
-			}
+				UpdateJobRunDetail(task->runId, &pid, GetCronStatus(CRON_STATUS_RUNNING), NULL, &start_time, NULL);
 
 			task->state = CRON_TASK_BGW_RUNNING;
 			break;
@@ -1330,9 +1415,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 				pid = (pid_t) PQbackendPID(connection);
 				if (CronLogRun)
-					result = InsertOrUpdateJobRunDetail(task->runId, NULL, &pid, NULL,
-													NULL, NULL, "sending", NULL,
-													NULL, NULL);
+					UpdateJobRunDetail(task->runId, &pid, GetCronStatus(CRON_STATUS_SENDING), NULL, NULL, NULL);
 			}
 			else if (pollingStatus == PGRES_POLLING_FAILED)
 			{
@@ -1398,12 +1481,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 				start_time = GetCurrentTimestamp();
 				if (CronLogRun)
-				{
-					result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
-													NULL, NULL, "running", NULL,
-													&start_time, NULL);
-					Assert(result);
-				}
+					UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_RUNNING), NULL, &start_time, NULL);
 			}
 			else
 			{
@@ -1450,7 +1528,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 			while ((result = PQgetResult(connection)) != NULL)
 			{
-				GetTaskFeedback(NULL, result, task);
+				GetTaskFeedback(result, task);
 			}
 
 			PQfinish(connection);
@@ -1478,7 +1556,6 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			{
 				TerminateBackgroundWorker(&task->handle);
 				WaitForBackgroundWorkerShutdown(&task->handle);
-				dsm_unpin_mapping(task->seg);
 				dsm_detach(task->seg);
 				task->seg = NULL;
 
@@ -1496,9 +1573,11 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				mq = shm_toc_lookup(toc, PG_CRON_KEY_QUEUE, false);
 			#endif
 			responseq = shm_mq_attach(mq, task->seg, NULL);
-			GetTaskFeedback(responseq, NULL, task);
+			GetBgwTaskFeedback(responseq, task);
 
 			task->state = CRON_TASK_DONE;
+			dsm_detach(task->seg);
+			task->seg = NULL;
 			RunningTaskCount--;
 
 			break;
@@ -1506,8 +1585,6 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 		case CRON_TASK_ERROR:
 		{
-			bool update_result;
-
 			if (connection != NULL)
 			{
 				PQfinish(connection);
@@ -1522,12 +1599,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			if (task->errorMessage != NULL)
 			{
 				if (CronLogRun)
-				{
-					update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
-												NULL, NULL, "failed",
-												task->errorMessage, NULL, NULL);
-					Assert(update_result);
-				}
+					UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_FAILED), task->errorMessage, NULL, NULL);
 
 				ereport(LOG, (errmsg("cron job " INT64_FORMAT " %s",
 									 jobId, task->errorMessage)));
@@ -1540,7 +1612,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			}
 			else
 			{
-				ereport(LOG, (errmsg("cron job " INT64_FORMAT " failed", jobId)));
+				ereport(LOG, (errmsg("cron job " INT64_FORMAT " %s", jobId, GetCronStatus(CRON_STATUS_FAILED))));
 			}
 
 			task->startDeadline = 0;
@@ -1549,9 +1621,6 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 			RunningTaskCount--;
 
-			/* keep compiler quiet */
-			(void) update_result;
-
 			/* fall through to CRON_TASK_DONE */
 		}
 
@@ -1560,32 +1629,129 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 		{
 			InitializeCronTask(task, jobId);
 		}
-
-	/* keep compiler quiet */
-	(void) result;
 	}
 }
 
 static void
-GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task)
+GetTaskFeedback(PGresult *result, CronTask *task)
 {
 
 	TimestampTz end_time;
-	bool update_result;
+	ExecStatusType executionStatus;
 
 	end_time = GetCurrentTimestamp();
+	executionStatus = PQresultStatus(result);
 
-	if (responseq) {
-		Size            nbytes;
-		void       *data;
-		char            msgtype;
-		StringInfoData  msg;
+	switch (executionStatus)
+	{
+		case PGRES_COMMAND_OK:
+		{
+			char *cmdStatus = PQcmdStatus(result);
+			char *cmdTuples = PQcmdTuples(result);
 
-		/*
-		 * Message-parsing routines operate on a null-terminated StringInfo,
-		 * so we must construct one.
-		 */
-		shm_mq_receive(responseq, &nbytes, &data, false);
+			if (CronLogRun)
+				UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_SUCCEEDED), cmdStatus, NULL, &end_time);
+
+			if (CronLogStatement)
+			{
+				ereport(LOG, (errmsg("cron job " INT64_FORMAT " COMMAND completed: %s %s",
+									 task->jobId, cmdStatus, cmdTuples)));
+			}
+
+			break;
+		}
+
+		case PGRES_BAD_RESPONSE:
+		case PGRES_FATAL_ERROR:
+		{
+			task->errorMessage = strdup(PQresultErrorMessage(result));
+			task->freeErrorMessage = true;
+			task->pollingStatus = 0;
+			task->state = CRON_TASK_ERROR;
+
+			if (CronLogRun)
+				UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_FAILED), task->errorMessage, NULL, &end_time);
+
+			PQclear(result);
+
+			return;
+		}
+
+		case PGRES_COPY_IN:
+		case PGRES_COPY_OUT:
+		case PGRES_COPY_BOTH:
+		{
+			/* cannot handle COPY input/output */
+			task->errorMessage = "COPY not supported";
+			task->pollingStatus = 0;
+			task->state = CRON_TASK_ERROR;
+
+			if (CronLogRun)
+				UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_FAILED), task->errorMessage, NULL, &end_time);
+
+			PQclear(result);
+
+			return;
+		}
+
+		case PGRES_TUPLES_OK:
+		case PGRES_EMPTY_QUERY:
+		case PGRES_SINGLE_TUPLE:
+		case PGRES_NONFATAL_ERROR:
+		default:
+		{
+			int tupleCount = PQntuples(result);
+			char *rowString = ngettext("row", "rows",
+										   tupleCount);
+			char  rows[MAXINT8LEN + 1];
+			char  outputrows[MAXINT8LEN + 4 + 1];
+
+			pg_lltoa(tupleCount, rows);
+			snprintf(outputrows, sizeof(outputrows), "%s %s", rows, rowString);
+
+			if (CronLogRun)
+				UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_SUCCEEDED), outputrows, NULL, &end_time);
+
+			if (CronLogStatement)
+			{
+				ereport(LOG, (errmsg("cron job " INT64_FORMAT " completed: "
+									 "%d %s",
+									 task->jobId, tupleCount,
+									 rowString)));
+			}
+
+			break;
+		}
+
+	}
+
+	PQclear(result);
+}
+
+static void
+GetBgwTaskFeedback(shm_mq_handle *responseq, CronTask *task)
+{
+
+	TimestampTz end_time;
+
+	Size            nbytes;
+	void       *data;
+	char            msgtype;
+	StringInfoData  msg;
+	shm_mq_result res;
+
+	end_time = GetCurrentTimestamp();
+	/*
+	 * Message-parsing routines operate on a null-terminated StringInfo,
+	 * so we must construct one.
+	 */
+	for (;;)
+	{
+		/* Get next message. */
+		res = shm_mq_receive(responseq, &nbytes, &data, false);
+
+		if (res != SHM_MQ_SUCCESS)
+			break;
 		initStringInfo(&msg);
 		resetStringInfo(&msg);
 		enlargeStringInfo(&msg, nbytes);
@@ -1595,38 +1761,30 @@ GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task)
 		msgtype = pq_getmsgbyte(&msg);
 		switch (msgtype)
 		{
+			case 'N':
 			case 'E':
 				{
 					ErrorData	edata;
+					StringInfoData  display_msg;
+
 					pq_parse_errornotice(&msg, &edata);
+					initStringInfo(&display_msg);
+					bgw_generate_returned_message(&display_msg, edata);
 
 					if (CronLogRun)
 					{
-						update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
-												NULL, NULL, "failed", edata.message,
-												NULL, &end_time);
-						Assert(update_result);
-					}
 
-					ereport(LOG, (errmsg("cron job " INT64_FORMAT " ERROR: %s",
-									 task->jobId, edata.message)));
-					break;
-				}
-			case 'N':
-				{
-					ErrorData	edata;
-					pq_parse_errornotice(&msg, &edata);
+						if (edata.elevel >= ERROR)
+							UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_FAILED), display_msg.data, NULL, &end_time);
+						else
+							UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_SUCCEEDED), display_msg.data, NULL, &end_time);
 
-					if (CronLogRun)
-					{
-						update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
-												NULL, NULL, "failed", edata.message,
-												NULL, &end_time);
-						Assert(update_result);
 					}
 
-					ereport(LOG, (errmsg("cron job " INT64_FORMAT " NOTICE: %s",
-									 task->jobId, edata.message)));
+					ereport(LOG, (errmsg("cron job " INT64_FORMAT ": %s",
+									 task->jobId, display_msg.data)));
+					pfree(display_msg.data);
+
 					break;
 				}
 			case 'T':
@@ -1640,12 +1798,7 @@ GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task)
 					nonconst_tag = strdup(tag);
 
 					if (CronLogRun)
-					{
-						update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
-												NULL, NULL, "succeeded", nonconst_tag,
-												NULL, &end_time);
-						Assert(update_result);
-					}
+						UpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_SUCCEEDED), nonconst_tag, NULL, &end_time);
 
 					if (CronLogStatement) {
 						cmdTuples = pg_cron_cmdTuples(nonconst_tag);
@@ -1668,119 +1821,8 @@ GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task)
 						 msg.data[0], nbytes);
 					break;
 		}
-	} else {
-
-			ExecStatusType executionStatus = PQresultStatus(result);
-			switch (executionStatus)
-			{
-				case PGRES_COMMAND_OK:
-				{
-					char *cmdStatus = PQcmdStatus(result);
-					char *cmdTuples = PQcmdTuples(result);
-
-					if (CronLogRun)
-					{
-
-						update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
-												NULL, NULL, "succeeded", cmdStatus,
-												NULL, &end_time);
-						Assert(update_result);
-					}
-
-					if (CronLogStatement)
-					{
-						ereport(LOG, (errmsg("cron job " INT64_FORMAT " COMMAND completed: %s %s",
-											 task->jobId, cmdStatus, cmdTuples)));
-					}
-
-					break;
-				}
-
-				case PGRES_BAD_RESPONSE:
-				case PGRES_FATAL_ERROR:
-				{
-					task->errorMessage = strdup(PQresultErrorMessage(result));
-					task->freeErrorMessage = true;
-					task->pollingStatus = 0;
-					task->state = CRON_TASK_ERROR;
-
-					if (CronLogRun)
-					{
-						update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
-												NULL, NULL, "failed", task->errorMessage,
-												NULL, &end_time);
-
-						Assert(update_result);
-					}
-
-					PQclear(result);
-
-					return;
-				}
-
-				case PGRES_COPY_IN:
-				case PGRES_COPY_OUT:
-				case PGRES_COPY_BOTH:
-				{
-					/* cannot handle COPY input/output */
-					task->errorMessage = "COPY not supported";
-					task->pollingStatus = 0;
-					task->state = CRON_TASK_ERROR;
-
-					if (CronLogRun)
-					{
-						update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
-												NULL, NULL, "failed", task->errorMessage,
-												NULL, &end_time);
-
-						Assert(update_result);
-					}
-
-					PQclear(result);
-
-					return;
-				}
-
-				case PGRES_TUPLES_OK:
-				case PGRES_EMPTY_QUERY:
-				case PGRES_SINGLE_TUPLE:
-				case PGRES_NONFATAL_ERROR:
-				default:
-				{
-					int tupleCount = PQntuples(result);
-					char *rowString = ngettext("row", "rows",
-										   tupleCount);
-					char  rows[MAXINT8LEN + 1];
-					char  outputrows[MAXINT8LEN + 4 + 1];
-
-					pg_lltoa(tupleCount, rows);
-					snprintf(outputrows, sizeof(outputrows), "%s %s", rows, rowString);
-
-					if (CronLogRun)
-					{
-						update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
-												NULL, NULL, "succeeded", outputrows,
-												NULL, &end_time);
-						Assert(update_result);
-					}
-
-					if (CronLogStatement)
-					{
-						ereport(LOG, (errmsg("cron job " INT64_FORMAT " completed: "
-											 "%d %s",
-											 task->jobId, tupleCount,
-											 rowString)));
-					}
-
-					break;
-				}
-
-			}
-
-			PQclear(result);
+		pfree(msg.data);
 	}
-	/* keep compiler quiet */
-	(void) update_result;
 }
 
 /*
@@ -2074,19 +2116,18 @@ jobCanceled(CronTask *task)
 /*
  * If a task has hit it's startup deadline, set an appropriate error state on
  * the task and return true. Note that this should only be called after a task
- * has already been launched. It's not used when UseBackgroundWorkers is true
- * (if that were to change the error message wouldn't make sense).
+ * has already been launched.
  */
 static bool
 jobStartupTimeout(CronTask *task, TimestampTz currentTime)
 {
-    Assert(!UseBackgroundWorkers);
     Assert(task->state == CRON_TASK_CONNECTING || \
-            task->state == CRON_TASK_SENDING);
+            task->state == CRON_TASK_SENDING || \
+            task->state == CRON_TASK_BGW_START);
 
     if (TimestampDifferenceExceeds(task->startDeadline, currentTime, 0))
     {
-        task->errorMessage = "connection timeout";
+        task->errorMessage = "job startup timeout";
         task->pollingStatus = 0;
         task->state = CRON_TASK_ERROR;
         return true;

COMMIT_HASH:44ae64b1467dfe29beffd3082098571e67054d0a|AUTHOR_NAME:bdt|AUTHOR_EMAIL:bdt|DATE:2020-08-26 06:51:22 +0000|TITLE:renamed bgworker scheduler to launcher|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index f440b8e..db2ceef 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -113,7 +113,7 @@ void _PG_fini(void);
 static void pg_cron_sigterm(SIGNAL_ARGS);
 static void pg_cron_sighup(SIGNAL_ARGS);
 static void pg_cron_background_worker_sigterm(SIGNAL_ARGS);
-void PgCronWorkerMain(Datum arg);
+void PgCronLauncherMain(Datum arg);
 void CronBackgroundWorker(Datum arg);
 
 static void StartAllPendingRuns(List *taskList, TimestampTz currentTime);
@@ -242,15 +242,15 @@ _PG_init(void)
 	worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
 	worker.bgw_restart_time = 1;
 #if (PG_VERSION_NUM < 100000)
-	worker.bgw_main = PgCronWorkerMain;
+	worker.bgw_main = PgCronLauncherMain;
 #endif
 	worker.bgw_main_arg = Int32GetDatum(0);
 	worker.bgw_notify_pid = 0;
 	sprintf(worker.bgw_library_name, "pg_cron");
-	sprintf(worker.bgw_function_name, "PgCronWorkerMain");
-	snprintf(worker.bgw_name, BGW_MAXLEN, "pg_cron scheduler");
+	sprintf(worker.bgw_function_name, "PgCronLauncherMain");
+	snprintf(worker.bgw_name, BGW_MAXLEN, "pg_cron launcher");
 #if (PG_VERSION_NUM >= 110000)
-	snprintf(worker.bgw_type, BGW_MAXLEN, "pg_cron scheduler");
+	snprintf(worker.bgw_type, BGW_MAXLEN, "pg_cron launcher");
 #endif
 
 	RegisterBackgroundWorker(&worker);
@@ -371,11 +371,11 @@ pg_cron_background_worker_sigterm(SIGNAL_ARGS)
 
 
 /*
- * PgCronWorkerMain is the main entry-point for the background worker
+ * PgCronLauncherMain is the main entry-point for the background worker
  * that performs tasks.
  */
 void
-PgCronWorkerMain(Datum arg)
+PgCronLauncherMain(Datum arg)
 {
 	MemoryContext CronLoopContext = NULL;
 	struct rlimit limit;

COMMIT_HASH:4c84cccc57e323f89f23eb1103ff6f00b0f6b3dd|AUTHOR_NAME:bdt|AUTHOR_EMAIL:bdt|DATE:2020-08-26 06:49:49 +0000|TITLE:job and task wording|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index f469af3..f440b8e 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -3,6 +3,9 @@
  * src/pg_cron.c
  *
  * Implementation of the pg_cron task scheduler.
+ * Wording:
+ *	   - A job is a scheduling definition of a task
+ *	   - A task is what is actually executed within the database engine
  *
  * Copyright (c) 2016, Citus Data, Inc.
  *

COMMIT_HASH:745c0c3f39b204159cffa21c645958e03e0de4d4|AUTHOR_NAME:bdt|AUTHOR_EMAIL:bdt|DATE:2020-08-26 06:49:27 +0000|TITLE:audit table support|MESSAGE:
diff --git a/Makefile b/Makefile
index a4f20ae..13c02b6 100644
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,7 @@
 # src/test/modules/pg_cron/Makefile
 
 EXTENSION = pg_cron
-EXTVERSION = 1.2
+EXTVERSION = 1.3
 
 DATA_built = $(EXTENSION)--1.0.sql
 DATA = $(wildcard $(EXTENSION)--*--*.sql)
diff --git a/include/cron_job.h b/include/cron_job.h
index 638db76..8eb6b5e 100644
--- a/include/cron_job.h
+++ b/include/cron_job.h
@@ -51,5 +51,34 @@ typedef FormData_cron_job *Form_cron_job;
 #define Anum_cron_job_username 7
 #define Anum_cron_job_active 8
 
+typedef struct FormData_job_run_details
+{
+	int64 jobId;
+	int64 runId;
+	int32 job_pid;
+#ifdef CATALOG_VARLEN
+	text database;
+	text username;
+	text command;
+	text status;
+	text return_message;
+	timestamptz start_time;
+	timestamptz end_time;
+#endif
+} FormData_job_run_details;
+
+typedef FormData_job_run_details *Form_job_run_details;
+
+#define Natts_job_run_details 10
+#define Anum_job_run_details_jobid 1
+#define Anum_job_run_details_runid 2
+#define Anum_job_run_details_job_pid 3
+#define Anum_job_run_details_database 4
+#define Anum_job_run_details_username 5
+#define Anum_job_run_details_command 6
+#define Anum_job_run_details_status 7
+#define Anum_job_run_details_return_message 8
+#define Anum_job_run_details_start_time 9
+#define Anum_job_run_details_end_time 10
 
 #endif /* CRON_JOB_H */
diff --git a/include/job_metadata.h b/include/job_metadata.h
index 1413ae1..9f4df8a 100644
--- a/include/job_metadata.h
+++ b/include/job_metadata.h
@@ -44,5 +44,11 @@ extern void ResetJobMetadataCache(void);
 extern List * LoadCronJobList(void);
 extern CronJob * GetCronJob(int64 jobId);
 
+extern bool InsertOrUpdateJobRunDetail(int64 runId, int64 *jobId, int32 *job_pid,
+									char *database, char *username, char *command,
+									char *status, char *return_message, TimestampTz *start_time,
+									TimestampTz *end_time);
+extern int64 NextRunId(void);
+extern void CleanAuditTable(void);
 
 #endif
diff --git a/pg_cron--1.2--1.3.sql b/pg_cron--1.2--1.3.sql
new file mode 100644
index 0000000..611fcb8
--- /dev/null
+++ b/pg_cron--1.2--1.3.sql
@@ -0,0 +1,22 @@
+/* pg_cron--1.2--1.3.sql */
+
+CREATE SEQUENCE cron.runid_seq;
+CREATE TABLE cron.job_run_details (
+	jobid bigint,
+	runid bigint primary key default nextval('cron.runid_seq'),
+	job_pid integer,
+	database text,
+	username text,
+	command text,
+	status text,
+	return_message text,
+	start_time timestamptz,
+	end_time timestamptz
+);
+
+GRANT SELECT ON cron.job_run_details TO public;
+ALTER TABLE cron.job_run_details ENABLE ROW LEVEL SECURITY;
+CREATE POLICY cron_job_run_details_policy ON cron.job_run_details USING (username = current_user);
+
+SELECT pg_catalog.pg_extension_config_dump('cron.job_run_details', '');
+SELECT pg_catalog.pg_extension_config_dump('cron.runid_seq', '');
diff --git a/pg_cron.control b/pg_cron.control
index cb469f9..5f63843 100644
--- a/pg_cron.control
+++ b/pg_cron.control
@@ -1,4 +1,4 @@
 comment = 'Job scheduler for PostgreSQL'
-default_version = '1.2'
+default_version = '1.3'
 module_pathname = '$libdir/pg_cron'
 relocatable = false
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 3a9d0f1..3405dce 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -58,6 +58,9 @@
 #define JOBS_TABLE_NAME "job"
 #define JOB_ID_INDEX_NAME "job_pkey"
 #define JOB_ID_SEQUENCE_NAME "cron.jobid_seq"
+#define JOB_RUN_DETAILS_TABLE_NAME "job_run_details"
+#define RUN_ID_SEQUENCE_NAME "cron.runid_seq"
+#define JOB_RUN_DETAILS_INDEX_NAME "job_run_details_pkey"
 
 
 /* forward declarations */
@@ -68,6 +71,7 @@ static Oid CronExtensionOwner(void);
 static void InvalidateJobCacheCallback(Datum argument, Oid relationId);
 static void InvalidateJobCache(void);
 static Oid CronJobRelationId(void);
+static Oid JobRunDetailsRelationId(void);
 
 static CronJob * TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple);
 static bool PgCronHasBeenLoaded(void);
@@ -85,6 +89,7 @@ static HTAB *CronJobHash = NULL;
 static Oid CachedCronJobRelationId = InvalidOid;
 bool CronJobCacheValid = false;
 char *CronHost = "localhost";
+static Oid CachedJobRunDetailsRelationId = InvalidOid;
 
 
 /*
@@ -275,6 +280,39 @@ NextJobId(void)
 	return jobId;
 }
 
+int64
+NextRunId(void)
+{
+	text *sequenceName = NULL;
+	Oid sequenceId = InvalidOid;
+	List *sequenceNameList = NIL;
+	RangeVar *sequenceVar = NULL;
+	Datum sequenceIdDatum = InvalidOid;
+	Oid savedUserId = InvalidOid;
+	int savedSecurityContext = 0;
+	Datum jobIdDatum = 0;
+	int64 jobId = 0;
+	bool failOK = true;
+
+	/* resolve relationId from passed in schema and relation name */
+	sequenceName = cstring_to_text(RUN_ID_SEQUENCE_NAME);
+	sequenceNameList = textToQualifiedNameList(sequenceName);
+	sequenceVar = makeRangeVarFromNameList(sequenceNameList);
+	sequenceId = RangeVarGetRelid(sequenceVar, NoLock, failOK);
+	sequenceIdDatum = ObjectIdGetDatum(sequenceId);
+
+	GetUserIdAndSecContext(&savedUserId, &savedSecurityContext);
+	SetUserIdAndSecContext(CronExtensionOwner(), SECURITY_LOCAL_USERID_CHANGE);
+
+	/* generate new and unique colocation id from sequence */
+	jobIdDatum = DirectFunctionCall1(nextval_oid, sequenceIdDatum);
+
+	SetUserIdAndSecContext(savedUserId, savedSecurityContext);
+
+	jobId = DatumGetInt64(jobIdDatum);
+
+	return jobId;
+}
 
 /*
  * CronExtensionOwner returns the name of the user that owns the
@@ -467,6 +505,18 @@ CronJobRelationId(void)
 	return CachedCronJobRelationId;
 }
 
+static Oid
+JobRunDetailsRelationId(void)
+{
+	if (CachedJobRunDetailsRelationId == InvalidOid)
+	{
+		Oid cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
+
+		CachedJobRunDetailsRelationId = get_relname_relid(JOB_RUN_DETAILS_TABLE_NAME, cronSchemaId);
+	}
+
+	return CachedJobRunDetailsRelationId;
+}
 
 /*
  * LoadCronJobList loads the current list of jobs from the
@@ -650,3 +700,238 @@ PgCronHasBeenLoaded(void)
 
 	return extensionLoaded;
 }
+
+bool
+InsertOrUpdateJobRunDetail(int64 runId, int64 *jobId, int32 *job_pid,
+								char *database, char *username, char *command,
+								char *status, char *return_message, TimestampTz *start_time,
+								TimestampTz *end_time)
+{
+	Relation jobRunDetailTable;
+	SysScanDesc scanDescriptor;
+	ScanKeyData scanKey[1];
+	HeapTuple heapTuple;
+	TupleDesc tupleDescriptor;
+	Datum values[Natts_job_run_details];
+	bool isNulls[Natts_job_run_details];
+	bool repl[Natts_job_run_details];
+	Oid schemaId;
+	Oid indexId;
+
+	SetCurrentStatementStartTimestamp();
+	StartTransactionCommand();
+	PushActiveSnapshot(GetTransactionSnapshot());
+
+	/*
+	 * If the pg_job_scheduler extension has not been created yet or
+	 * we are on a hot standby, the job table is treated as
+	 * being empty.
+	 */
+	if (!PgCronHasBeenLoaded() || RecoveryInProgress())
+	{
+		PopActiveSnapshot();
+		CommitTransactionCommand();
+		pgstat_report_activity(STATE_IDLE, NULL);
+		return false;
+	}
+
+	memset(values, 0, sizeof(values));
+	memset(isNulls, false, sizeof(isNulls));
+	memset(repl, false, sizeof(repl));
+
+	values[Anum_job_run_details_runid - 1] = Int64GetDatum(runId);
+
+	if (jobId == NULL)
+		isNulls[Anum_job_run_details_jobid - 1] = true;
+	else
+	{
+		values[Anum_job_run_details_jobid - 1] = Int64GetDatum(*jobId);
+		repl[Anum_job_run_details_jobid - 1] = true;
+	}
+
+	if (job_pid == NULL)
+		isNulls[Anum_job_run_details_job_pid - 1] = true;
+	else
+	{
+		values[Anum_job_run_details_job_pid - 1] = Int32GetDatum(*job_pid);
+		repl[Anum_job_run_details_job_pid - 1] = true;
+	}
+
+	if (database == NULL)
+		isNulls[Anum_job_run_details_database - 1] = true;
+	else
+	{
+		values[Anum_job_run_details_database - 1] = CStringGetTextDatum(database);
+		repl[Anum_job_run_details_database - 1] = true;
+	}
+
+	if (username == NULL)
+		isNulls[Anum_job_run_details_username - 1] = true;
+	else
+	{
+		values[Anum_job_run_details_username - 1] = CStringGetTextDatum(username);
+		repl[Anum_job_run_details_username - 1] = true;
+	}
+
+	if (command == NULL)
+		isNulls[Anum_job_run_details_command - 1] = true;
+	else
+	{
+		values[Anum_job_run_details_command - 1] = CStringGetTextDatum(command);
+		repl[Anum_job_run_details_command - 1] = true;
+	}
+
+	if (status == NULL)
+		isNulls[Anum_job_run_details_status - 1] = true;
+	else
+	{
+		values[Anum_job_run_details_status - 1] = CStringGetTextDatum(status);
+		repl[Anum_job_run_details_status - 1] = true;
+	}
+
+	if (return_message == NULL)
+		isNulls[Anum_job_run_details_return_message - 1] = true;
+	else
+	{
+		values[Anum_job_run_details_return_message - 1] = CStringGetTextDatum(return_message);
+		repl[Anum_job_run_details_return_message - 1] = true;
+	}
+
+	if (start_time == NULL)
+		isNulls[Anum_job_run_details_start_time - 1] = true;
+	else
+	{
+		values[Anum_job_run_details_start_time - 1] = TimestampTzGetDatum(*start_time);
+		repl[Anum_job_run_details_start_time - 1] = true;
+	}
+
+	if (end_time == NULL)
+		isNulls[Anum_job_run_details_end_time - 1] = true;
+	else
+	{
+		values[Anum_job_run_details_end_time - 1] = TimestampTzGetDatum(*end_time);
+		repl[Anum_job_run_details_end_time - 1] = true;
+	}
+
+	schemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
+	indexId = get_relname_relid(JOB_RUN_DETAILS_INDEX_NAME, schemaId);
+
+	jobRunDetailTable = table_open(JobRunDetailsRelationId(), RowExclusiveLock);
+
+	ScanKeyInit(&scanKey[0], Anum_job_run_details_runid,
+							BTEqualStrategyNumber, F_INT8EQ, Int64GetDatum(runId));
+
+	scanDescriptor = systable_beginscan(jobRunDetailTable, indexId, true,
+									NULL, 1, scanKey);
+
+	tupleDescriptor = RelationGetDescr(jobRunDetailTable);
+
+	heapTuple = systable_getnext(scanDescriptor);
+	if (!HeapTupleIsValid(heapTuple))
+	{
+		heapTuple = heap_form_tuple(tupleDescriptor, values, isNulls);
+		#if PG_VERSION_NUM < 100000
+			simple_heap_insert(jobRunDetailTable, heapTuple);
+			CatalogUpdateIndexes(jobRunDetailTable, heapTuple);
+		#else
+			CatalogTupleInsert(jobRunDetailTable, heapTuple);
+		#endif
+		heap_freetuple(heapTuple);
+	}
+	else
+	{
+		HeapTuple newtuple;
+
+		newtuple = heap_modify_tuple(heapTuple, tupleDescriptor, values, isNulls, repl);
+		#if PG_VERSION_NUM < 100000
+			simple_heap_update(jobRunDetailTable, &newtuple->t_self, newtuple);
+			CatalogUpdateIndexes(jobRunDetailTable, newtuple);
+		#else
+			CatalogTupleUpdate(jobRunDetailTable, &newtuple->t_self, newtuple);
+		#endif
+		heap_freetuple(newtuple);
+	}
+
+	systable_endscan(scanDescriptor);
+	table_close(jobRunDetailTable, NoLock);
+
+	PopActiveSnapshot();
+	CommitTransactionCommand();
+
+	return true;
+}
+
+void
+CleanAuditTable(void)
+{
+	Relation jobRunDetailTable;
+	SysScanDesc scanDescriptor;
+	HeapTuple heapTuple;
+	TupleDesc tupleDescriptor;
+	Datum values[Natts_job_run_details];
+	bool isNulls[Natts_job_run_details];
+	bool repl[Natts_job_run_details];
+
+	SetCurrentStatementStartTimestamp();
+	StartTransactionCommand();
+	PushActiveSnapshot(GetTransactionSnapshot());
+
+	/*
+	 * If the pg_job_scheduler extension has not been created yet or
+	 * we are on a hot standby, the job table is treated as
+	 * being empty.
+	 */
+	if (!PgCronHasBeenLoaded() || RecoveryInProgress())
+	{
+		PopActiveSnapshot();
+		CommitTransactionCommand();
+		pgstat_report_activity(STATE_IDLE, NULL);
+		return;
+	}
+
+	memset(values, 0, sizeof(values));
+	memset(isNulls, false, sizeof(isNulls));
+	memset(repl, false, sizeof(repl));
+
+	values[Anum_job_run_details_status - 1] = CStringGetTextDatum("failed");
+	repl[Anum_job_run_details_status - 1] = true;
+
+	values[Anum_job_run_details_return_message - 1] = CStringGetTextDatum("server restarted");
+	repl[Anum_job_run_details_return_message - 1] = true;
+
+	get_namespace_oid(CRON_SCHEMA_NAME, false);
+	jobRunDetailTable = table_open(JobRunDetailsRelationId(), RowExclusiveLock);
+
+	scanDescriptor = systable_beginscan(jobRunDetailTable, InvalidOid, false,
+                                                                              NULL, 0, NULL);
+	tupleDescriptor = RelationGetDescr(jobRunDetailTable);
+
+	while (HeapTupleIsValid(heapTuple = systable_getnext(scanDescriptor)))
+	{
+		HeapTuple newtuple;
+		Datum status;
+		bool isNull;
+
+		status = heap_getattr(heapTuple, Anum_job_run_details_status, tupleDescriptor, &isNull);
+
+		if (!isNull &&
+			strcmp("starting", TextDatumGetCString(status)) != 0 &&
+			strcmp("running", TextDatumGetCString(status)) != 0)
+			continue;
+
+		newtuple = heap_modify_tuple(heapTuple, tupleDescriptor, values, isNulls, repl);
+		#if PG_VERSION_NUM < 100000
+			simple_heap_update(jobRunDetailTable, &newtuple->t_self, newtuple);
+			CatalogUpdateIndexes(jobRunDetailTable, newtuple);
+		#else
+			CatalogTupleUpdate(jobRunDetailTable, &newtuple->t_self, newtuple);
+		#endif
+		heap_freetuple(newtuple);
+	}
+
+	systable_endscan(scanDescriptor);
+	table_close(jobRunDetailTable, NoLock);
+
+	PopActiveSnapshot();
+	CommitTransactionCommand();
+}
diff --git a/src/pg_cron.c b/src/pg_cron.c
index d732688..f469af3 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -78,10 +78,14 @@
 #include "tcop/pquery.h"
 #include "tcop/utility.h"
 #include "libpq/pqformat.h"
+#include "utils/builtins.h"
 
 
 PG_MODULE_MAGIC;
 
+#ifndef MAXINT8LEN
+#define MAXINT8LEN 20
+#endif
 
 /* Table-of-contents constants for our dynamic shared memory segment. */
 #define PG_CRON_MAGIC			0x51028080
@@ -134,12 +138,12 @@ static char* pg_cron_cmdTuples(char *msg);
 /* global settings */
 char *CronTableDatabaseName = "postgres";
 static bool CronLogStatement = true;
+static bool CronLogRun = true;
 
 /* flags set by signal handlers */
 static volatile sig_atomic_t got_sigterm = false;
 
 /* global variables */
-static int64 RunCount = 0; /* counter for assigning unique run IDs */
 static int CronTaskStartTimeout = 10000; /* maximum connection time */
 static const int MaxWait = 1000; /* maximum time in ms that poll() can block */
 static bool RebootJobsScheduled = false;
@@ -188,6 +192,16 @@ _PG_init(void)
 		GUC_SUPERUSER_ONLY,
 		NULL, NULL, NULL);
 
+	DefineCustomBoolVariable(
+		"cron.log_run",
+		gettext_noop("Log all jobs runs into the job_run_details table"),
+		NULL,
+		&CronLogRun,
+		true,
+		PGC_POSTMASTER,
+		GUC_SUPERUSER_ONLY,
+		NULL, NULL, NULL);
+
 	DefineCustomIntVariable(
 		"cron.max_running_jobs",
 		gettext_noop("Maximum number of jobs that can run concurrently."),
@@ -381,6 +395,12 @@ PgCronWorkerMain(Datum arg)
 	/* Make pg_cron recognisable in pg_stat_activity */
 	pgstat_report_appname("pg_cron scheduler");
 
+	/*
+	 * Mark anything that was in progress before the database restarted as
+	 * failed.
+	 */
+	CleanAuditTable();
+
 	/* Determine how many tasks we can run concurrently */
 	if (MaxConnections < MaxRunningTasks)
 	{
@@ -1005,6 +1025,8 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 	CronJob *cronJob = GetCronJob(jobId);
 	PGconn *connection = task->connection;
 	ConnStatusType connectionStatus = CONNECTION_BAD;
+	bool result;
+	TimestampTz start_time;
 
 	switch (checkState)
 	{
@@ -1023,7 +1045,6 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				break;
 			}
 
-			task->runId = RunCount++;
 			task->pendingRunCount -= 1;
 			if (UseBackgroundWorkers)
 				task->state = CRON_TASK_BGW_START;
@@ -1031,6 +1052,23 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				task->state = CRON_TASK_START;
 
 			RunningTaskCount++;
+
+			/* Add new entry to audit table. */
+			SetCurrentStatementStartTimestamp();
+			StartTransactionCommand();
+			PushActiveSnapshot(GetTransactionSnapshot());
+			task->runId = NextRunId();
+			PopActiveSnapshot();
+			CommitTransactionCommand();
+			if (CronLogRun)
+			{
+				result = InsertOrUpdateJobRunDetail(task->runId, &cronJob->jobId,
+												NULL, cronJob->database,
+												cronJob->userName,
+												cronJob->command, "starting",
+												NULL, NULL, NULL);
+				Assert(result);
+			}
 		}
 
 		case CRON_TASK_START:
@@ -1096,6 +1134,15 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				task->connection = connection;
 				task->pollingStatus = PGRES_POLLING_WRITING;
 				task->state = CRON_TASK_CONNECTING;
+
+				if (CronLogRun)
+				{
+					result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
+												NULL, NULL, "connecting", NULL,
+												NULL, NULL);
+					Assert(result);
+				}
+
 				break;
 			}
 		}
@@ -1224,6 +1271,16 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				break;
 			}
 
+			start_time = GetCurrentTimestamp();
+
+			if (CronLogRun)
+			{
+				result = InsertOrUpdateJobRunDetail(task->runId, NULL, &pid, NULL,
+												NULL, NULL, "running", NULL,
+												&start_time, NULL);
+				Assert(result);
+			}
+
 			task->state = CRON_TASK_BGW_RUNNING;
 			break;
 		}
@@ -1262,10 +1319,17 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			pollingStatus = PQconnectPoll(connection);
 			if (pollingStatus == PGRES_POLLING_OK)
 			{
+				pid_t pid;
 				/* wait for socket to be ready to send a query */
 				task->pollingStatus = PGRES_POLLING_WRITING;
 
 				task->state = CRON_TASK_SENDING;
+
+				pid = (pid_t) PQbackendPID(connection);
+				if (CronLogRun)
+					result = InsertOrUpdateJobRunDetail(task->runId, NULL, &pid, NULL,
+													NULL, NULL, "sending", NULL,
+													NULL, NULL);
 			}
 			else if (pollingStatus == PGRES_POLLING_FAILED)
 			{
@@ -1328,6 +1392,15 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				/* command is underway, stop using timeout */
 				task->startDeadline = 0;
 				task->state = CRON_TASK_RUNNING;
+
+				start_time = GetCurrentTimestamp();
+				if (CronLogRun)
+				{
+					result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
+													NULL, NULL, "running", NULL,
+													&start_time, NULL);
+					Assert(result);
+				}
 			}
 			else
 			{
@@ -1430,6 +1503,8 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 		case CRON_TASK_ERROR:
 		{
+			bool update_result;
+
 			if (connection != NULL)
 			{
 				PQfinish(connection);
@@ -1443,9 +1518,18 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 			if (task->errorMessage != NULL)
 			{
+				if (CronLogRun)
+				{
+					update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
+												NULL, NULL, "failed",
+												task->errorMessage, NULL, NULL);
+					Assert(update_result);
+				}
+
 				ereport(LOG, (errmsg("cron job " INT64_FORMAT " %s",
 									 jobId, task->errorMessage)));
 
+
 				if (task->freeErrorMessage)
 				{
 					free(task->errorMessage);
@@ -1462,6 +1546,9 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 			RunningTaskCount--;
 
+			/* keep compiler quiet */
+			(void) update_result;
+
 			/* fall through to CRON_TASK_DONE */
 		}
 
@@ -1471,6 +1558,8 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			InitializeCronTask(task, jobId);
 		}
 
+	/* keep compiler quiet */
+	(void) result;
 	}
 }
 
@@ -1478,6 +1567,11 @@ static void
 GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task)
 {
 
+	TimestampTz end_time;
+	bool update_result;
+
+	end_time = GetCurrentTimestamp();
+
 	if (responseq) {
 		Size            nbytes;
 		void       *data;
@@ -1502,6 +1596,15 @@ GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task)
 				{
 					ErrorData	edata;
 					pq_parse_errornotice(&msg, &edata);
+
+					if (CronLogRun)
+					{
+						update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
+												NULL, NULL, "failed", edata.message,
+												NULL, &end_time);
+						Assert(update_result);
+					}
+
 					ereport(LOG, (errmsg("cron job " INT64_FORMAT " ERROR: %s",
 									 task->jobId, edata.message)));
 					break;
@@ -1510,6 +1613,15 @@ GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task)
 				{
 					ErrorData	edata;
 					pq_parse_errornotice(&msg, &edata);
+
+					if (CronLogRun)
+					{
+						update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
+												NULL, NULL, "failed", edata.message,
+												NULL, &end_time);
+						Assert(update_result);
+					}
+
 					ereport(LOG, (errmsg("cron job " INT64_FORMAT " NOTICE: %s",
 									 task->jobId, edata.message)));
 					break;
@@ -1518,19 +1630,27 @@ GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task)
 					break;
 			case 'C':
 				{
-					if (CronLogStatement)
+					const char  *tag = pq_getmsgstring(&msg);
+					char *nonconst_tag;
+					char *cmdTuples;
+
+					nonconst_tag = strdup(tag);
+
+					if (CronLogRun)
 					{
-						const char  *tag = pq_getmsgstring(&msg);
-						char *nonconst_tag;
-						char *cmdTuples;
+						update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
+												NULL, NULL, "succeeded", nonconst_tag,
+												NULL, &end_time);
+						Assert(update_result);
+					}
 
-						nonconst_tag = strdup(tag);
+					if (CronLogStatement) {
 						cmdTuples = pg_cron_cmdTuples(nonconst_tag);
-
 						ereport(LOG, (errmsg("cron job " INT64_FORMAT " COMMAND completed: %s %s",
 											 task->jobId, nonconst_tag, cmdTuples)));
-						free(nonconst_tag);
 					}
+
+					free(nonconst_tag);
 					break;
 				}
 			case 'A':
@@ -1552,16 +1672,25 @@ GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task)
 			{
 				case PGRES_COMMAND_OK:
 				{
-					if (CronLogStatement)
+					char *cmdStatus = PQcmdStatus(result);
+					char *cmdTuples = PQcmdTuples(result);
+
+					if (CronLogRun)
 					{
-						char *cmdStatus = PQcmdStatus(result);
-						char *cmdTuples = PQcmdTuples(result);
 
+						update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
+												NULL, NULL, "succeeded", cmdStatus,
+												NULL, &end_time);
+						Assert(update_result);
+					}
+
+					if (CronLogStatement)
+					{
 						ereport(LOG, (errmsg("cron job " INT64_FORMAT " COMMAND completed: %s %s",
 											 task->jobId, cmdStatus, cmdTuples)));
 					}
 
-				break;
+					break;
 				}
 
 				case PGRES_BAD_RESPONSE:
@@ -1572,6 +1701,15 @@ GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task)
 					task->pollingStatus = 0;
 					task->state = CRON_TASK_ERROR;
 
+					if (CronLogRun)
+					{
+						update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
+												NULL, NULL, "failed", task->errorMessage,
+												NULL, &end_time);
+
+						Assert(update_result);
+					}
+
 					PQclear(result);
 
 					return;
@@ -1586,6 +1724,15 @@ GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task)
 					task->pollingStatus = 0;
 					task->state = CRON_TASK_ERROR;
 
+					if (CronLogRun)
+					{
+						update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
+												NULL, NULL, "failed", task->errorMessage,
+												NULL, &end_time);
+
+						Assert(update_result);
+					}
+
 					PQclear(result);
 
 					return;
@@ -1597,12 +1744,25 @@ GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task)
 				case PGRES_NONFATAL_ERROR:
 				default:
 				{
-					if (CronLogStatement)
+					int tupleCount = PQntuples(result);
+					char *rowString = ngettext("row", "rows",
+										   tupleCount);
+					char  rows[MAXINT8LEN + 1];
+					char  outputrows[MAXINT8LEN + 4 + 1];
+
+					pg_lltoa(tupleCount, rows);
+					snprintf(outputrows, sizeof(outputrows), "%s %s", rows, rowString);
+
+					if (CronLogRun)
 					{
-						int tupleCount = PQntuples(result);
-						char *rowString = ngettext("row", "rows",
-											   tupleCount);
+						update_result = InsertOrUpdateJobRunDetail(task->runId, NULL, NULL, NULL,
+												NULL, NULL, "succeeded", outputrows,
+												NULL, &end_time);
+						Assert(update_result);
+					}
 
+					if (CronLogStatement)
+					{
 						ereport(LOG, (errmsg("cron job " INT64_FORMAT " completed: "
 											 "%d %s",
 											 task->jobId, tupleCount,
@@ -1616,6 +1776,8 @@ GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task)
 
 			PQclear(result);
 	}
+	/* keep compiler quiet */
+	(void) update_result;
 }
 
 /*

COMMIT_HASH:4f471b4248e6afd71bd0638a1d451f01b314d7a4|AUTHOR_NAME:bdt|AUTHOR_EMAIL:bdt|DATE:2020-08-26 06:48:53 +0000|TITLE:background worker support|MESSAGE:
diff --git a/include/job_metadata.h b/include/job_metadata.h
index 06e9622..1413ae1 100644
--- a/include/job_metadata.h
+++ b/include/job_metadata.h
@@ -13,6 +13,9 @@
 
 
 #include "nodes/pg_list.h"
+#if (PG_VERSION_NUM < 120000)
+#include "datatype/timestamp.h"
+#endif
 
 
 /* job metadata data structure */
diff --git a/include/task_states.h b/include/task_states.h
index dbd5db6..ea33970 100644
--- a/include/task_states.h
+++ b/include/task_states.h
@@ -14,6 +14,8 @@
 
 #include "job_metadata.h"
 #include "libpq-fe.h"
+#include "postmaster/bgworker.h"
+#include "storage/dsm.h"
 #include "utils/timestamp.h"
 
 
@@ -26,9 +28,17 @@ typedef enum
 	CRON_TASK_RUNNING = 4,
 	CRON_TASK_RECEIVING = 5,
 	CRON_TASK_DONE = 6,
-	CRON_TASK_ERROR = 7
+	CRON_TASK_ERROR = 7,
+	CRON_TASK_BGW_START = 8,
+	CRON_TASK_BGW_RUNNING = 9
 } CronTaskState;
 
+struct BackgroundWorkerHandle
+{
+	int slot;
+	uint64 generation;
+};
+
 typedef struct CronTask
 {
 	int64 jobId;
@@ -42,6 +52,8 @@ typedef struct CronTask
 	bool isActive;
 	char *errorMessage;
 	bool freeErrorMessage;
+	dsm_segment *seg;
+	BackgroundWorkerHandle handle;
 } CronTask;
 
 
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 369fef9..d732688 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -20,6 +20,8 @@
 #include "storage/latch.h"
 #include "storage/lwlock.h"
 #include "storage/proc.h"
+#include "storage/shm_mq.h"
+#include "storage/shm_toc.h"
 #include "storage/shmem.h"
 
 /* these headers are used by this particular worker's code */
@@ -39,19 +41,23 @@
 #include "access/genam.h"
 #include "access/heapam.h"
 #include "access/htup_details.h"
+#include "access/printtup.h"
 #include "access/xact.h"
 #include "access/xlog.h"
 #include "catalog/pg_extension.h"
 #include "catalog/indexing.h"
 #include "catalog/namespace.h"
+#include "commands/async.h"
 #include "commands/dbcommands.h"
 #include "commands/extension.h"
 #include "commands/sequence.h"
 #include "commands/trigger.h"
 #include "lib/stringinfo.h"
 #include "libpq-fe.h"
+#include "libpq/pqmq.h"
 #include "libpq/pqsignal.h"
 #include "mb/pg_wchar.h"
+#include "parser/analyze.h"
 #include "pgstat.h"
 #include "postmaster/postmaster.h"
 #include "utils/builtins.h"
@@ -59,19 +65,32 @@
 #include "utils/inval.h"
 #include "utils/lsyscache.h"
 #include "utils/memutils.h"
+#include "utils/portal.h"
+#include "utils/ps_status.h"
 #include "utils/rel.h"
 #include "utils/snapmgr.h"
 #include "utils/syscache.h"
+#include "utils/timeout.h"
 #include "utils/timestamp.h"
 #if (PG_VERSION_NUM >= 100000)
 #include "utils/varlena.h"
 #endif
+#include "tcop/pquery.h"
 #include "tcop/utility.h"
+#include "libpq/pqformat.h"
 
 
 PG_MODULE_MAGIC;
 
 
+/* Table-of-contents constants for our dynamic shared memory segment. */
+#define PG_CRON_MAGIC			0x51028080
+#define PG_CRON_KEY_DATABASE	0
+#define PG_CRON_KEY_USERNAME	1
+#define PG_CRON_KEY_COMMAND		2
+#define PG_CRON_KEY_QUEUE		3
+#define PG_CRON_NKEYS			4
+
 /* ways in which the clock can change between main loop iterations */
 typedef enum
 {
@@ -81,13 +100,14 @@ typedef enum
 	CLOCK_CHANGE = 3
 } ClockProgress;
 
-
 /* forward declarations */
 void _PG_init(void);
 void _PG_fini(void);
 static void pg_cron_sigterm(SIGNAL_ARGS);
 static void pg_cron_sighup(SIGNAL_ARGS);
+static void pg_cron_background_worker_sigterm(SIGNAL_ARGS);
 void PgCronWorkerMain(Datum arg);
+void CronBackgroundWorker(Datum arg);
 
 static void StartAllPendingRuns(List *taskList, TimestampTz currentTime);
 static void StartPendingRuns(CronTask *task, ClockProgress clockProgress,
@@ -104,7 +124,12 @@ static void PollForTasks(List *taskList);
 static bool CanStartTask(CronTask *task);
 static void ManageCronTasks(List *taskList, TimestampTz currentTime);
 static void ManageCronTask(CronTask *task, TimestampTz currentTime);
+static void ExecuteSqlString(const char *sql);
+static void GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task);
 
+static bool jobCanceled(CronTask *task);
+static bool jobStartupTimeout(CronTask *task, TimestampTz currentTime);
+static char* pg_cron_cmdTuples(char *msg);
 
 /* global settings */
 char *CronTableDatabaseName = "postgres";
@@ -120,6 +145,7 @@ static const int MaxWait = 1000; /* maximum time in ms that poll() can block */
 static bool RebootJobsScheduled = false;
 static int RunningTaskCount = 0;
 static int MaxRunningTasks = 0;
+static bool UseBackgroundWorkers = false;
 
 
 /*
@@ -177,13 +203,23 @@ _PG_init(void)
 	DefineCustomStringVariable(
 		"cron.host",
 		gettext_noop("Hostname to connect to postgres."),
-		NULL,
+		gettext_noop("This setting has no effect when background workers are used."),
 		&CronHost,
 		"localhost",
 		PGC_POSTMASTER,
 		GUC_SUPERUSER_ONLY,
 		NULL, NULL, NULL);
 
+	DefineCustomBoolVariable(
+		"cron.use_background_workers",
+		gettext_noop("Use background workers instead of client sessions."),
+		NULL,
+		&UseBackgroundWorkers,
+		false,
+		PGC_POSTMASTER,
+		GUC_SUPERUSER_ONLY,
+		NULL, NULL, NULL);
+
 	/* set up common data for all our workers */
 	worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
 	worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
@@ -236,6 +272,86 @@ pg_cron_sighup(SIGNAL_ARGS)
 	}
 }
 
+/*
+ * pg_cron_cmdTuples -
+ *      mainly copy/pasted from PQcmdTuples
+ *      If the last command was INSERT/UPDATE/DELETE/MOVE/FETCH/COPY, return
+ *      a string containing the number of inserted/affected tuples. If not,
+ *      return "".
+ *
+ *      XXX: this should probably return an int
+ */
+
+static char *
+pg_cron_cmdTuples(char *msg)
+{
+        char       *p,
+                           *c;
+
+        if (!msg)
+                return "";
+
+        if (strncmp(msg, "INSERT ", 7) == 0)
+        {
+                p = msg + 7;
+                /* INSERT: skip oid and space */
+                while (*p && *p != ' ')
+                        p++;
+                if (*p == 0)
+                        goto interpret_error;   /* no space? */
+                p++;
+        }
+        else if (strncmp(msg, "SELECT ", 7) == 0 ||
+                         strncmp(msg, "DELETE ", 7) == 0 ||
+                         strncmp(msg, "UPDATE ", 7) == 0)
+                p = msg + 7;
+        else if (strncmp(msg, "FETCH ", 6) == 0)
+                p = msg + 6;
+        else if (strncmp(msg, "MOVE ", 5) == 0 ||
+                         strncmp(msg, "COPY ", 5) == 0)
+                p = msg + 5;
+        else
+                return "";
+
+        /* check that we have an integer (at least one digit, nothing else) */
+        for (c = p; *c; c++)
+        {
+                if (!isdigit((unsigned char) *c))
+                        goto interpret_error;
+        }
+        if (c == p)
+                goto interpret_error;
+
+        return p;
+
+interpret_error:
+	ereport(LOG, (errmsg("could not interpret result from server: %s", msg)));
+        return "";
+}
+
+/*
+ * Signal handler for SIGTERM for background workers
+ * 		When we receive a SIGTERM, we set InterruptPending and ProcDiePending
+ * 		just like a normal backend.  The next CHECK_FOR_INTERRUPTS() will do the
+ * 		right thing.
+ */
+static void
+pg_cron_background_worker_sigterm(SIGNAL_ARGS)
+{
+	int save_errno = errno;
+
+	if (MyProc)
+		SetLatch(&MyProc->procLatch);
+
+	if (!proc_exit_inprogress)
+	{
+		InterruptPending = true;
+		ProcDiePending = true;
+	}
+
+	errno = save_errno;
+}
+
 
 /*
  * PgCronWorkerMain is the main entry-point for the background worker
@@ -751,6 +867,7 @@ PollForTasks(List *taskList)
 
 		if (task->state == CRON_TASK_CONNECTING ||
 			task->state == CRON_TASK_SENDING ||
+			task->state == CRON_TASK_BGW_RUNNING ||
 			task->state == CRON_TASK_RUNNING)
 		{
 			PGconn *connection = task->connection;
@@ -908,70 +1025,206 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 			task->runId = RunCount++;
 			task->pendingRunCount -= 1;
-			task->state = CRON_TASK_START;
+			if (UseBackgroundWorkers)
+				task->state = CRON_TASK_BGW_START;
+			else
+				task->state = CRON_TASK_START;
 
 			RunningTaskCount++;
 		}
 
 		case CRON_TASK_START:
 		{
-			const char *clientEncoding = GetDatabaseEncodingName();
-			char nodePortString[12];
-			TimestampTz startDeadline = 0;
-
-			const char *keywordArray[] = {
-				"host",
-				"port",
-				"fallback_application_name",
-				"client_encoding",
-				"dbname",
-				"user",
-				NULL
-			};
-			const char *valueArray[] = {
-				cronJob->nodeName,
-				nodePortString,
-				"pg_cron",
-				clientEncoding,
-				cronJob->database,
-				cronJob->userName,
-				NULL
-			};
-			sprintf(nodePortString, "%d", cronJob->nodePort);
-
-			Assert(sizeof(keywordArray) == sizeof(valueArray));
-
-			if (CronLogStatement)
+			/* as there is no break at the end of the previous case
+			 * to not add an extra second, then do another check here
+			 */
+			if (!UseBackgroundWorkers)
 			{
-				char *command = cronJob->command;
+				const char *clientEncoding = GetDatabaseEncodingName();
+				char nodePortString[12];
+				TimestampTz startDeadline = 0;
+
+				const char *keywordArray[] = {
+					"host",
+					"port",
+					"fallback_application_name",
+					"client_encoding",
+					"dbname",
+					"user",
+					NULL
+					};
+				const char *valueArray[] = {
+					cronJob->nodeName,
+					nodePortString,
+					"pg_cron",
+					clientEncoding,
+					cronJob->database,
+					cronJob->userName,
+					NULL
+				};
+				sprintf(nodePortString, "%d", cronJob->nodePort);
+
+				Assert(sizeof(keywordArray) == sizeof(valueArray));
+
+				if (CronLogStatement)
+				{
+					char *command = cronJob->command;
 
-				ereport(LOG, (errmsg("cron job " INT64_FORMAT " starting: %s",
+					ereport(LOG, (errmsg("cron job " INT64_FORMAT " starting: %s",
 									 jobId, command)));
-			}
+				}
 
-			connection = PQconnectStartParams(keywordArray, valueArray, false);
-			PQsetnonblocking(connection, 1);
+				connection = PQconnectStartParams(keywordArray, valueArray, false);
+				PQsetnonblocking(connection, 1);
 
-			connectionStatus = PQstatus(connection);
-			if (connectionStatus == CONNECTION_BAD)
-			{
-				/* make sure we call PQfinish on the connection */
+				connectionStatus = PQstatus(connection);
+				if (connectionStatus == CONNECTION_BAD)
+				{
+					/* make sure we call PQfinish on the connection */
+					task->connection = connection;
+
+					task->errorMessage = "connection failed";
+					task->pollingStatus = 0;
+					task->state = CRON_TASK_ERROR;
+					break;
+				}
+
+				startDeadline = TimestampTzPlusMilliseconds(currentTime,
+											CronTaskStartTimeout);
+
+				task->startDeadline = startDeadline;
 				task->connection = connection;
+				task->pollingStatus = PGRES_POLLING_WRITING;
+				task->state = CRON_TASK_CONNECTING;
+				break;
+			}
+		}
 
-				task->errorMessage = "connection failed";
-				task->pollingStatus = 0;
+		case CRON_TASK_BGW_START:
+		{
+
+			BackgroundWorker worker;
+			pid_t pid;
+			shm_toc_estimator e;
+			shm_toc *toc;
+			char *database;
+			char *username;
+			char *command;
+			MemoryContext oldcontext;
+			shm_mq *mq;
+			Size segsize;
+			BackgroundWorkerHandle *handle;
+			BgwHandleStatus status;
+
+			/* break in the previous case has not been reached
+			 * checking just for extra precaution
+			 */
+			Assert(UseBackgroundWorkers);
+			#if PG_VERSION_NUM < 100000
+				Assert(CurrentResourceOwner == NULL);
+				CurrentResourceOwner = ResourceOwnerCreate(NULL, "pg_cron_worker");
+			#endif
+
+			#define QUEUE_SIZE ((Size) 65536)
+
+			/*
+			 * Create the shared memory that we will pass to the background
+			 * worker process.  We use DSM_CREATE_NULL_IF_MAXSEGMENTS so that we
+			 * do not ERROR here.  This way, we can mark the job as failed and
+			 * keep the launcher process running normally.
+			 */
+			shm_toc_initialize_estimator(&e);
+			shm_toc_estimate_chunk(&e, strlen(cronJob->database) + 1);
+			shm_toc_estimate_chunk(&e, strlen(cronJob->userName) + 1);
+			shm_toc_estimate_chunk(&e, strlen(cronJob->command) + 1);
+			shm_toc_estimate_chunk(&e, QUEUE_SIZE);
+			shm_toc_estimate_keys(&e, PG_CRON_NKEYS);
+			segsize = shm_toc_estimate(&e);
+
+			task->seg = dsm_create(segsize, DSM_CREATE_NULL_IF_MAXSEGMENTS);
+			if (task->seg == NULL)
+			{
 				task->state = CRON_TASK_ERROR;
+				task->errorMessage = "unable to create a DSM segment; more "
+								"details may be available in the server log";
+
 				break;
 			}
 
-			startDeadline = TimestampTzPlusMilliseconds(currentTime,
-														CronTaskStartTimeout);
+			toc = shm_toc_create(PG_CRON_MAGIC, dsm_segment_address(task->seg), segsize);
+
+			database = shm_toc_allocate(toc, strlen(cronJob->database) + 1);
+			strcpy(database, cronJob->database);
+			shm_toc_insert(toc, PG_CRON_KEY_DATABASE, database);
+
+			username = shm_toc_allocate(toc, strlen(cronJob->userName) + 1);
+			strcpy(username, cronJob->userName);
+			shm_toc_insert(toc, PG_CRON_KEY_USERNAME, username);
+
+			command = shm_toc_allocate(toc, strlen(cronJob->command) + 1);
+			strcpy(command, cronJob->command);
+			shm_toc_insert(toc, PG_CRON_KEY_COMMAND, command);
+
+			mq = shm_mq_create(shm_toc_allocate(toc, QUEUE_SIZE), QUEUE_SIZE);
+			shm_toc_insert(toc, PG_CRON_KEY_QUEUE, mq);
+			shm_mq_set_receiver(mq, MyProc);
+
+			/*
+			 * Attach the queue before launching a worker, so that we'll automatically
+			 * detach the queue if we error out.  (Otherwise, the worker might sit
+			 * there trying to write the queue long after we've gone away.)
+			 */
+			oldcontext = MemoryContextSwitchTo(TopMemoryContext);
+			MemoryContextSwitchTo(oldcontext);
+
+			/*
+			 * Prepare the background worker.
+			 *
+			 */
+			memset(&worker, 0, sizeof(BackgroundWorker));
+			worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
+			worker.bgw_start_time = BgWorkerStart_ConsistentState;
+			worker.bgw_restart_time = BGW_NEVER_RESTART;
+			sprintf(worker.bgw_library_name, "pg_cron");
+			sprintf(worker.bgw_function_name, "CronBackgroundWorker");
+#if (PG_VERSION_NUM >= 110000)
+			snprintf(worker.bgw_type, BGW_MAXLEN, "pg_cron");
+#endif
+			snprintf(worker.bgw_name, BGW_MAXLEN, "pg_cron worker");
+			worker.bgw_main_arg = UInt32GetDatum(dsm_segment_handle(task->seg));
+			worker.bgw_notify_pid = MyProcPid;
+
+			/*
+			 * Start the worker process.
+			 */
+			if (CronLogStatement)
+			{
+				ereport(LOG, (errmsg("cron job " INT64_FORMAT " starting: %s",
+										 jobId, command)));
+			}
+			if (!RegisterDynamicBackgroundWorker(&worker, &handle))
+			{
+				dsm_detach(task->seg);
+				task->seg = NULL;
+				task->state = CRON_TASK_ERROR;
+				task->errorMessage = "could not start background process; more "
+									 "details may be available in the server log";
+				break;
+			}
 
-			task->startDeadline = startDeadline;
-			task->connection = connection;
-			task->pollingStatus = PGRES_POLLING_WRITING;
-			task->state = CRON_TASK_CONNECTING;
+			task->handle = *handle;
+			status = WaitForBackgroundWorkerStartup(&task->handle, &pid);
+			if (status != BGWH_STARTED && status != BGWH_STOPPED)
+			{
+				dsm_detach(task->seg);
+				task->seg = NULL;
+				task->state = CRON_TASK_ERROR;
+				task->errorMessage = "could not start background process; more "
+									 "details may be available in the server log";
+				break;
+			}
 
+			task->state = CRON_TASK_BGW_RUNNING;
 			break;
 		}
 
@@ -979,23 +1232,15 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 		{
 			PostgresPollingStatusType pollingStatus = 0;
 
+			Assert(!UseBackgroundWorkers);
+
 			/* check if job has been removed */
-			if (!task->isActive)
-			{
-				task->errorMessage = "job cancelled";
-				task->pollingStatus = 0;
-				task->state = CRON_TASK_ERROR;
+			if (jobCanceled(task))
 				break;
-			}
 
 			/* check if timeout has been reached */
-			if (TimestampDifferenceExceeds(task->startDeadline, currentTime, 0))
-			{
-				task->errorMessage = "connection timeout";
-				task->pollingStatus = 0;
-				task->state = CRON_TASK_ERROR;
+			if (jobStartupTimeout(task, currentTime))
 				break;
-			}
 
 			/* check if connection is still alive */
 			connectionStatus = PQstatus(connection);
@@ -1048,23 +1293,15 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			char *command = cronJob->command;
 			int sendResult = 0;
 
+			Assert(!UseBackgroundWorkers);
+
 			/* check if job has been removed */
-			if (!task->isActive)
-			{
-				task->errorMessage = "job cancelled";
-				task->pollingStatus = 0;
-				task->state = CRON_TASK_ERROR;
+			if (jobCanceled(task))
 				break;
-			}
 
 			/* check if timeout has been reached */
-			if (TimestampDifferenceExceeds(task->startDeadline, currentTime, 0))
-			{
-				task->errorMessage = "connection timeout";
-				task->pollingStatus = 0;
-				task->state = CRON_TASK_ERROR;
+			if (jobStartupTimeout(task, currentTime))
 				break;
-			}
 
 			/* check if socket is ready to send */
 			if (!task->isSocketReady)
@@ -1104,15 +1341,11 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 		{
 			int connectionBusy = 0;
 			PGresult *result = NULL;
+			Assert(!UseBackgroundWorkers);
 
 			/* check if job has been removed */
-			if (!task->isActive)
-			{
-				task->errorMessage = "job cancelled";
-				task->pollingStatus = 0;
-				task->state = CRON_TASK_ERROR;
+			if (jobCanceled(task))
 				break;
-			}
 
 			/* check if connection is still alive */
 			connectionStatus = PQstatus(connection);
@@ -1141,84 +1374,55 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 			while ((result = PQgetResult(connection)) != NULL)
 			{
-				ExecStatusType executionStatus = PQresultStatus(result);
-
-				switch (executionStatus)
-				{
-					case PGRES_COMMAND_OK:
-					{
-						if (CronLogStatement)
-						{
-							char *cmdStatus = PQcmdStatus(result);
-							char *cmdTuples = PQcmdTuples(result);
-
-							ereport(LOG, (errmsg("cron job " INT64_FORMAT " completed: %s %s",
-												 jobId, cmdStatus, cmdTuples)));
-						}
-
-						break;
-					}
-
-					case PGRES_BAD_RESPONSE:
-					case PGRES_FATAL_ERROR:
-					{
-						task->errorMessage = strdup(PQresultErrorMessage(result));
-						task->freeErrorMessage = true;
-						task->pollingStatus = 0;
-						task->state = CRON_TASK_ERROR;
-
-						PQclear(result);
+				GetTaskFeedback(NULL, result, task);
+			}
 
-						return;
-					}
+			PQfinish(connection);
 
-					case PGRES_COPY_IN:
-					case PGRES_COPY_OUT:
-					case PGRES_COPY_BOTH:
-					{
-						/* cannot handle COPY input/output */
-						task->errorMessage = "COPY not supported";
-						task->pollingStatus = 0;
-						task->state = CRON_TASK_ERROR;
+			task->connection = NULL;
+			task->pollingStatus = 0;
+			task->isSocketReady = false;
 
-						PQclear(result);
+			task->state = CRON_TASK_DONE;
+			RunningTaskCount--;
 
-						return;
-					}
+			break;
+		}
 
-					case PGRES_TUPLES_OK:
-					case PGRES_EMPTY_QUERY:
-					case PGRES_SINGLE_TUPLE:
-					case PGRES_NONFATAL_ERROR:
-					default:
-					{
-						if (CronLogStatement)
-						{
-							int tupleCount = PQntuples(result);
-							char *rowString = ngettext("row", "rows",
-													   tupleCount);
-
-							ereport(LOG, (errmsg("cron job " INT64_FORMAT " completed: "
-												 "%d %s",
-												 jobId, tupleCount,
-												 rowString)));
-						}
-
-						break;
-					}
+		case CRON_TASK_BGW_RUNNING:
+		{
+			pid_t pid;
+			shm_mq_handle *responseq;
+			shm_mq *mq;
+			shm_toc *toc;
 
-				}
+			Assert(UseBackgroundWorkers);
+			/* check if job has been removed */
+			if (jobCanceled(task))
+			{
+				TerminateBackgroundWorker(&task->handle);
+				WaitForBackgroundWorkerShutdown(&task->handle);
+				dsm_unpin_mapping(task->seg);
+				dsm_detach(task->seg);
+				task->seg = NULL;
 
-				PQclear(result);
+				break;
 			}
 
-			PQfinish(connection);
+			/* still waiting for job to complete */
+			if (GetBackgroundWorkerPid(&task->handle, &pid) != BGWH_STOPPED)
+				break;
 
-			task->connection = NULL;
-			task->pollingStatus = 0;
-			task->isSocketReady = false;
-			task->state = CRON_TASK_DONE;
+			toc = shm_toc_attach(PG_CRON_MAGIC, dsm_segment_address(task->seg));
+			#if PG_VERSION_NUM < 100000
+				mq = shm_toc_lookup(toc, PG_CRON_KEY_QUEUE);
+			#else
+				mq = shm_toc_lookup(toc, PG_CRON_KEY_QUEUE, false);
+			#endif
+			responseq = shm_mq_attach(mq, task->seg, NULL);
+			GetTaskFeedback(responseq, NULL, task);
 
+			task->state = CRON_TASK_DONE;
 			RunningTaskCount--;
 
 			break;
@@ -1269,3 +1473,459 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 	}
 }
+
+static void
+GetTaskFeedback(shm_mq_handle *responseq, PGresult *result, CronTask *task)
+{
+
+	if (responseq) {
+		Size            nbytes;
+		void       *data;
+		char            msgtype;
+		StringInfoData  msg;
+
+		/*
+		 * Message-parsing routines operate on a null-terminated StringInfo,
+		 * so we must construct one.
+		 */
+		shm_mq_receive(responseq, &nbytes, &data, false);
+		initStringInfo(&msg);
+		resetStringInfo(&msg);
+		enlargeStringInfo(&msg, nbytes);
+		msg.len = nbytes;
+		memcpy(msg.data, data, nbytes);
+		msg.data[nbytes] = '\0';
+		msgtype = pq_getmsgbyte(&msg);
+		switch (msgtype)
+		{
+			case 'E':
+				{
+					ErrorData	edata;
+					pq_parse_errornotice(&msg, &edata);
+					ereport(LOG, (errmsg("cron job " INT64_FORMAT " ERROR: %s",
+									 task->jobId, edata.message)));
+					break;
+				}
+			case 'N':
+				{
+					ErrorData	edata;
+					pq_parse_errornotice(&msg, &edata);
+					ereport(LOG, (errmsg("cron job " INT64_FORMAT " NOTICE: %s",
+									 task->jobId, edata.message)));
+					break;
+				}
+			case 'T':
+					break;
+			case 'C':
+				{
+					if (CronLogStatement)
+					{
+						const char  *tag = pq_getmsgstring(&msg);
+						char *nonconst_tag;
+						char *cmdTuples;
+
+						nonconst_tag = strdup(tag);
+						cmdTuples = pg_cron_cmdTuples(nonconst_tag);
+
+						ereport(LOG, (errmsg("cron job " INT64_FORMAT " COMMAND completed: %s %s",
+											 task->jobId, nonconst_tag, cmdTuples)));
+						free(nonconst_tag);
+					}
+					break;
+				}
+			case 'A':
+			case 'D':
+			case 'G':
+			case 'H':
+			case 'W':
+			case 'Z':
+					break;
+			default:
+					elog(WARNING, "unknown message type: %c (%zu bytes)",
+						 msg.data[0], nbytes);
+					break;
+		}
+	} else {
+
+			ExecStatusType executionStatus = PQresultStatus(result);
+			switch (executionStatus)
+			{
+				case PGRES_COMMAND_OK:
+				{
+					if (CronLogStatement)
+					{
+						char *cmdStatus = PQcmdStatus(result);
+						char *cmdTuples = PQcmdTuples(result);
+
+						ereport(LOG, (errmsg("cron job " INT64_FORMAT " COMMAND completed: %s %s",
+											 task->jobId, cmdStatus, cmdTuples)));
+					}
+
+				break;
+				}
+
+				case PGRES_BAD_RESPONSE:
+				case PGRES_FATAL_ERROR:
+				{
+					task->errorMessage = strdup(PQresultErrorMessage(result));
+					task->freeErrorMessage = true;
+					task->pollingStatus = 0;
+					task->state = CRON_TASK_ERROR;
+
+					PQclear(result);
+
+					return;
+				}
+
+				case PGRES_COPY_IN:
+				case PGRES_COPY_OUT:
+				case PGRES_COPY_BOTH:
+				{
+					/* cannot handle COPY input/output */
+					task->errorMessage = "COPY not supported";
+					task->pollingStatus = 0;
+					task->state = CRON_TASK_ERROR;
+
+					PQclear(result);
+
+					return;
+				}
+
+				case PGRES_TUPLES_OK:
+				case PGRES_EMPTY_QUERY:
+				case PGRES_SINGLE_TUPLE:
+				case PGRES_NONFATAL_ERROR:
+				default:
+				{
+					if (CronLogStatement)
+					{
+						int tupleCount = PQntuples(result);
+						char *rowString = ngettext("row", "rows",
+											   tupleCount);
+
+						ereport(LOG, (errmsg("cron job " INT64_FORMAT " completed: "
+											 "%d %s",
+											 task->jobId, tupleCount,
+											 rowString)));
+					}
+
+					break;
+				}
+
+			}
+
+			PQclear(result);
+	}
+}
+
+/*
+ * Background worker logic.
+ */
+void
+CronBackgroundWorker(Datum main_arg)
+{
+	dsm_segment *seg;
+	shm_toc *toc;
+	char *database;
+	char *username;
+	char *command;
+	shm_mq *mq;
+	shm_mq_handle *responseq;
+
+	pqsignal(SIGTERM, pg_cron_background_worker_sigterm);
+	BackgroundWorkerUnblockSignals();
+
+	/* Set up a memory context and resource owner. */
+	Assert(CurrentResourceOwner == NULL);
+	CurrentResourceOwner = ResourceOwnerCreate(NULL, "pg_cron");
+	CurrentMemoryContext = AllocSetContextCreate(TopMemoryContext,
+												 "pg_cron worker",
+												 ALLOCSET_DEFAULT_MINSIZE,
+												 ALLOCSET_DEFAULT_INITSIZE,
+												 ALLOCSET_DEFAULT_MAXSIZE);
+
+	/* Set up a dynamic shared memory segment. */
+	seg = dsm_attach(DatumGetInt32(main_arg));
+	if (seg == NULL)
+		ereport(ERROR,
+				(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),
+				 errmsg("unable to map dynamic shared memory segment")));
+	toc = shm_toc_attach(PG_CRON_MAGIC, dsm_segment_address(seg));
+	if (toc == NULL)
+		ereport(ERROR,
+				(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),
+			   errmsg("bad magic number in dynamic shared memory segment")));
+
+	#if PG_VERSION_NUM < 100000
+		database = shm_toc_lookup(toc, PG_CRON_KEY_DATABASE);
+		username = shm_toc_lookup(toc, PG_CRON_KEY_USERNAME);
+		command = shm_toc_lookup(toc, PG_CRON_KEY_COMMAND);
+		mq = shm_toc_lookup(toc, PG_CRON_KEY_QUEUE);
+	#else
+		database = shm_toc_lookup(toc, PG_CRON_KEY_DATABASE, false);
+		username = shm_toc_lookup(toc, PG_CRON_KEY_USERNAME, false);
+		command = shm_toc_lookup(toc, PG_CRON_KEY_COMMAND, false);
+		mq = shm_toc_lookup(toc, PG_CRON_KEY_QUEUE, false);
+	#endif
+
+	shm_mq_set_sender(mq, MyProc);
+	responseq = shm_mq_attach(mq, seg, NULL);
+	pq_redirect_to_shm_mq(seg, responseq);
+
+#if (PG_VERSION_NUM < 110000)
+	BackgroundWorkerInitializeConnection(database, username);
+#else
+	BackgroundWorkerInitializeConnection(database, username, 0);
+#endif
+
+	/* Prepare to execute the query. */
+	SetCurrentStatementStartTimestamp();
+	debug_query_string = command;
+	pgstat_report_activity(STATE_RUNNING, command);
+	StartTransactionCommand();
+	if (StatementTimeout > 0)
+		enable_timeout_after(STATEMENT_TIMEOUT, StatementTimeout);
+	else
+		disable_timeout(STATEMENT_TIMEOUT, false);
+
+	/* Execute the query. */
+	ExecuteSqlString(command);
+
+	/* Post-execution cleanup. */
+	disable_timeout(STATEMENT_TIMEOUT, false);
+	CommitTransactionCommand();
+	ProcessCompletedNotifies();
+	pgstat_report_activity(STATE_IDLE, command);
+	pgstat_report_stat(true);
+
+	/* Signal that we are done. */
+	ReadyForQuery(DestRemote);
+
+	dsm_detach(seg);
+	proc_exit(0);
+}
+
+/*
+ * Execute given SQL string without SPI or a libpq session.
+ */
+static void
+ExecuteSqlString(const char *sql)
+{
+	List *raw_parsetree_list;
+	ListCell *lc1;
+	bool isTopLevel;
+	int commands_remaining;
+	MemoryContext parsecontext;
+	MemoryContext oldcontext;
+
+	/*
+	 * Parse the SQL string into a list of raw parse trees.
+	 *
+	 * Because we allow statements that perform internal transaction control,
+	 * we can't do this in TopTransactionContext; the parse trees might get
+	 * blown away before we're done executing them.
+	 */
+	parsecontext = AllocSetContextCreate(TopMemoryContext,
+										 "pg_cron parse/plan",
+										 ALLOCSET_DEFAULT_MINSIZE,
+										 ALLOCSET_DEFAULT_INITSIZE,
+										 ALLOCSET_DEFAULT_MAXSIZE);
+	oldcontext = MemoryContextSwitchTo(parsecontext);
+	raw_parsetree_list = pg_parse_query(sql);
+	commands_remaining = list_length(raw_parsetree_list);
+	isTopLevel = commands_remaining == 1;
+	MemoryContextSwitchTo(oldcontext);
+
+	/*
+	 * Do parse analysis, rule rewrite, planning, and execution for each raw
+	 * parsetree.  We must fully execute each query before beginning parse
+	 * analysis on the next one, since there may be interdependencies.
+	 */
+	foreach(lc1, raw_parsetree_list)
+	{
+		#if PG_VERSION_NUM < 100000
+			Node *parsetree = (Node *) lfirst(lc1);
+		#else
+			RawStmt *parsetree = (RawStmt *)  lfirst(lc1);
+		#endif
+
+		#if PG_VERSION_NUM < 130000
+			const char *commandTag;
+			char completionTag[COMPLETION_TAG_BUFSIZE];
+		#else
+			CommandTag commandTag;
+			QueryCompletion qc;
+		#endif
+
+		List *querytree_list;
+		List *plantree_list;
+		bool snapshot_set = false;
+		Portal portal;
+		DestReceiver *receiver;
+		int16 format = 1;
+
+		/*
+		 * We don't allow transaction-control commands like COMMIT and ABORT
+		 * here.  The entire SQL statement is executed as a single transaction
+		 * which commits if no errors are encountered.
+		 */
+		if (IsA(parsetree, TransactionStmt))
+			ereport(ERROR,
+					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
+					 errmsg("transaction control statements are not allowed in pg_cron")));
+
+		/*
+		 * Get the command name for use in status display (it also becomes the
+		 * default completion tag, down inside PortalRun).  Set ps_status and
+		 * do any special start-of-SQL-command processing needed by the
+		 * destination.
+		 */
+		#if PG_VERSION_NUM < 100000
+			commandTag = CreateCommandTag(parsetree);
+		#else
+			commandTag = CreateCommandTag(parsetree->stmt);
+		#endif
+
+
+		#if PG_VERSION_NUM < 130000
+			set_ps_display(commandTag, false);
+		#else
+			set_ps_display(GetCommandTagName(commandTag), false);
+		#endif
+
+		BeginCommand(commandTag, DestNone);
+
+		/* Set up a snapshot if parse analysis/planning will need one. */
+		if (analyze_requires_snapshot(parsetree))
+		{
+			PushActiveSnapshot(GetTransactionSnapshot());
+			snapshot_set = true;
+		}
+
+		/*
+		 * OK to analyze, rewrite, and plan this query.
+		 *
+		 * As with parsing, we need to make sure this data outlives the
+		 * transaction, because of the possibility that the statement might
+		 * perform internal transaction control.
+		 */
+		oldcontext = MemoryContextSwitchTo(parsecontext);
+		#if PG_VERSION_NUM >= 100000
+			querytree_list = pg_analyze_and_rewrite(parsetree, sql, NULL, 0,NULL);
+		#else
+			querytree_list = pg_analyze_and_rewrite(parsetree, sql, NULL, 0);
+		#endif
+
+		plantree_list = pg_plan_queries(querytree_list, 0, NULL);
+
+		/* Done with the snapshot used for parsing/planning */
+		if (snapshot_set)
+			PopActiveSnapshot();
+
+		/* If we got a cancel signal in analysis or planning, quit */
+		CHECK_FOR_INTERRUPTS();
+
+		/*
+		 * Execute the query using the unnamed portal.
+		 */
+		portal = CreatePortal("", true, true);
+		/* Don't display the portal in pg_cursors */
+		portal->visible = false;
+		PortalDefineQuery(portal, NULL, sql, commandTag, plantree_list, NULL);
+		PortalStart(portal, NULL, 0, InvalidSnapshot);
+		PortalSetResultFormat(portal, 1, &format);		/* binary format */
+
+		--commands_remaining;
+		receiver = CreateDestReceiver(DestNone);
+
+		/*
+		 * Only once the portal and destreceiver have been established can
+		 * we return to the transaction context.  All that stuff needs to
+		 * survive an internal commit inside PortalRun!
+		 */
+		MemoryContextSwitchTo(oldcontext);
+
+		/* Here's where we actually execute the command. */
+		#if PG_VERSION_NUM < 100000
+			(void) PortalRun(portal, FETCH_ALL, isTopLevel, receiver, receiver, completionTag);
+		#elif PG_VERSION_NUM < 130000
+			(void) PortalRun(portal, FETCH_ALL, isTopLevel,true, receiver, receiver, completionTag);
+		#else
+			(void) PortalRun(portal, FETCH_ALL, isTopLevel, true, receiver, receiver, &qc);
+		#endif
+
+		/* Clean up the receiver. */
+		(*receiver->rDestroy) (receiver);
+
+		/*
+		 * Send a CommandComplete message even if we suppressed the query
+		 * results.  The user backend will report these in the absence of
+		 * any true query results.
+		 */
+		#if PG_VERSION_NUM < 130000
+			EndCommand(completionTag, DestRemote);
+		#else
+			EndCommand(&qc, DestRemote, false);
+		#endif
+
+		/* Clean up the portal. */
+		PortalDrop(portal, false);
+	}
+
+	/* Be sure to advance the command counter after the last script command */
+	CommandCounterIncrement();
+}
+
+/*
+ * If a task is not marked as active, set an appropriate error state on the task
+ * and return true. Note that this should only be called after a task has
+ * already been launched.
+ */
+static bool
+jobCanceled(CronTask *task)
+{
+    Assert(task->state == CRON_TASK_CONNECTING || \
+            task->state == CRON_TASK_SENDING || \
+            task->state == CRON_TASK_BGW_RUNNING || \
+            task->state == CRON_TASK_RUNNING);
+
+    if (task->isActive)
+        return false;
+    else
+    {
+        /* Use the American spelling for consistency with PG code. */
+        task->errorMessage = "job canceled";
+        task->state = CRON_TASK_ERROR;
+
+        /*
+         * Technically, pollingStatus is only used by when UseBackgroundWorkers
+         * is false, but no damage in setting it in both cases.
+         */
+        task->pollingStatus = 0;
+        return true;
+    }
+}
+
+/*
+ * If a task has hit it's startup deadline, set an appropriate error state on
+ * the task and return true. Note that this should only be called after a task
+ * has already been launched. It's not used when UseBackgroundWorkers is true
+ * (if that were to change the error message wouldn't make sense).
+ */
+static bool
+jobStartupTimeout(CronTask *task, TimestampTz currentTime)
+{
+    Assert(!UseBackgroundWorkers);
+    Assert(task->state == CRON_TASK_CONNECTING || \
+            task->state == CRON_TASK_SENDING);
+
+    if (TimestampDifferenceExceeds(task->startDeadline, currentTime, 0))
+    {
+        task->errorMessage = "connection timeout";
+        task->pollingStatus = 0;
+        task->state = CRON_TASK_ERROR;
+        return true;
+    }
+    else
+        return false;
+}

COMMIT_HASH:4ac2ae4f04846ed94e87cfaad643482a00d6e461|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2020-09-18 11:23:10 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 08d014f..e791f96 100644
--- a/README.md
+++ b/README.md
@@ -130,11 +130,12 @@ You can use [.pgpass](https://www.postgresql.org/docs/current/static/libpq-pgpas
 
 The following table keeps track of which of the major managed Postgres services support pg_cron.
 
-| Service       | Supported     | Version  |
-| ------------- |:-------------:| --------:|
-| [Citus Cloud](https://www.citusdata.com/product/cloud)  | :heavy_check_mark: |   1.1.3    |
+| Service       | Supported     |
+| ------------- |:-------------:|
+| [Citus Cloud](https://www.citusdata.com/product/cloud)  | :heavy_check_mark: |
 | [Amazon RDS](https://aws.amazon.com/rds/postgresql/)     | :x:      |          |
-| [Azure](https://azure.microsoft.com/en-us/services/postgresql/) | :heavy_check_mark: for Hyperscale (Citus)   |  1.1.4 |
-| [DigitalOcean](https://www.digitalocean.com/products/managed-databases/) | :heavy_check_mark: | |
-| [Google Cloud](https://cloud.google.com/sql/docs/postgres/) | :x:      |          |
+| [Azure](https://azure.microsoft.com/en-us/services/postgresql/) | :heavy_check_mark: for Hyperscale (Citus)   |
+| [DigitalOcean](https://www.digitalocean.com/products/managed-databases/) | :heavy_check_mark: |
+| [Google Cloud](https://cloud.google.com/sql/docs/postgres/) | :x:      |
 | [Heroku](https://elements.heroku.com/addons/heroku-postgresql) | :x: | |
+| [Crunchy Bridge](https://www.crunchydata.com/products/crunchy-bridge/?ref=producthunt) | :heavy_check_mark: |

COMMIT_HASH:7f832ed4f629ae3617a66a6dd30bc40129243106|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2020-08-22 12:01:10 +0200|TITLE:Merge pull request #108 from nxz91/patch-1|MESSAGE:Update README.md
COMMIT_HASH:8e60e0790c80bf8abfaa1d725a8254326dd22f45|AUTHOR_NAME:nxz91|AUTHOR_EMAIL:leonardwitteler@gmail.com|DATE:2020-08-03 01:16:44 +0200|TITLE:Update README.md|MESSAGE:Source: https://www.digitalocean.com/docs/databases/postgresql/resources/supported-extensions/
diff --git a/README.md b/README.md
index 48d0c17..08d014f 100644
--- a/README.md
+++ b/README.md
@@ -135,6 +135,6 @@ The following table keeps track of which of the major managed Postgres services
 | [Citus Cloud](https://www.citusdata.com/product/cloud)  | :heavy_check_mark: |   1.1.3    |
 | [Amazon RDS](https://aws.amazon.com/rds/postgresql/)     | :x:      |          |
 | [Azure](https://azure.microsoft.com/en-us/services/postgresql/) | :heavy_check_mark: for Hyperscale (Citus)   |  1.1.4 |
-| [DigitalOcean](https://www.digitalocean.com/products/managed-databases/) | :x: ([idea](https://ideas.digitalocean.com/ideas/DBAAS-I-18)) | |
+| [DigitalOcean](https://www.digitalocean.com/products/managed-databases/) | :heavy_check_mark: | |
 | [Google Cloud](https://cloud.google.com/sql/docs/postgres/) | :x:      |          |
 | [Heroku](https://elements.heroku.com/addons/heroku-postgresql) | :x: | |

COMMIT_HASH:f6c5747a985eba2d3c60a94599f3900e63d87bf3|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2020-05-21 20:18:21 +0200|TITLE:Merge pull request #103 from CyberDem0n/pg13-compat|MESSAGE:Compatibility with PostgreSQL 13
COMMIT_HASH:2ad167a5666490572a50b69e31b5d3cb277f4623|AUTHOR_NAME:Alexander Kukushkin|AUTHOR_EMAIL:alexander.kukushkin@zalando.de|DATE:2020-05-21 10:48:00 +0200|TITLE:Compatibility with PostgreSQL 13|MESSAGE:* heap_open() and head_close() were removed
* fix some includes

diff --git a/src/job_metadata.c b/src/job_metadata.c
index 8b0c928..3a9d0f1 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -19,6 +19,7 @@
 #include "cron_job.h"
 
 #include "access/genam.h"
+#include "access/hash.h"
 #include "access/heapam.h"
 #include "access/htup_details.h"
 #include "access/skey.h"
@@ -33,6 +34,7 @@
 #include "postmaster/postmaster.h"
 #include "pgstat.h"
 #include "storage/lock.h"
+#include "utils/acl.h"
 #include "utils/builtins.h"
 #include "utils/fmgroids.h"
 #include "utils/inval.h"
@@ -46,6 +48,10 @@
 #include "utils/varlena.h"
 #endif
 
+#if (PG_VERSION_NUM < 120000)
+#define table_open(r, l) heap_open(r, l)
+#define table_close(r, l) heap_close(r, l)
+#endif
 
 #define EXTENSION_NAME "pg_cron"
 #define CRON_SCHEMA_NAME "cron"
@@ -210,7 +216,7 @@ cron_schedule(PG_FUNCTION_ARGS)
 	cronJobsRelationId = get_relname_relid(JOBS_TABLE_NAME, cronSchemaId);
 
 	/* open jobs relation and insert new tuple */
-	cronJobsTable = heap_open(cronJobsRelationId, RowExclusiveLock);
+	cronJobsTable = table_open(cronJobsRelationId, RowExclusiveLock);
 
 	tupleDescriptor = RelationGetDescr(cronJobsTable);
 	heapTuple = heap_form_tuple(tupleDescriptor, values, isNulls);
@@ -224,7 +230,7 @@ cron_schedule(PG_FUNCTION_ARGS)
 	CommandCounterIncrement();
 
 	/* close relation and invalidate previous cache entry */
-	heap_close(cronJobsTable, NoLock);
+	table_close(cronJobsTable, NoLock);
 
 	InvalidateJobCache();
 
@@ -284,7 +290,7 @@ CronExtensionOwner(void)
 	Form_pg_extension extensionForm = NULL;
 	Oid extensionOwner = InvalidOid;
 
-	extensionRelation = heap_open(ExtensionRelationId, AccessShareLock);
+	extensionRelation = table_open(ExtensionRelationId, AccessShareLock);
 
 	ScanKeyInit(&entry[0],
 				Anum_pg_extension_extname,
@@ -305,7 +311,7 @@ CronExtensionOwner(void)
 	extensionOwner = extensionForm->extowner;
 
 	systable_endscan(scanDescriptor);
-	heap_close(extensionRelation, AccessShareLock);
+	table_close(extensionRelation, AccessShareLock);
 
 	return extensionOwner;
 }
@@ -338,7 +344,7 @@ cron_unschedule(PG_FUNCTION_ARGS)
 	cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
 	cronJobIndexId = get_relname_relid(JOB_ID_INDEX_NAME, cronSchemaId);
 
-	cronJobsTable = heap_open(CronJobRelationId(), RowExclusiveLock);
+	cronJobsTable = table_open(CronJobRelationId(), RowExclusiveLock);
 
 	ScanKeyInit(&scanKey[0], Anum_cron_job_jobid,
 				BTEqualStrategyNumber, F_INT8EQ, Int64GetDatum(jobId));
@@ -383,7 +389,7 @@ cron_unschedule(PG_FUNCTION_ARGS)
 	simple_heap_delete(cronJobsTable, &heapTuple->t_self);
 
 	systable_endscan(scanDescriptor);
-	heap_close(cronJobsTable, NoLock);
+	table_close(cronJobsTable, NoLock);
 
 	CommandCounterIncrement();
 	InvalidateJobCache();
@@ -498,7 +504,7 @@ LoadCronJobList(void)
 		return NIL;
 	}
 
-	cronJobTable = heap_open(CronJobRelationId(), AccessShareLock);
+	cronJobTable = table_open(CronJobRelationId(), AccessShareLock);
 
 	scanDescriptor = systable_beginscan(cronJobTable,
 										InvalidOid, false,
@@ -523,7 +529,7 @@ LoadCronJobList(void)
 	}
 
 	systable_endscan(scanDescriptor);
-	heap_close(cronJobTable, AccessShareLock);
+	table_close(cronJobTable, AccessShareLock);
 
 	PopActiveSnapshot();
 	CommitTransactionCommand();
diff --git a/src/task_states.c b/src/task_states.c
index 1084062..e934d2f 100644
--- a/src/task_states.c
+++ b/src/task_states.c
@@ -17,6 +17,7 @@
 #include "pg_cron.h"
 #include "task_states.h"
 
+#include "access/hash.h"
 #include "utils/hsearch.h"
 #include "utils/memutils.h"
 

COMMIT_HASH:4ec6b0d244cafa9b811a204c7a7e609e1fdf7181|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2019-12-10 20:29:40 +0100|TITLE:Fix potential segfault when schedule too long (#98)|MESSAGE:Fix potential segfault when schedule too long
COMMIT_HASH:54a2b8ea67d4756e3d457ba8906bd73178cf68bf|AUTHOR_NAME:Philip Dubé|AUTHOR_EMAIL:gunkmute@gmail.com|DATE:2019-12-02 22:41:11 +0000|TITLE:Fix potential segfault when schedule too long|MESSAGE:
diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index 1711758..d0ca140 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -26,4 +26,7 @@ SELECT cron.unschedule(1);
  t
 (1 row)
 
+-- Invalid input: input too long
+SELECT cron.schedule(repeat('a', 1000), '');
+ERROR:  invalid schedule: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
 DROP EXTENSION pg_cron;
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index aa05faa..3eb0c96 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -9,4 +9,7 @@ SELECT cron.schedule('0 10 * * *', 'VACUUM');
 -- Stop scheduling a job
 SELECT cron.unschedule(1);
 
+-- Invalid input: input too long
+SELECT cron.schedule(repeat('a', 1000), '');
+
 DROP EXTENSION pg_cron;
diff --git a/src/entry.c b/src/entry.c
index f7308e4..eae4516 100644
--- a/src/entry.c
+++ b/src/entry.c
@@ -42,14 +42,15 @@ static int	set_element(bitstr_t *, int, int, int);
 
 
 void
-free_entry(e)
-	entry	*e;
+free_entry(entry *e)
 {
-	free(e->cmd);
+	if (e->cmd)
+		free(e->cmd);
 	free(e);
 }
 
 
+
 /* return NULL if eof or syntax error occurs;
  * otherwise return a pointer to a new entry.
  *
@@ -74,15 +75,16 @@ parse_cron_entry(char *schedule)
 	 */
 
 	ecode_e	ecode = e_none;
-	entry *e = NULL;
+	entry *e = (entry *) calloc(sizeof(entry), sizeof(char));
 	int	ch = 0;
 	char cmd[MAX_COMMAND];
 	file_buffer buffer = {{},0,0,{},0};
 	FILE *file = (FILE *) &buffer;
 
-	int scheduleLength = strlen(schedule); 
+	int scheduleLength = strlen(schedule);
 	if (scheduleLength >= MAX_FILE_BUFFER_LENGTH)
 	{
+		ch = EOF;
 		ecode = e_cmd_len;
 		goto eof;
 	}
@@ -97,15 +99,16 @@ parse_cron_entry(char *schedule)
 
 	ch = get_char(file);
 	if (ch == EOF)
+	{
+		free_entry(e);
 		return NULL;
+	}
 
 	/* ch is now the first useful character of a useful line.
 	 * it may be an @special or it may be the first character
 	 * of a list of minutes.
 	 */
 
-	e = (entry *) calloc(sizeof(entry), sizeof(char));
-
 	if (ch == '@') {
 		/* all of these should be flagged and load-limited; i.e.,
 		 * instead of @hourly meaning "0 * * * *" it should mean
@@ -128,7 +131,7 @@ parse_cron_entry(char *schedule)
 			bit_set(e->dom, 0);
 			bit_set(e->month, 0);
 			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
-                        e->flags |= DOW_STAR; 
+                        e->flags |= DOW_STAR;
 		} else if (!strcmp("monthly", cmd)) {
 			bit_set(e->minute, 0);
 			bit_set(e->hour, 0);
@@ -219,7 +222,7 @@ parse_cron_entry(char *schedule)
 		}
 	}
 
-	/* make sundays equivilent */
+	/* make sundays equivalent */
 	if (bit_test(e->dow, 0) || bit_test(e->dow, 7)) {
 		bit_set(e->dow, 0);
 		bit_set(e->dow, 7);
@@ -231,9 +234,7 @@ parse_cron_entry(char *schedule)
 
  eof:
 	elog(LOG, "failed to parse entry %d", ecode);
-	if (e->cmd)
-		free(e->cmd);
-	free(e);
+	free_entry(e);
 	while (ch != EOF && ch != '\n')
 		ch = get_char(file);
 	return NULL;
@@ -260,7 +261,7 @@ get_list(bits, low, high, names, ch, file)
 
 	/* list = range {"," range}
 	 */
-	
+
 	/* clear the bit string, since the default is 'off'.
 	 */
 	bit_nclear(bits, 0, (high-low+1));

COMMIT_HASH:d0b9808626785330a1a324e3303b7557787066f1|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2019-10-29 10:53:11 +0100|TITLE:Merge pull request #92 from JRaspass/patch-1|MESSAGE:Add DigitalOcean to README.md
COMMIT_HASH:f8e28693a646c99984d32efb52bbf1227a7d67d8|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2019-10-29 10:52:44 +0100|TITLE:Fix installation instructions for PostgreSQL 9.x (#93)|MESSAGE:Fix installation instructions for PostgreSQL 9.x
COMMIT_HASH:630c1009a20afdf1004e314f99e48ddf68fcdb99|AUTHOR_NAME:Christoph Berg|AUTHOR_EMAIL:myon@debian.org|DATE:2019-10-26 10:28:12 +0200|TITLE:Fix installation instructions for PostgreSQL 9.x|MESSAGE:Versions before 10 can't directly install version 1.2 which only exists
as 1.0 -> 1.1 -> 1.2 upgrade path.

diff --git a/README.md b/README.md
index 83fae6b..75d4f6d 100644
--- a/README.md
+++ b/README.md
@@ -93,6 +93,10 @@ After restarting PostgreSQL, you can create the pg_cron functions and metadata t
 -- run as superuser:
 CREATE EXTENSION pg_cron;
 
+-- on PostgreSQL 9.x, do this instead:
+CREATE EXTENSION pg_cron VERSION '1.0';
+ALTER EXTENSION pg_cron UPDATE;
+
 -- optionally, grant usage to regular users:
 GRANT USAGE ON SCHEMA cron TO marco;
 ```

COMMIT_HASH:b6e7dc9627515bf00e2086f168b3faa660e5fd36|AUTHOR_NAME:James Raspass|AUTHOR_EMAIL:jraspass@gmail.com|DATE:2019-10-23 15:15:24 +0100|TITLE:Add DigitalOcean to README.md|MESSAGE:Note that it isn't currently supported but there is an "idea".
diff --git a/README.md b/README.md
index 83fae6b..eb80dae 100644
--- a/README.md
+++ b/README.md
@@ -131,5 +131,6 @@ The following table keeps track of which of the major managed Postgres services
 | [Citus Cloud](https://www.citusdata.com/product/cloud)  | :heavy_check_mark: |   1.1.3    |
 | [Amazon RDS](https://aws.amazon.com/rds/postgresql/)     | :x:      |          |
 | [Azure](https://azure.microsoft.com/en-us/services/postgresql/) | :heavy_check_mark: for Hyperscale (Citus)   |  1.1.4 |
+| [DigitalOcean](https://www.digitalocean.com/products/managed-databases/) | :x: ([idea](https://ideas.digitalocean.com/ideas/DBAAS-I-18)) | |
 | [Google Cloud](https://cloud.google.com/sql/docs/postgres/) | :x:      |          |
 | [Heroku](https://elements.heroku.com/addons/heroku-postgresql) | :x: | |

COMMIT_HASH:36446a7dccd6a07485e7150183cfd57d56668559|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2019-08-28 14:19:34 +0200|TITLE:Add CHANGELOG entry for 1.2.0|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index c06f73f..7695b8a 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,8 @@
+### pg_cron v1.2.0 (August 30, 2019) ###
+
+* PostgreSQL 12 support by dverite
+* Fixes a bug that caused the cron.job table to not appear in pg_dump
+
 ### pg_cron v1.1.4 (April 4, 2019) ###
 
 * Adds a cron.host setting to make the postgres host configurable

COMMIT_HASH:95b5af8bd3d830a8e91983d77911eb1eef929956|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2019-08-28 13:54:25 +0200|TITLE:Redo pg_extension_config_dump calls which were lost during build|MESSAGE:
diff --git a/Makefile b/Makefile
index 04dfd0e..a4f20ae 100644
--- a/Makefile
+++ b/Makefile
@@ -1,9 +1,9 @@
 # src/test/modules/pg_cron/Makefile
 
 EXTENSION = pg_cron
-EXTVERSION = 1.1
+EXTVERSION = 1.2
 
-DATA_built = $(EXTENSION)--$(EXTVERSION).sql $(EXTENSION)--1.0.sql
+DATA_built = $(EXTENSION)--1.0.sql
 DATA = $(wildcard $(EXTENSION)--*--*.sql)
 REGRESS = pg_cron-test 
 
@@ -22,7 +22,5 @@ PG_CONFIG = pg_config
 PGXS := $(shell $(PG_CONFIG) --pgxs)
 include $(PGXS)
 
-$(EXTENSION)--1.0.sql: $(EXTENSION).sql $(EXTENSION)--0.1--1.0.sql
-	cat $^ > $@
-$(EXTENSION)--1.1.sql: $(EXTENSION).sql $(EXTENSION)--1.0--1.1.sql
+$(EXTENSION)--1.0.sql: $(EXTENSION).sql
 	cat $^ > $@
diff --git a/pg_cron--0.1--1.0.sql b/pg_cron--0.1--1.0.sql
deleted file mode 100644
index beee92d..0000000
--- a/pg_cron--0.1--1.0.sql
+++ /dev/null
@@ -1,3 +0,0 @@
-/* pg_cron--0.1--1.0.sql */
-
-SELECT pg_catalog.pg_extension_config_dump('cron.job', '');
diff --git a/pg_cron--1.1--1.2.sql b/pg_cron--1.1--1.2.sql
new file mode 100644
index 0000000..a0ea04a
--- /dev/null
+++ b/pg_cron--1.1--1.2.sql
@@ -0,0 +1,4 @@
+/* pg_cron--1.1--1.2.sql */
+
+SELECT pg_catalog.pg_extension_config_dump('cron.job', '');
+SELECT pg_catalog.pg_extension_config_dump('cron.jobid_seq', '');
diff --git a/pg_cron.control b/pg_cron.control
index aaf4214..cb469f9 100644
--- a/pg_cron.control
+++ b/pg_cron.control
@@ -1,4 +1,4 @@
 comment = 'Job scheduler for PostgreSQL'
-default_version = '1.1'
+default_version = '1.2'
 module_pathname = '$libdir/pg_cron'
 relocatable = false

COMMIT_HASH:f67ca999a5c3b082d313021ec9371e31179a8b83|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2019-06-06 17:25:12 +0200|TITLE:Merge pull request #78 from dverite/master|MESSAGE:Call AllocSetContextCreate() directly rather than through a macro.
COMMIT_HASH:a21536387f2ee9a2e295fc2375d57d6e4971d91b|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2019-06-04 18:15:14 +0200|TITLE:Merge pull request #80 from fluca1978/readme_blog_post|MESSAGE:Added blog post to README "use cases".
COMMIT_HASH:af1e1afdd15559b7efa257002df1784806eb8c89|AUTHOR_NAME:Luca Ferrari|AUTHOR_EMAIL:fluca1978@gmail.com|DATE:2019-06-03 18:16:21 +0200|TITLE:Added blog post to README "use cases".|MESSAGE:
diff --git a/README.md b/README.md
index 41f7008..e425308 100644
--- a/README.md
+++ b/README.md
@@ -109,6 +109,7 @@ Articles showing possible ways of using pg_cron:
 * [Computing rollups in an analytical dashboard](https://www.citusdata.com/blog/2017/12/27/real-time-analytics-dashboards-with-citus/)
 * [Deleting old data, vacuum](https://www.citusdata.com/blog/2016/09/09/pgcron-run-periodic-jobs-in-postgres/)
 * [Feeding cats](http://bonesmoses.org/2016/09/09/pg-phriday-irrelevant-inclinations/)
+* [Routinely invoking a function](https://fluca1978.github.io/2019/05/21/pgcron.html)
 
 ## Advanced usage
 

COMMIT_HASH:71071d81a30103d5908933c358da8294fdbbde10|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2019-05-22 05:46:08 -0700|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 41f7008..c440a99 100644
--- a/README.md
+++ b/README.md
@@ -105,7 +105,7 @@ For security, jobs are executed in the database in which the `cron.schedule` fun
 
 Articles showing possible ways of using pg_cron:
 
-* [Auto-partitioning using pg_partman](https://www.citusdata.com/blog/2017/12/27/real-time-analytics-dashboards-with-citus/)
+* [Auto-partitioning using pg_partman](https://www.citusdata.com/blog/2018/01/24/citus-and-pg-partman-creating-a-scalable-time-series-database-on-PostgreSQL/)
 * [Computing rollups in an analytical dashboard](https://www.citusdata.com/blog/2017/12/27/real-time-analytics-dashboards-with-citus/)
 * [Deleting old data, vacuum](https://www.citusdata.com/blog/2016/09/09/pgcron-run-periodic-jobs-in-postgres/)
 * [Feeding cats](http://bonesmoses.org/2016/09/09/pg-phriday-irrelevant-inclinations/)

COMMIT_HASH:be1947db35ddd72e9f84beb6ac42023ce343c7a7|AUTHOR_NAME:Daniel Vérité|AUTHOR_EMAIL:dverite@gmail.com|DATE:2019-05-22 13:29:53 +0200|TITLE:Call AllocSetContextCreate() directly rather than through a macro.|MESSAGE:The macro was needed with early PostgreSQL versions in the 11.x
branch that introduced AllocSetContextCreateExtended().
Later this was simplified (see commit 13cd7209 in Postgres)
and starting with 12.x we must call AllocSetContextCreate()
again.

diff --git a/include/pg_cron.h b/include/pg_cron.h
index 2d4defa..6822ab4 100644
--- a/include/pg_cron.h
+++ b/include/pg_cron.h
@@ -14,10 +14,5 @@
 
 /* global settings */
 extern char *CronTableDatabaseName;
-#if (PG_VERSION_NUM < 110000)
-#define PgAllocSetContextCreate AllocSetContextCreate
-#else
-#define PgAllocSetContextCreate AllocSetContextCreateExtended
-#endif
 
 #endif
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 3faf0cd..8b0c928 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -91,7 +91,7 @@ InitializeJobMetadataCache(void)
 	/* watch for invalidation events */
 	CacheRegisterRelcacheCallback(InvalidateJobCacheCallback, (Datum) 0);
 
-	CronJobContext = PgAllocSetContextCreate(CurrentMemoryContext,
+	CronJobContext = AllocSetContextCreate(CurrentMemoryContext,
 											 "pg_cron job context",
 											 ALLOCSET_DEFAULT_MINSIZE,
 											 ALLOCSET_DEFAULT_INITSIZE,
diff --git a/src/pg_cron.c b/src/pg_cron.c
index f8241f8..369fef9 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -288,7 +288,7 @@ PgCronWorkerMain(Datum arg)
 	}
 
 
-	CronLoopContext = PgAllocSetContextCreate(CurrentMemoryContext,
+	CronLoopContext = AllocSetContextCreate(CurrentMemoryContext,
 											  "pg_cron loop context",
 											  ALLOCSET_DEFAULT_MINSIZE,
 											  ALLOCSET_DEFAULT_INITSIZE,
diff --git a/src/task_states.c b/src/task_states.c
index ddbd328..1084062 100644
--- a/src/task_states.c
+++ b/src/task_states.c
@@ -36,7 +36,7 @@ static HTAB *CronTaskHash = NULL;
 void
 InitializeTaskStateHash(void)
 {
-	CronTaskContext = PgAllocSetContextCreate(CurrentMemoryContext,
+	CronTaskContext = AllocSetContextCreate(CurrentMemoryContext,
 											  "pg_cron task context",
 											  ALLOCSET_DEFAULT_MINSIZE,
 											  ALLOCSET_DEFAULT_INITSIZE,

COMMIT_HASH:d032da7e99f26fdbea8aea3c8cbce8d9a9aa78e6|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2019-05-15 05:26:39 -0700|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 09207f6..41f7008 100644
--- a/README.md
+++ b/README.md
@@ -127,8 +127,8 @@ The following table keeps track of which of the major managed Postgres services
 
 | Service       | Supported     | Version  |
 | ------------- |:-------------:| --------:|
-| [Citus Cloud](https://www.citusdata.com/product/cloud)  | :heavy_check_mark: |   1.0    |
+| [Citus Cloud](https://www.citusdata.com/product/cloud)  | :heavy_check_mark: |   1.1.3    |
 | [Amazon RDS](https://aws.amazon.com/rds/postgresql/)     | :x:      |          |
-| [Azure](https://azure.microsoft.com/en-us/services/postgresql/) | :x:      |          |
+| [Azure](https://azure.microsoft.com/en-us/services/postgresql/) | :heavy_check_mark: for Hyperscale (Citus)   |  1.1.4 |
 | [Google Cloud](https://cloud.google.com/sql/docs/postgres/) | :x:      |          |
 | [Heroku](https://elements.heroku.com/addons/heroku-postgresql) | :x: | |

COMMIT_HASH:92e87855926c51910a3f434cf6c14a0a3b8c2ce0|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2019-03-31 12:16:20 +0200|TITLE:Add CHANGELOG entry for 1.1.4|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 3923490..c06f73f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,8 @@
+### pg_cron v1.1.4 (April 4, 2019) ###
+
+* Adds a cron.host setting to make the postgres host configurable
+* Fixes a bug that could cause segmentation fault after cron.unschedule
+
 ### pg_cron v1.1.3 (November 15, 2018) ###
 
 * Fixes a bug that causes pg_cron to run during pg_upgrade

COMMIT_HASH:23ffc0d53e62c9441834cb59ac1889351111a0ff|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2019-03-31 11:16:18 +0200|TITLE:Add default nodename GUC|MESSAGE:
diff --git a/include/job_metadata.h b/include/job_metadata.h
index 8300c07..06e9622 100644
--- a/include/job_metadata.h
+++ b/include/job_metadata.h
@@ -31,6 +31,7 @@ typedef struct CronJob
 
 
 /* global settings */
+extern char *CronHost;
 extern bool CronJobCacheValid;
 
 
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 069179e..3faf0cd 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -78,6 +78,7 @@ static MemoryContext CronJobContext = NULL;
 static HTAB *CronJobHash = NULL;
 static Oid CachedCronJobRelationId = InvalidOid;
 bool CronJobCacheValid = false;
+char *CronHost = "localhost";
 
 
 /*
@@ -199,7 +200,7 @@ cron_schedule(PG_FUNCTION_ARGS)
 	values[Anum_cron_job_jobid - 1] = jobIdDatum;
 	values[Anum_cron_job_schedule - 1] = CStringGetTextDatum(schedule);
 	values[Anum_cron_job_command - 1] = CStringGetTextDatum(command);
-	values[Anum_cron_job_nodename - 1] = CStringGetTextDatum("localhost");
+	values[Anum_cron_job_nodename - 1] = CStringGetTextDatum(CronHost);
 	values[Anum_cron_job_nodeport - 1] = Int32GetDatum(PostPortNumber);
 	values[Anum_cron_job_database - 1] = CStringGetTextDatum(CronTableDatabaseName);
 	values[Anum_cron_job_username - 1] = CStringGetTextDatum(userName);
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 5ea9616..f8241f8 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -174,6 +174,15 @@ _PG_init(void)
 		GUC_SUPERUSER_ONLY,
 		NULL, NULL, NULL);
 
+	DefineCustomStringVariable(
+		"cron.host",
+		gettext_noop("Hostname to connect to postgres."),
+		NULL,
+		&CronHost,
+		"localhost",
+		PGC_POSTMASTER,
+		GUC_SUPERUSER_ONLY,
+		NULL, NULL, NULL);
 
 	/* set up common data for all our workers */
 	worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;

COMMIT_HASH:6fbbd128903a0e5e4a2e86fda490d0cb1fae54e5|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2019-03-31 12:10:07 +0200|TITLE:Do not StartPendingRuns if a task is inactive|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 7a95e6c..5ea9616 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -395,6 +395,16 @@ StartAllPendingRuns(List *taskList, TimestampTz currentTime)
 	{
 		CronTask *task = (CronTask *) lfirst(taskCell);
 
+		if (!task->isActive)
+		{
+			/*
+			 * The job has been unscheduled, so we should not schedule
+			 * new runs. The task will be safely removed on the next call
+			 * to ManageCronTask.
+			 */
+			continue;
+		}
+
 		StartPendingRuns(task, clockProgress, lastMinute, currentTime);
 	}
 
@@ -424,7 +434,6 @@ StartPendingRuns(CronTask *task, ClockProgress clockProgress,
 	TimestampTz virtualTime = lastMinute;
 	TimestampTz currentMinute = TimestampMinuteStart(currentTime);
 
-
 	switch (clockProgress)
 	{
 		case CLOCK_PROGRESSED:

COMMIT_HASH:5aab8db479497ad286e1d1b6008ef198716e5684|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2019-03-12 18:35:45 +0100|TITLE:Merge pull request #71 from Airconaaron/master|MESSAGE:fixed readme spelling
COMMIT_HASH:970adcd120a5224f5e37b44213fc43d7d001e439|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2019-03-12 09:22:59 -0700|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 31935ff..70afd01 100644
--- a/README.md
+++ b/README.md
@@ -48,21 +48,21 @@ The code in pg_cron that handles parsing and scheduling comes directly from the
 
 ## Installing pg_cron
 
-Install on Red Hat, CentOS, Fedora, Amazon Linux with PostgreSQL 10:
+Install on Red Hat, CentOS, Fedora, Amazon Linux with PostgreSQL 11:
 
 ```bash
 # Add Citus Data package repository
 curl https://install.citusdata.com/community/rpm.sh | sudo bash
 
 # Install the pg_cron extension
-sudo yum install -y pg_cron_10
+sudo yum install -y pg_cron_11
 ```
 
-Install on Debian, Ubuntu with PostgreSQL 10 using [apt.postgresql.org](https://wiki.postgresql.org/wiki/Apt):
+Install on Debian, Ubuntu with PostgreSQL 11 using [apt.postgresql.org](https://wiki.postgresql.org/wiki/Apt):
 
 ```bash
 # Install the pg_cron extension
-sudo apt-get -y install postgresql-10-cron
+sudo apt-get -y install postgresql-11-cron
 ```
 
 You can also install pg_cron by building it from source:
@@ -71,7 +71,7 @@ You can also install pg_cron by building it from source:
 git clone https://github.com/citusdata/pg_cron.git
 cd pg_cron
 # Ensure pg_config is in your path, e.g.
-export PATH=/usr/pgsql-10/bin:$PATH
+export PATH=/usr/pgsql-11/bin:$PATH
 make && sudo PATH=$PATH make install
 ```
 

COMMIT_HASH:7395b489feb18bc0a10e30be37e7b79042a44079|AUTHOR_NAME:Airconaaron|AUTHOR_EMAIL:aaron@visenze.com|DATE:2019-01-28 14:20:58 +0800|TITLE:fixed readme spelling|MESSAGE:
diff --git a/README.md b/README.md
index 31935ff..6a432b1 100644
--- a/README.md
+++ b/README.md
@@ -18,7 +18,7 @@ SELECT cron.schedule('0 10 * * *', 'VACUUM');
  schedule
 ----------
        43
-    
+
 -- Stop scheduling a job
 SELECT cron.unschedule(43);
  unschedule
@@ -87,7 +87,7 @@ shared_preload_libraries = 'pg_cron'
 cron.database_name = 'postgres'
 ```
 
-After restarting PostgreSQL, you can create the pg_cron functions and metadata tables using `CREATE EXTENSION pg_cron`. 
+After restarting PostgreSQL, you can create the pg_cron functions and metadata tables using `CREATE EXTENSION pg_cron`.
 
 ```sql
 -- run as superuser:
@@ -106,7 +106,7 @@ For security, jobs are executed in the database in which the `cron.schedule` fun
 Articles showing possible ways of using pg_cron:
 
 * [Auto-partitioning using pg_partman](https://www.citusdata.com/blog/2017/12/27/real-time-analytics-dashboards-with-citus/)
-* [Computing rollups in an anlytical dashboard](https://www.citusdata.com/blog/2017/12/27/real-time-analytics-dashboards-with-citus/)
+* [Computing rollups in an analytical dashboard](https://www.citusdata.com/blog/2017/12/27/real-time-analytics-dashboards-with-citus/)
 * [Deleting old data, vacuum](https://www.citusdata.com/blog/2016/09/09/pgcron-run-periodic-jobs-in-postgres/)
 * [Feeding cats](http://bonesmoses.org/2016/09/09/pg-phriday-irrelevant-inclinations/)
 
@@ -123,7 +123,7 @@ You can use [.pgpass](https://www.postgresql.org/docs/current/static/libpq-pgpas
 
 ## Managed services
 
-The following table keeps track of which of the major managed Postgres services support pg_cron. 
+The following table keeps track of which of the major managed Postgres services support pg_cron.
 
 | Service       | Supported     | Version  |
 | ------------- |:-------------:| --------:|

COMMIT_HASH:c71b868043c6b4ba64f21de7653809d9fa4463cd|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2018-11-15 06:30:35 +0100|TITLE:Add CHANGELOG entry for 1.1.3|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 2dbab38..3923490 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,8 @@
+### pg_cron v1.1.3 (November 15, 2018) ###
+
+* Fixes a bug that causes pg_cron to run during pg_upgrade
+* Fixes a bug that causes pg_cron to show up incorrectly in pg_stat_activity in PG11
+
 ### pg_cron v1.1.2 (July 10, 2018) ###
 
 * PostgreSQL 11 support by dverite

COMMIT_HASH:5b5f5e4c930634b2ea0e9afbbe19a81ceb814df9|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2018-08-22 13:49:55 +0200|TITLE:Populate bgw_type in PostgreSQL 11|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index da5cd53..7a95e6c 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -186,7 +186,10 @@ _PG_init(void)
 	worker.bgw_notify_pid = 0;
 	sprintf(worker.bgw_library_name, "pg_cron");
 	sprintf(worker.bgw_function_name, "PgCronWorkerMain");
-	snprintf(worker.bgw_name, BGW_MAXLEN, "pg_cron_scheduler");
+	snprintf(worker.bgw_name, BGW_MAXLEN, "pg_cron scheduler");
+#if (PG_VERSION_NUM >= 110000)
+	snprintf(worker.bgw_type, BGW_MAXLEN, "pg_cron scheduler");
+#endif
 
 	RegisterBackgroundWorker(&worker);
 }

COMMIT_HASH:a62e67209fb0f5c1f224d9d222cb500b5e7ef9b3|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2018-08-22 13:32:43 +0200|TITLE:Do not activate background worker during binary upgrade|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index c0c6be9..da5cd53 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -130,6 +130,11 @@ _PG_init(void)
 {
 	BackgroundWorker worker;
 
+	if (IsBinaryUpgrade)
+	{
+		return;
+	}
+
 	if (!process_shared_preload_libraries_in_progress)
 	{
 		ereport(ERROR, (errmsg("pg_cron can only be loaded via shared_preload_libraries"),

COMMIT_HASH:0ee09078f25994ac5cd06859d2ea517d36a5e11e|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2018-07-10 12:43:47 +0200|TITLE:Add CHANGELOG entry for 1.1.2|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 73c98fb..2dbab38 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,8 @@
+### pg_cron v1.1.2 (July 10, 2018) ###
+
+* PostgreSQL 11 support by dverite
+* Fix a clang build error by kxjhlele
+
 ### pg_cron v1.1.1 (June 7, 2018) ###
 
 * Fixed a bug that would cause new jobs to be created as inactive

COMMIT_HASH:01e249b0a7113291742a9b665231c5cfec1d2c4f|AUTHOR_NAME:Goo|AUTHOR_EMAIL:liuwanle2010@gmail.com|DATE:2018-05-20 15:20:57 +0800|TITLE:clang build error -Wno-maybe-uninitialized|MESSAGE:clang build error
error: unknown warning option '-Wno-maybe-uninitialized'; did you mean '-Wno-uninitialized'? [-Werror,-Wunknown-warning-option]
diff --git a/Makefile b/Makefile
index 06b0c0f..04dfd0e 100644
--- a/Makefile
+++ b/Makefile
@@ -10,7 +10,11 @@ REGRESS = pg_cron-test
 # compilation configuration
 MODULE_big = $(EXTENSION)
 OBJS = $(patsubst %.c,%.o,$(wildcard src/*.c))
-PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-maybe-uninitialized -Wno-implicit-fallthrough -Iinclude -I$(libpq_srcdir)
+ifeq ($(CC),gcc)
+    PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-maybe-uninitialized -Wno-implicit-fallthrough -Iinclude -I$(libpq_srcdir)
+else
+    PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-implicit-fallthrough -Iinclude -I$(libpq_srcdir)
+endif
 SHLIB_LINK = $(libpq)
 EXTRA_CLEAN += $(addprefix src/,*.gcno *.gcda) # clean up after profiling runs
 

COMMIT_HASH:3f1776c68d535a65f87b3dc131bb14df1fe4438a|AUTHOR_NAME:Daniel Vérité|AUTHOR_EMAIL:dverite@gmail.com|DATE:2018-05-21 16:07:16 +0200|TITLE:Changes for PostgreSQL 11.|MESSAGE:- AllocSetContextCreate() becomes AllocSetContextCreateExtended().
- ACL_KIND_CLASS replaced by OBJECT_TABLE in aclcheck_error().
- BackgroundWorkerInitializeConnection() takes a new flag parameter.

diff --git a/include/pg_cron.h b/include/pg_cron.h
index 437de1f..2d4defa 100644
--- a/include/pg_cron.h
+++ b/include/pg_cron.h
@@ -14,6 +14,10 @@
 
 /* global settings */
 extern char *CronTableDatabaseName;
-
+#if (PG_VERSION_NUM < 110000)
+#define PgAllocSetContextCreate AllocSetContextCreate
+#else
+#define PgAllocSetContextCreate AllocSetContextCreateExtended
+#endif
 
 #endif
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 8eea450..069179e 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -90,11 +90,11 @@ InitializeJobMetadataCache(void)
 	/* watch for invalidation events */
 	CacheRegisterRelcacheCallback(InvalidateJobCacheCallback, (Datum) 0);
 
-	CronJobContext = AllocSetContextCreate(CurrentMemoryContext,
-										   "pg_cron job context",
-										   ALLOCSET_DEFAULT_MINSIZE,
-										   ALLOCSET_DEFAULT_INITSIZE,
-										   ALLOCSET_DEFAULT_MAXSIZE);
+	CronJobContext = PgAllocSetContextCreate(CurrentMemoryContext,
+											 "pg_cron job context",
+											 ALLOCSET_DEFAULT_MINSIZE,
+											 ALLOCSET_DEFAULT_INITSIZE,
+											 ALLOCSET_DEFAULT_MAXSIZE);
 
 	CronJobHash = CreateCronJobHash();
 }
@@ -369,7 +369,12 @@ cron_unschedule(PG_FUNCTION_ARGS)
 												ACL_DELETE);
 		if (aclResult != ACLCHECK_OK)
 		{
-			aclcheck_error(aclResult, ACL_KIND_CLASS,
+			aclcheck_error(aclResult,
+#if (PG_VERSION_NUM < 110000)
+						   ACL_KIND_CLASS,
+#else
+						   OBJECT_TABLE,
+#endif
 						   get_rel_name(CronJobRelationId()));
 		}
 	}
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 1ef453c..c0c6be9 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -239,7 +239,11 @@ PgCronWorkerMain(Datum arg)
 	BackgroundWorkerUnblockSignals();
 
 	/* Connect to our database */
+#if (PG_VERSION_NUM < 110000)
 	BackgroundWorkerInitializeConnection(CronTableDatabaseName, NULL);
+#else
+	BackgroundWorkerInitializeConnection(CronTableDatabaseName, NULL, 0);
+#endif
 
 	/* Make pg_cron recognisable in pg_stat_activity */
 	pgstat_report_appname("pg_cron scheduler");
@@ -266,12 +270,12 @@ PgCronWorkerMain(Datum arg)
 		MaxRunningTasks = 1;
 	}
 
-	CronLoopContext = AllocSetContextCreate(CurrentMemoryContext,
-											"pg_cron loop context",
-											ALLOCSET_DEFAULT_MINSIZE,
-											ALLOCSET_DEFAULT_INITSIZE,
-											ALLOCSET_DEFAULT_MAXSIZE);
 
+	CronLoopContext = PgAllocSetContextCreate(CurrentMemoryContext,
+											  "pg_cron loop context",
+											  ALLOCSET_DEFAULT_MINSIZE,
+											  ALLOCSET_DEFAULT_INITSIZE,
+											  ALLOCSET_DEFAULT_MAXSIZE);
 	InitializeJobMetadataCache();
 	InitializeTaskStateHash();
 
diff --git a/src/task_states.c b/src/task_states.c
index c02e097..ddbd328 100644
--- a/src/task_states.c
+++ b/src/task_states.c
@@ -36,11 +36,11 @@ static HTAB *CronTaskHash = NULL;
 void
 InitializeTaskStateHash(void)
 {
-	CronTaskContext = AllocSetContextCreate(CurrentMemoryContext,
-											"pg_cron task context",
-											ALLOCSET_DEFAULT_MINSIZE,
-											ALLOCSET_DEFAULT_INITSIZE,
-											ALLOCSET_DEFAULT_MAXSIZE);
+	CronTaskContext = PgAllocSetContextCreate(CurrentMemoryContext,
+											  "pg_cron task context",
+											  ALLOCSET_DEFAULT_MINSIZE,
+											  ALLOCSET_DEFAULT_INITSIZE,
+											  ALLOCSET_DEFAULT_MAXSIZE);
 
 	CronTaskHash = CreateCronTaskHash();
 }

COMMIT_HASH:9d86b82abbb535906197bfdb581fcee070408a7d|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2018-06-07 14:07:51 +0200|TITLE:Add CHANGELOG entry for 1.1.1|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 327815d..73c98fb 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,7 @@
+### pg_cron v1.1.1 (June 7, 2018) ###
+
+* Fixed a bug that would cause new jobs to be created as inactive
+
 ### pg_cron v1.1.0 (March 22, 2018) ###
 
 * Add new 'active' column on cron.job table to enable or disable job(s).

COMMIT_HASH:f1e5e598cfc772b04907368e7dd05679da69c3a7|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2018-06-07 14:06:30 +0200|TITLE:Set active column to true when adding a job|MESSAGE:
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 1a65ce5..8eea450 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -203,6 +203,7 @@ cron_schedule(PG_FUNCTION_ARGS)
 	values[Anum_cron_job_nodeport - 1] = Int32GetDatum(PostPortNumber);
 	values[Anum_cron_job_database - 1] = CStringGetTextDatum(CronTableDatabaseName);
 	values[Anum_cron_job_username - 1] = CStringGetTextDatum(userName);
+	values[Anum_cron_job_active - 1] = BoolGetDatum(true);
 
 	cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
 	cronJobsRelationId = get_relname_relid(JOBS_TABLE_NAME, cronSchemaId);

COMMIT_HASH:7078c083cefea950286c51497847e41dc151be6d|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2018-05-03 01:59:01 +0200|TITLE:Set application_name of the scheduler in pg_stat_activity|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5725f74..327815d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -2,6 +2,7 @@
 
 * Add new 'active' column on cron.job table to enable or disable job(s).
 * Added a regression test, simply run 'make installcheck'
+* Set relevant application_name in pg_stat_activity
 * Increased pg_cron version to 1.1
 
 ### pg_cron v1.0.2 (October 6, 2017) ###
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 58ca9ac..1ef453c 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -241,6 +241,9 @@ PgCronWorkerMain(Datum arg)
 	/* Connect to our database */
 	BackgroundWorkerInitializeConnection(CronTableDatabaseName, NULL);
 
+	/* Make pg_cron recognisable in pg_stat_activity */
+	pgstat_report_appname("pg_cron scheduler");
+
 	/* Determine how many tasks we can run concurrently */
 	if (MaxConnections < MaxRunningTasks)
 	{

COMMIT_HASH:7589248a418f16f37d181bbee7e9a093648f7d90|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2018-05-03 08:59:09 +0200|TITLE:Merge pull request #47 from Voipfuture-GmbH/master|MESSAGE:Add a 'active' column on con.job table to simply enable and disable jobs
COMMIT_HASH:0305160449e4ea2b7f4862ad88b26f055d7fbc74|AUTHOR_NAME:Sven Stadler|AUTHOR_EMAIL:sven.stadler@voipfuture.com|DATE:2018-04-10 08:24:12 +0200|TITLE:o omit the exception handler in pg_cron 1.1 upgrade file o removed unneeded REGRESS_OPTS from Makefile o add cron.schedule and cron.unschedule to regression test o removed some odd extra newlines|MESSAGE:
diff --git a/Makefile b/Makefile
index f659820..06b0c0f 100644
--- a/Makefile
+++ b/Makefile
@@ -6,7 +6,6 @@ EXTVERSION = 1.1
 DATA_built = $(EXTENSION)--$(EXTVERSION).sql $(EXTENSION)--1.0.sql
 DATA = $(wildcard $(EXTENSION)--*--*.sql)
 REGRESS = pg_cron-test 
-REGRESS_OPTS = --dbname=postgres
 
 # compilation configuration
 MODULE_big = $(EXTENSION)
diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
index a8c299c..1711758 100644
--- a/expected/pg_cron-test.out
+++ b/expected/pg_cron-test.out
@@ -12,4 +12,18 @@ SELECT extversion FROM pg_extension WHERE extname='pg_cron';
  1.1
 (1 row)
 
+-- Vacuum every day at 10:00am (GMT)
+SELECT cron.schedule('0 10 * * *', 'VACUUM');
+ schedule 
+----------
+        1
+(1 row)
+
+-- Stop scheduling a job
+SELECT cron.unschedule(1);
+ unschedule 
+------------
+ t
+(1 row)
+
 DROP EXTENSION pg_cron;
diff --git a/pg_cron--1.0--1.1.sql b/pg_cron--1.0--1.1.sql
index 31dda23..6c84dfa 100644
--- a/pg_cron--1.0--1.1.sql
+++ b/pg_cron--1.0--1.1.sql
@@ -1,12 +1,3 @@
 /* pg_cron--1.0--1.1.sql */
 
-DO $$ 
-BEGIN
-    BEGIN
-        ALTER TABLE cron.job ADD COLUMN active boolean not null default 'true';
-    EXCEPTION
-        WHEN duplicate_column THEN RAISE NOTICE 'column <active> already exists in <cron.job>.';
-    END;
-END;
-$$
-
+ALTER TABLE cron.job ADD COLUMN active boolean not null default 'true';
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
index 2bf35a8..aa05faa 100644
--- a/sql/pg_cron-test.sql
+++ b/sql/pg_cron-test.sql
@@ -2,4 +2,11 @@ CREATE EXTENSION pg_cron VERSION '1.0';
 SELECT extversion FROM pg_extension WHERE extname='pg_cron';
 ALTER EXTENSION pg_cron UPDATE TO '1.1';
 SELECT extversion FROM pg_extension WHERE extname='pg_cron';
+
+-- Vacuum every day at 10:00am (GMT)
+SELECT cron.schedule('0 10 * * *', 'VACUUM');
+
+-- Stop scheduling a job
+SELECT cron.unschedule(1);
+
 DROP EXTENSION pg_cron;
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 3495ce5..1a65ce5 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -163,7 +163,6 @@ cron_schedule(PG_FUNCTION_ARGS)
 
 	char *schedule = text_to_cstring(scheduleText);
 	char *command = text_to_cstring(commandText);
-
 	entry *parsedSchedule = NULL;
 
 	int64 jobId = 0;
@@ -205,7 +204,6 @@ cron_schedule(PG_FUNCTION_ARGS)
 	values[Anum_cron_job_database - 1] = CStringGetTextDatum(CronTableDatabaseName);
 	values[Anum_cron_job_username - 1] = CStringGetTextDatum(userName);
 
-
 	cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
 	cronJobsRelationId = get_relname_relid(JOBS_TABLE_NAME, cronSchemaId);
 
@@ -557,8 +555,6 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 								  tupleDescriptor, &isNull);
 	Datum userName = heap_getattr(heapTuple, Anum_cron_job_username,
 								  tupleDescriptor, &isNull);
-	Datum active = heap_getattr(heapTuple, Anum_cron_job_active,
-                                                                  tupleDescriptor, &isNull);
 
 	Assert(!HeapTupleHasNulls(heapTuple));
 
@@ -572,7 +568,18 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 	job->nodePort = DatumGetInt32(nodePort);
 	job->userName = TextDatumGetCString(userName);
 	job->database = TextDatumGetCString(database);
-	job->active = DatumGetBool(active);
+
+	if (HeapTupleHeaderGetNatts(heapTuple->t_data) >= Anum_cron_job_active)
+	{
+		Datum active = heap_getattr(heapTuple, Anum_cron_job_active,
+								tupleDescriptor, &isNull);
+		Assert(!isNull);
+		job->active = DatumGetBool(active);
+	}
+	else
+	{
+		job->active = true;
+	}
 
 	parsedSchedule = parse_cron_entry(job->scheduleText);
 	if (parsedSchedule != NULL)

COMMIT_HASH:dc4b118438c1c7f1e1468c02d4d222a9ddd408a4|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2018-03-30 12:57:45 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 4281c5a..31935ff 100644
--- a/README.md
+++ b/README.md
@@ -101,15 +101,34 @@ GRANT USAGE ON SCHEMA cron TO marco;
 
 For security, jobs are executed in the database in which the `cron.schedule` function is called with the same permissions as the current user. In addition, users are only able to see their own jobs in the `cron.job` table.
 
-## Advanced usage
+## Example use cases
+
+Articles showing possible ways of using pg_cron:
 
-Since pg_cron uses libpq, you can also run periodic jobs on other databases or other machines. This can be especially useful when you are using the [Citus extension](https://www.citusdata.com/product) to distribute tables across many PostgreSQL servers and need to run periodic jobs across all of them.
+* [Auto-partitioning using pg_partman](https://www.citusdata.com/blog/2017/12/27/real-time-analytics-dashboards-with-citus/)
+* [Computing rollups in an anlytical dashboard](https://www.citusdata.com/blog/2017/12/27/real-time-analytics-dashboards-with-citus/)
+* [Deleting old data, vacuum](https://www.citusdata.com/blog/2016/09/09/pgcron-run-periodic-jobs-in-postgres/)
+* [Feeding cats](http://bonesmoses.org/2016/09/09/pg-phriday-irrelevant-inclinations/)
+
+## Advanced usage
 
-If you are superuser, then you can manually modify the `cron.job` table and use custom values for nodename and nodeport to connect to a different machine:
+Since pg_cron uses libpq, you can also run periodic jobs on other databases or other machines. If you are superuser, then you can manually modify the `cron.job` table and use custom values for nodename and nodeport to connect to a different machine:
 
 ```sql
 INSERT INTO cron.job (schedule, command, nodename, nodeport, database, username)
-VALUES ('0 4 * * *', 'VACUUM', 'worker-node-1', 5432, 'postgres', 'marco');
+VALUES ('0 4 * * *', 'VACUUM', 'node-1', 5432, 'postgres', 'marco');
 ```
 
 You can use [.pgpass](https://www.postgresql.org/docs/current/static/libpq-pgpass.html) to allow pg_cron to authenticate with the remote server.
+
+## Managed services
+
+The following table keeps track of which of the major managed Postgres services support pg_cron. 
+
+| Service       | Supported     | Version  |
+| ------------- |:-------------:| --------:|
+| [Citus Cloud](https://www.citusdata.com/product/cloud)  | :heavy_check_mark: |   1.0    |
+| [Amazon RDS](https://aws.amazon.com/rds/postgresql/)     | :x:      |          |
+| [Azure](https://azure.microsoft.com/en-us/services/postgresql/) | :x:      |          |
+| [Google Cloud](https://cloud.google.com/sql/docs/postgres/) | :x:      |          |
+| [Heroku](https://elements.heroku.com/addons/heroku-postgresql) | :x: | |

COMMIT_HASH:84f9f17d1f70997b2f5e7da95ed94cc2a05ddfec|AUTHOR_NAME:Sven Stadler|AUTHOR_EMAIL:sven.stadler@voipfuture.com|DATE:2018-03-21 14:55:56 +0100|TITLE:o To be able to switch on and off cron.job(s) we introduced a new   column 'active' on cron.job table. This allows us to simply enable   or disable a job without modifiing the schedule. o In addition a regression test was added to test the upgrade path.   Simply run 'make installcheck' to execute the test. o Increased pg_cron version to 1.1.|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5209fc0..5725f74 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,9 @@
+### pg_cron v1.1.0 (March 22, 2018) ###
+
+* Add new 'active' column on cron.job table to enable or disable job(s).
+* Added a regression test, simply run 'make installcheck'
+* Increased pg_cron version to 1.1
+
 ### pg_cron v1.0.2 (October 6, 2017) ###
 
 * PostgreSQL 10 support
diff --git a/Makefile b/Makefile
index 4f537e2..f659820 100644
--- a/Makefile
+++ b/Makefile
@@ -1,10 +1,12 @@
 # src/test/modules/pg_cron/Makefile
 
 EXTENSION = pg_cron
-EXTVERSION = 1.0
+EXTVERSION = 1.1
 
-DATA_built = $(EXTENSION)--$(EXTVERSION).sql
+DATA_built = $(EXTENSION)--$(EXTVERSION).sql $(EXTENSION)--1.0.sql
 DATA = $(wildcard $(EXTENSION)--*--*.sql)
+REGRESS = pg_cron-test 
+REGRESS_OPTS = --dbname=postgres
 
 # compilation configuration
 MODULE_big = $(EXTENSION)
@@ -19,3 +21,5 @@ include $(PGXS)
 
 $(EXTENSION)--1.0.sql: $(EXTENSION).sql $(EXTENSION)--0.1--1.0.sql
 	cat $^ > $@
+$(EXTENSION)--1.1.sql: $(EXTENSION).sql $(EXTENSION)--1.0--1.1.sql
+	cat $^ > $@
diff --git a/expected/pg_cron-test.out b/expected/pg_cron-test.out
new file mode 100644
index 0000000..a8c299c
--- /dev/null
+++ b/expected/pg_cron-test.out
@@ -0,0 +1,15 @@
+CREATE EXTENSION pg_cron VERSION '1.0';
+SELECT extversion FROM pg_extension WHERE extname='pg_cron';
+ extversion 
+------------
+ 1.0
+(1 row)
+
+ALTER EXTENSION pg_cron UPDATE TO '1.1';
+SELECT extversion FROM pg_extension WHERE extname='pg_cron';
+ extversion 
+------------
+ 1.1
+(1 row)
+
+DROP EXTENSION pg_cron;
diff --git a/include/cron_job.h b/include/cron_job.h
index 661382d..638db76 100644
--- a/include/cron_job.h
+++ b/include/cron_job.h
@@ -26,6 +26,7 @@ typedef struct FormData_cron_job
 	int nodePort;
 	text database;
 	text userName;
+	bool active;
 #endif
 } FormData_cron_job;
 
@@ -40,7 +41,7 @@ typedef FormData_cron_job *Form_cron_job;
  *      compiler constants for cron_job
  * ----------------
  */
-#define Natts_cron_job 7
+#define Natts_cron_job 8
 #define Anum_cron_job_jobid 1
 #define Anum_cron_job_schedule 2
 #define Anum_cron_job_command 3
@@ -48,6 +49,7 @@ typedef FormData_cron_job *Form_cron_job;
 #define Anum_cron_job_nodeport 5
 #define Anum_cron_job_database 6
 #define Anum_cron_job_username 7
+#define Anum_cron_job_active 8
 
 
 #endif /* CRON_JOB_H */
diff --git a/include/job_metadata.h b/include/job_metadata.h
index 5a67771..8300c07 100644
--- a/include/job_metadata.h
+++ b/include/job_metadata.h
@@ -26,6 +26,7 @@ typedef struct CronJob
 	int nodePort;
 	char *database;
 	char *userName;
+	bool active;
 } CronJob;
 
 
diff --git a/pg_cron--1.0--1.1.sql b/pg_cron--1.0--1.1.sql
new file mode 100644
index 0000000..31dda23
--- /dev/null
+++ b/pg_cron--1.0--1.1.sql
@@ -0,0 +1,12 @@
+/* pg_cron--1.0--1.1.sql */
+
+DO $$ 
+BEGIN
+    BEGIN
+        ALTER TABLE cron.job ADD COLUMN active boolean not null default 'true';
+    EXCEPTION
+        WHEN duplicate_column THEN RAISE NOTICE 'column <active> already exists in <cron.job>.';
+    END;
+END;
+$$
+
diff --git a/pg_cron.control b/pg_cron.control
index b523c15..aaf4214 100644
--- a/pg_cron.control
+++ b/pg_cron.control
@@ -1,4 +1,4 @@
 comment = 'Job scheduler for PostgreSQL'
-default_version = '1.0'
+default_version = '1.1'
 module_pathname = '$libdir/pg_cron'
 relocatable = false
diff --git a/pg_cron.sql b/pg_cron.sql
index 4c90ebc..74193cf 100644
--- a/pg_cron.sql
+++ b/pg_cron.sql
@@ -1,6 +1,6 @@
 DO $$
 BEGIN
-   IF current_database() <> current_setting('cron.database_name') THEN
+   IF current_database() <> current_setting('cron.database_name') AND current_database() <> 'contrib_regression' THEN
       RAISE EXCEPTION 'can only create extension in database %',
                       current_setting('cron.database_name')
       USING DETAIL = 'Jobs must be scheduled from the database configured in '||
diff --git a/sql/pg_cron-test.sql b/sql/pg_cron-test.sql
new file mode 100644
index 0000000..2bf35a8
--- /dev/null
+++ b/sql/pg_cron-test.sql
@@ -0,0 +1,5 @@
+CREATE EXTENSION pg_cron VERSION '1.0';
+SELECT extversion FROM pg_extension WHERE extname='pg_cron';
+ALTER EXTENSION pg_cron UPDATE TO '1.1';
+SELECT extversion FROM pg_extension WHERE extname='pg_cron';
+DROP EXTENSION pg_cron;
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 012d93a..3495ce5 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -163,6 +163,7 @@ cron_schedule(PG_FUNCTION_ARGS)
 
 	char *schedule = text_to_cstring(scheduleText);
 	char *command = text_to_cstring(commandText);
+
 	entry *parsedSchedule = NULL;
 
 	int64 jobId = 0;
@@ -204,6 +205,7 @@ cron_schedule(PG_FUNCTION_ARGS)
 	values[Anum_cron_job_database - 1] = CStringGetTextDatum(CronTableDatabaseName);
 	values[Anum_cron_job_username - 1] = CStringGetTextDatum(userName);
 
+
 	cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
 	cronJobsRelationId = get_relname_relid(JOBS_TABLE_NAME, cronSchemaId);
 
@@ -555,6 +557,8 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 								  tupleDescriptor, &isNull);
 	Datum userName = heap_getattr(heapTuple, Anum_cron_job_username,
 								  tupleDescriptor, &isNull);
+	Datum active = heap_getattr(heapTuple, Anum_cron_job_active,
+                                                                  tupleDescriptor, &isNull);
 
 	Assert(!HeapTupleHasNulls(heapTuple));
 
@@ -568,6 +572,7 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 	job->nodePort = DatumGetInt32(nodePort);
 	job->userName = TextDatumGetCString(userName);
 	job->database = TextDatumGetCString(database);
+	job->active = DatumGetBool(active);
 
 	parsedSchedule = parse_cron_entry(job->scheduleText);
 	if (parsedSchedule != NULL)
diff --git a/src/task_states.c b/src/task_states.c
index 8f38871..c02e097 100644
--- a/src/task_states.c
+++ b/src/task_states.c
@@ -100,7 +100,7 @@ RefreshTaskHash(void)
 		CronJob *job = (CronJob *) lfirst(jobCell);
 
 		CronTask *task = GetCronTask(job->jobId);
-		task->isActive = true;
+		task->isActive = job->active;
 	}
 
 	CronJobCacheValid = true;

COMMIT_HASH:9daf292918caebe3956df5d25b01eba2a92d1a76|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2017-11-27 21:40:00 +0100|TITLE:Merge pull request #40 from credativ/porting-fixes|MESSAGE:Porting fixes
COMMIT_HASH:f7208a2e342a84ca95f1af66940a1b4c88d4d899|AUTHOR_NAME:Christoph Berg|AUTHOR_EMAIL:christoph.berg@credativ.de|DATE:2017-11-27 11:00:48 +0100|TITLE:Correctly handle jobId as 64bit int|MESSAGE:jobId is a signed 64bit integer in the database, correctly handle it as
such on the C side. Use INT64_FORMAT to replace %ld in errmsg(), and
consistently use DatumGetInt64.

diff --git a/src/job_metadata.c b/src/job_metadata.c
index d9a5879..012d93a 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -262,7 +262,7 @@ NextJobId(void)
 
 	SetUserIdAndSecContext(savedUserId, savedSecurityContext);
 
-	jobId = DatumGetUInt32(jobIdDatum);
+	jobId = DatumGetInt64(jobIdDatum);
 
 	return jobId;
 }
@@ -351,7 +351,7 @@ cron_unschedule(PG_FUNCTION_ARGS)
 	if (!HeapTupleIsValid(heapTuple))
 	{
 		ereport(ERROR, (errmsg("could not find valid entry for job "
-							   UINT64_FORMAT, jobId)));
+							   INT64_FORMAT, jobId)));
 	}
 
 	/* check if the current user owns the row */
@@ -558,14 +558,14 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 
 	Assert(!HeapTupleHasNulls(heapTuple));
 
-	jobKey = DatumGetUInt32(jobId);
+	jobKey = DatumGetInt64(jobId);
 	job = hash_search(CronJobHash, &jobKey, HASH_ENTER, &isPresent);
 
-	job->jobId = DatumGetUInt32(jobId);
+	job->jobId = DatumGetInt64(jobId);
 	job->scheduleText = TextDatumGetCString(schedule);
 	job->command = TextDatumGetCString(command);
 	job->nodeName = TextDatumGetCString(nodeName);
-	job->nodePort = DatumGetUInt32(nodePort);
+	job->nodePort = DatumGetInt32(nodePort);
 	job->userName = TextDatumGetCString(userName);
 	job->database = TextDatumGetCString(database);
 
@@ -579,8 +579,8 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 	}
 	else
 	{
-		ereport(LOG, (errmsg("invalid pg_cron schedule for job %ld: %s",
-							 jobId, job->scheduleText)));
+		ereport(LOG, (errmsg("invalid pg_cron schedule for job " INT64_FORMAT ": %s",
+							 job->jobId, job->scheduleText)));
 
 		/* a zeroed out schedule never runs */
 		memset(&job->schedule, 0, sizeof(entry));
diff --git a/src/pg_cron.c b/src/pg_cron.c
index c1ded45..58ca9ac 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -912,7 +912,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			{
 				char *command = cronJob->command;
 
-				ereport(LOG, (errmsg("cron job %ld starting: %s",
+				ereport(LOG, (errmsg("cron job " INT64_FORMAT " starting: %s",
 									 jobId, command)));
 			}
 
@@ -1119,7 +1119,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 							char *cmdStatus = PQcmdStatus(result);
 							char *cmdTuples = PQcmdTuples(result);
 
-							ereport(LOG, (errmsg("cron job %ld completed: %s %s",
+							ereport(LOG, (errmsg("cron job " INT64_FORMAT " completed: %s %s",
 												 jobId, cmdStatus, cmdTuples)));
 						}
 
@@ -1165,7 +1165,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 							char *rowString = ngettext("row", "rows",
 													   tupleCount);
 
-							ereport(LOG, (errmsg("cron job %ld completed: "
+							ereport(LOG, (errmsg("cron job " INT64_FORMAT " completed: "
 												 "%d %s",
 												 jobId, tupleCount,
 												 rowString)));
@@ -1206,7 +1206,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 			if (task->errorMessage != NULL)
 			{
-				ereport(LOG, (errmsg("cron job %ld %s",
+				ereport(LOG, (errmsg("cron job " INT64_FORMAT " %s",
 									 jobId, task->errorMessage)));
 
 				if (task->freeErrorMessage)
@@ -1216,7 +1216,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			}
 			else
 			{
-				ereport(LOG, (errmsg("cron job %ld failed", jobId)));
+				ereport(LOG, (errmsg("cron job " INT64_FORMAT " failed", jobId)));
 			}
 
 			task->startDeadline = 0;

COMMIT_HASH:8165d9a30d02adf2a2ae85901869f8d2918e3bf9|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2017-11-27 18:17:52 +0100|TITLE:Update README.md with Debian instructions|MESSAGE:
diff --git a/README.md b/README.md
index 31873db..4281c5a 100644
--- a/README.md
+++ b/README.md
@@ -48,27 +48,22 @@ The code in pg_cron that handles parsing and scheduling comes directly from the
 
 ## Installing pg_cron
 
-Install on Red Hat, CentOS, Fedora, Amazon Linux with PostgreSQL 9.6:
+Install on Red Hat, CentOS, Fedora, Amazon Linux with PostgreSQL 10:
 
 ```bash
 # Add Citus Data package repository
 curl https://install.citusdata.com/community/rpm.sh | sudo bash
 
 # Install the pg_cron extension
-sudo yum install -y pg_cron_96
+sudo yum install -y pg_cron_10
 ```
-<!---
 
-Install on Debian, Ubuntu with PostgreSQL 9.6:
+Install on Debian, Ubuntu with PostgreSQL 10 using [apt.postgresql.org](https://wiki.postgresql.org/wiki/Apt):
 
 ```bash
-# Add Citus Data package repository
-curl https://install.citusdata.com/community/deb.sh | sudo bash
-
 # Install the pg_cron extension
-sudo apt-get -y install postgresql-9.6-pgcron
+sudo apt-get -y install postgresql-10-cron
 ```
--->
 
 You can also install pg_cron by building it from source:
 
@@ -76,20 +71,23 @@ You can also install pg_cron by building it from source:
 git clone https://github.com/citusdata/pg_cron.git
 cd pg_cron
 # Ensure pg_config is in your path, e.g.
-export PATH=/usr/pgsql-9.6/bin:$PATH
+export PATH=/usr/pgsql-10/bin:$PATH
 make && sudo PATH=$PATH make install
 ```
 
 ## Setting up pg_cron
 
- To start the pg_cron background worker when PostgreSQL starts, you need to add pg_cron to `shared_preload_libraries` in postgresql.conf and restart PostgreSQL. Note that pg_cron does not run any jobs as a long a server is in [hot standby](https://www.postgresql.org/docs/current/static/hot-standby.html) mode, but it automatically starts when the server is promoted.
+To start the pg_cron background worker when PostgreSQL starts, you need to add pg_cron to `shared_preload_libraries` in postgresql.conf. Note that pg_cron does not run any jobs as a long a server is in [hot standby](https://www.postgresql.org/docs/current/static/hot-standby.html) mode, but it automatically starts when the server is promoted.
+
+By default, the pg_cron background worker expects its metadata tables to be created in the "postgres" database. However, you can configure this by setting the `cron.database_name` configuration parameter in postgresql.conf.
 
 ```
 # add to postgresql.conf:
 shared_preload_libraries = 'pg_cron'
+cron.database_name = 'postgres'
 ```
 
-After restarting PostgreSQL, you can create the pg_cron functions and metadata tables using `CREATE EXTENSION pg_cron`. By default, the pg_cron background worker expects its metadata tables to be created in the "postgres" database. However, you can configure this by setting the `cron.database_name` configuration parameter in postgresql.conf.
+After restarting PostgreSQL, you can create the pg_cron functions and metadata tables using `CREATE EXTENSION pg_cron`. 
 
 ```sql
 -- run as superuser:
@@ -99,7 +97,7 @@ CREATE EXTENSION pg_cron;
 GRANT USAGE ON SCHEMA cron TO marco;
 ```
 
-Internally, pg_cron uses libpq to open a new connection to the local database. It may be necessary to enable `trust` authentication for connections coming from localhost in [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html) for the user running the cron job. Alternatively, you can add the password to a [.pgpass file](https://www.postgresql.org/docs/current/static/libpq-pgpass.html), which libpq will use when opening a connection.
+**Important**: Internally, pg_cron uses libpq to open a new connection to the local database. It may be necessary to enable `trust` authentication for connections coming from localhost in [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html) for the user running the cron job. Alternatively, you can add the password to a [.pgpass file](https://www.postgresql.org/docs/current/static/libpq-pgpass.html), which libpq will use when opening a connection.
 
 For security, jobs are executed in the database in which the `cron.schedule` function is called with the same permissions as the current user. In addition, users are only able to see their own jobs in the `cron.job` table.
 

COMMIT_HASH:fda5845fa54ead26a4b8c65d53a70201b094f163|AUTHOR_NAME:Christoph Berg|AUTHOR_EMAIL:christoph.berg@credativ.de|DATE:2017-11-27 10:58:47 +0100|TITLE:Suppress warnings about maybe uninitialized variables in entry.c|MESSAGE:Ubuntu's gcc on ppc64el thinks num1/num2/num3 might be uninitialized in
entry.c, which is fatal because of -Werror. Suppress the warnings using
-Wno-maybe-uninitialized.

diff --git a/Makefile b/Makefile
index 7365dbc..4f537e2 100644
--- a/Makefile
+++ b/Makefile
@@ -9,7 +9,7 @@ DATA = $(wildcard $(EXTENSION)--*--*.sql)
 # compilation configuration
 MODULE_big = $(EXTENSION)
 OBJS = $(patsubst %.c,%.o,$(wildcard src/*.c))
-PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter  -Wno-implicit-fallthrough -Iinclude -I$(libpq_srcdir)
+PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-maybe-uninitialized -Wno-implicit-fallthrough -Iinclude -I$(libpq_srcdir)
 SHLIB_LINK = $(libpq)
 EXTRA_CLEAN += $(addprefix src/,*.gcno *.gcda) # clean up after profiling runs
 

COMMIT_HASH:c12e786950c070066b948e4dfe42fd1004f3af32|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2017-10-06 09:52:32 +0200|TITLE:Add 1.0.2 CHANGELOG entry|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index af4f98c..5209fc0 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,9 @@
+### pg_cron v1.0.2 (October 6, 2017) ###
+
+* PostgreSQL 10 support
+* Restrict the maximum number of concurrent tasks
+* Ensure table locks on cron.job are kept after schedule/unschedule
+
 ### pg_cron v1.0.1 (June 30, 2017) ###
 
 * Fixes a memory leak that occurs when a connection fails immediately

COMMIT_HASH:02059dcec54e4b73472986c2ddf007f1aced1bd4|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2017-06-02 14:24:27 +0200|TITLE:Restrict number of tasks that can run concurrently|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index a66944a..c1ded45 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -8,6 +8,7 @@
  *
  *-------------------------------------------------------------------------
  */
+#include <sys/resource.h>
 
 #include "postgres.h"
 #include "fmgr.h"
@@ -98,7 +99,9 @@ static bool ShouldRunTask(entry *schedule, TimestampTz currentMinute,
 						  bool doWild, bool doNonWild);
 
 static void WaitForCronTasks(List *taskList);
+static void WaitForLatch(int timeoutMs);
 static void PollForTasks(List *taskList);
+static bool CanStartTask(CronTask *task);
 static void ManageCronTasks(List *taskList, TimestampTz currentTime);
 static void ManageCronTask(CronTask *task, TimestampTz currentTime);
 
@@ -115,6 +118,8 @@ static int64 RunCount = 0; /* counter for assigning unique run IDs */
 static int CronTaskStartTimeout = 10000; /* maximum connection time */
 static const int MaxWait = 1000; /* maximum time in ms that poll() can block */
 static bool RebootJobsScheduled = false;
+static int RunningTaskCount = 0;
+static int MaxRunningTasks = 0;
 
 
 /*
@@ -152,6 +157,19 @@ _PG_init(void)
 		GUC_SUPERUSER_ONLY,
 		NULL, NULL, NULL);
 
+	DefineCustomIntVariable(
+		"cron.max_running_jobs",
+		gettext_noop("Maximum number of jobs that can run concurrently."),
+		NULL,
+		&MaxRunningTasks,
+		32,
+		0,
+		MaxConnections,
+		PGC_POSTMASTER,
+		GUC_SUPERUSER_ONLY,
+		NULL, NULL, NULL);
+
+
 	/* set up common data for all our workers */
 	worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
 	worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
@@ -210,6 +228,7 @@ void
 PgCronWorkerMain(Datum arg)
 {
 	MemoryContext CronLoopContext = NULL;
+	struct rlimit limit;
 
 	/* Establish signal handlers before unblocking signals. */
 	pqsignal(SIGHUP, pg_cron_sighup);
@@ -222,6 +241,28 @@ PgCronWorkerMain(Datum arg)
 	/* Connect to our database */
 	BackgroundWorkerInitializeConnection(CronTableDatabaseName, NULL);
 
+	/* Determine how many tasks we can run concurrently */
+	if (MaxConnections < MaxRunningTasks)
+	{
+		MaxRunningTasks = MaxConnections;
+	}
+
+	if (max_files_per_process < MaxRunningTasks)
+	{
+		MaxRunningTasks = max_files_per_process;
+	}
+
+	if (getrlimit(RLIMIT_NOFILE, &limit) != 0 &&
+		limit.rlim_cur < (uint32) MaxRunningTasks)
+	{
+		MaxRunningTasks = limit.rlim_cur;
+	}
+
+	if (MaxRunningTasks <= 0)
+	{
+		MaxRunningTasks = 1;
+	}
+
 	CronLoopContext = AllocSetContextCreate(CurrentMemoryContext,
 											"pg_cron loop context",
 											ALLOCSET_DEFAULT_MINSIZE,
@@ -568,23 +609,34 @@ WaitForCronTasks(List *taskList)
 	}
 	else
 	{
-		int rc = 0;
-		int waitFlags = WL_LATCH_SET | WL_POSTMASTER_DEATH | WL_TIMEOUT;
+		WaitForLatch(MaxWait);
+	}
+}
+
+
+/*
+ * WaitForLatch waits for the given number of milliseconds unless a signal
+ * is received or postmaster shuts down.
+ */
+static void
+WaitForLatch(int timeoutMs)
+{
+	int rc = 0;
+	int waitFlags = WL_LATCH_SET | WL_POSTMASTER_DEATH | WL_TIMEOUT;
 
-		/* nothing to do, wait for new jobs */
+	/* nothing to do, wait for new jobs */
 #if (PG_VERSION_NUM >= 100000)
-		rc = WaitLatch(MyLatch, waitFlags, MaxWait, PG_WAIT_EXTENSION);
+	rc = WaitLatch(MyLatch, waitFlags, timeoutMs, PG_WAIT_EXTENSION);
 #else
-		rc = WaitLatch(MyLatch, waitFlags, MaxWait);
+	rc = WaitLatch(MyLatch, waitFlags, timeoutMs);
 #endif
 
-		ResetLatch(MyLatch);
+	ResetLatch(MyLatch);
 
-		if (rc & WL_POSTMASTER_DEATH)
-		{
-			/* postmaster died and we should bail out immediately */
-			proc_exit(1);
-		}
+	if (rc & WL_POSTMASTER_DEATH)
+	{
+		/* postmaster died and we should bail out immediately */
+		proc_exit(1);
 	}
 }
 
@@ -601,13 +653,16 @@ PollForTasks(List *taskList)
 	int pollTimeout = 0;
 	long waitSeconds = 0;
 	int waitMicros = 0;
+	CronTask **polledTasks = NULL;
 	struct pollfd *pollFDs = NULL;
 	int pollResult = 0;
 
 	int taskIndex = 0;
 	int taskCount = list_length(taskList);
+	int activeTaskCount = 0;
 	ListCell *taskCell = NULL;
 
+	polledTasks = (CronTask **) palloc0(taskCount * sizeof(CronTask));
 	pollFDs = (struct pollfd *) palloc0(taskCount * sizeof(struct pollfd));
 
 	currentTime = GetCurrentTimestamp();
@@ -621,16 +676,29 @@ PollForTasks(List *taskList)
 	{
 		CronTask *task = (CronTask *) lfirst(taskCell);
 		PostgresPollingStatusType pollingStatus = task->pollingStatus;
-		struct pollfd *pollFileDescriptor = &pollFDs[taskIndex];
+		struct pollfd *pollFileDescriptor = &pollFDs[activeTaskCount];
+
+		if (activeTaskCount >= MaxRunningTasks)
+		{
+			/* already polling the maximum number of tasks */
+			break;
+		}
 
-		if ((task->state == CRON_TASK_WAITING && task->pendingRunCount > 0) ||
-			task->state == CRON_TASK_ERROR || task->state == CRON_TASK_DONE)
+		if (task->state == CRON_TASK_ERROR || task->state == CRON_TASK_DONE ||
+			CanStartTask(task))
 		{
 			/* there is work to be done, don't wait */
+			pfree(polledTasks);
 			pfree(pollFDs);
 			return;
 		}
 
+		if (task->state == CRON_TASK_WAITING && task->pendingRunCount == 0)
+		{
+			/* don't poll idle tasks */
+			continue;
+		}
+
 		if (task->state == CRON_TASK_CONNECTING ||
 			task->state == CRON_TASK_SENDING)
 		{
@@ -644,6 +712,10 @@ PollForTasks(List *taskList)
 			}
 		}
 
+		/* we plan to poll this task */
+		pollFileDescriptor = &pollFDs[activeTaskCount];
+		polledTasks[activeTaskCount] = task;
+
 		if (task->state == CRON_TASK_CONNECTING ||
 			task->state == CRON_TASK_SENDING ||
 			task->state == CRON_TASK_RUNNING)
@@ -680,7 +752,7 @@ PollForTasks(List *taskList)
 
 		pollFileDescriptor->revents = 0;
 
-		taskIndex++;
+		activeTaskCount++;
 	}
 
 	/*
@@ -692,6 +764,7 @@ PollForTasks(List *taskList)
 	pollTimeout = waitSeconds * 1000 + waitMicros / 1000;
 	if (pollTimeout <= 0)
 	{
+		pfree(polledTasks);
 		pfree(pollFDs);
 		return;
 	}
@@ -705,7 +778,17 @@ PollForTasks(List *taskList)
 		pollTimeout = MaxWait;
 	}
 
-	pollResult = poll(pollFDs, taskCount, pollTimeout);
+	if (activeTaskCount == 0)
+	{
+		/* turns out there's nothing to do, just wait for something to happen */
+		WaitForLatch(pollTimeout);
+
+		pfree(polledTasks);
+		pfree(pollFDs);
+		return;
+	}
+
+	pollResult = poll(pollFDs, activeTaskCount, pollTimeout);
 	if (pollResult < 0)
 	{
 		/*
@@ -713,27 +796,37 @@ PollForTasks(List *taskList)
 		 * probably check errno in case something bad happened.
 		 */
 
+		pfree(polledTasks);
 		pfree(pollFDs);
 		return;
 	}
 
-	taskIndex = 0;
-
-	foreach(taskCell, taskList)
+	for (taskIndex = 0; taskIndex < activeTaskCount; taskIndex++)
 	{
-		CronTask *task = (CronTask *) lfirst(taskCell);
+		CronTask *task = polledTasks[taskIndex];
 		struct pollfd *pollFileDescriptor = &pollFDs[taskIndex];
 
 		task->isSocketReady = pollFileDescriptor->revents &
 							  pollFileDescriptor->events;
-
-		taskIndex++;
 	}
 
+	pfree(polledTasks);
 	pfree(pollFDs);
 }
 
 
+/*
+ * CanStartTask determines whether a task is ready to be started because
+ * it has pending runs and we are running less than MaxRunningTasks.
+ */
+static bool
+CanStartTask(CronTask *task)
+{
+	return task->state == CRON_TASK_WAITING && task->pendingRunCount > 0 &&
+		   RunningTaskCount < MaxRunningTasks;
+}
+
+
 /*
  * ManageCronTasks proceeds the state machines of the given list of tasks.
  */
@@ -775,8 +868,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				break;
 			}
 
-			/* check whether runs are pending */
-			if (task->pendingRunCount == 0)
+			if (!CanStartTask(task))
 			{
 				break;
 			}
@@ -784,6 +876,8 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			task->runId = RunCount++;
 			task->pendingRunCount -= 1;
 			task->state = CRON_TASK_START;
+
+			RunningTaskCount++;
 		}
 
 		case CRON_TASK_START:
@@ -1092,6 +1186,8 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			task->isSocketReady = false;
 			task->state = CRON_TASK_DONE;
 
+			RunningTaskCount--;
+
 			break;
 		}
 
@@ -1127,6 +1223,8 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			task->isSocketReady = false;
 			task->state = CRON_TASK_DONE;
 
+			RunningTaskCount--;
+
 			/* fall through to CRON_TASK_DONE */
 		}
 

COMMIT_HASH:ac11f146e17faa909a11bd4626da0176e5d02153|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2017-10-04 12:23:04 +0200|TITLE:Add GMT warning to README|MESSAGE:
diff --git a/README.md b/README.md
index 2fb6039..31873db 100644
--- a/README.md
+++ b/README.md
@@ -39,12 +39,12 @@ The schedule uses the standard cron syntax, in which * means "run every time per
  │ │ │ │ │                  Saturday, or use names; 7 is also Sunday)
  │ │ │ │ │
  │ │ │ │ │
- * * * * * 
+ * * * * *
 ```
 
 An easy way to create a cron schedule is: [crontab.guru](http://crontab.guru/).
 
-The code in pg_cron that handles parsing and scheduling comes directly from the cron source code by Paul Vixie, hence the same options are supported.
+The code in pg_cron that handles parsing and scheduling comes directly from the cron source code by Paul Vixie, hence the same options are supported. Be aware that pg_cron always uses GMT!
 
 ## Installing pg_cron
 

COMMIT_HASH:a2b7a6483719ac5104f5d4acbf81c95311c22474|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2017-10-04 11:47:37 +0200|TITLE:Merge pull request #33 from citusdata/fall_through|MESSAGE:Disable implicit fallthrough error in gcc-7 compiler
COMMIT_HASH:39d467e0a6728e60e96a345c06ec0d25518d27b3|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2017-08-21 13:01:09 +0200|TITLE:Keep cron.job table locks on heap_close|MESSAGE:
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 24a48e0..d9a5879 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -222,7 +222,7 @@ cron_schedule(PG_FUNCTION_ARGS)
 	CommandCounterIncrement();
 
 	/* close relation and invalidate previous cache entry */
-	heap_close(cronJobsTable, RowExclusiveLock);
+	heap_close(cronJobsTable, NoLock);
 
 	InvalidateJobCache();
 
@@ -376,7 +376,7 @@ cron_unschedule(PG_FUNCTION_ARGS)
 	simple_heap_delete(cronJobsTable, &heapTuple->t_self);
 
 	systable_endscan(scanDescriptor);
-	heap_close(cronJobsTable, RowExclusiveLock);
+	heap_close(cronJobsTable, NoLock);
 
 	CommandCounterIncrement();
 	InvalidateJobCache();

COMMIT_HASH:6786e978178c065f24dceb249a8ccd7a0ed82798|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2017-08-21 12:27:56 +0200|TITLE:Fix error when shared_preload_libraries is not set|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 2ce5ed4..a66944a 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -128,8 +128,8 @@ _PG_init(void)
 	if (!process_shared_preload_libraries_in_progress)
 	{
 		ereport(ERROR, (errmsg("pg_cron can only be loaded via shared_preload_libraries"),
-						errhint("Add pg_cron to shared_preload_libraries configuration "
-								"variable in postgresql.conf in master and workers.")));
+						errhint("Add pg_cron to the shared_preload_libraries "
+								"configuration variable in postgresql.conf.")));
 	}
 
 	DefineCustomStringVariable(

COMMIT_HASH:eafc8b61e5b37d5716c1b0a3963ecf696ae3476b|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2017-08-21 12:24:12 +0200|TITLE:PostgreSQL 10 compatibility|MESSAGE:
diff --git a/src/job_metadata.c b/src/job_metadata.c
index f6019d2..24a48e0 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -42,6 +42,9 @@
 #include "utils/relcache.h"
 #include "utils/snapmgr.h"
 #include "utils/syscache.h"
+#if (PG_VERSION_NUM >= 100000)
+#include "utils/varlena.h"
+#endif
 
 
 #define EXTENSION_NAME "pg_cron"
@@ -210,8 +213,12 @@ cron_schedule(PG_FUNCTION_ARGS)
 	tupleDescriptor = RelationGetDescr(cronJobsTable);
 	heapTuple = heap_form_tuple(tupleDescriptor, values, isNulls);
 
+#if (PG_VERSION_NUM >= 100000)
+	CatalogTupleInsert(cronJobsTable, heapTuple);
+#else
 	simple_heap_insert(cronJobsTable, heapTuple);
 	CatalogUpdateIndexes(cronJobsTable, heapTuple);
+#endif
 	CommandCounterIncrement();
 
 	/* close relation and invalidate previous cache entry */
@@ -367,11 +374,11 @@ cron_unschedule(PG_FUNCTION_ARGS)
 	}
 
 	simple_heap_delete(cronJobsTable, &heapTuple->t_self);
-	CommandCounterIncrement();
 
 	systable_endscan(scanDescriptor);
 	heap_close(cronJobsTable, RowExclusiveLock);
 
+	CommandCounterIncrement();
 	InvalidateJobCache();
 
 	PG_RETURN_BOOL(true);
diff --git a/src/pg_cron.c b/src/pg_cron.c
index e2f5992..2ce5ed4 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -62,6 +62,9 @@
 #include "utils/snapmgr.h"
 #include "utils/syscache.h"
 #include "utils/timestamp.h"
+#if (PG_VERSION_NUM >= 100000)
+#include "utils/varlena.h"
+#endif
 #include "tcop/utility.h"
 
 
@@ -83,7 +86,7 @@ void _PG_init(void);
 void _PG_fini(void);
 static void pg_cron_sigterm(SIGNAL_ARGS);
 static void pg_cron_sighup(SIGNAL_ARGS);
-static void PgCronWorkerMain(Datum arg);
+void PgCronWorkerMain(Datum arg);
 
 static void StartAllPendingRuns(List *taskList, TimestampTz currentTime);
 static void StartPendingRuns(CronTask *task, ClockProgress clockProgress,
@@ -153,10 +156,13 @@ _PG_init(void)
 	worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
 	worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
 	worker.bgw_restart_time = 1;
+#if (PG_VERSION_NUM < 100000)
 	worker.bgw_main = PgCronWorkerMain;
+#endif
 	worker.bgw_main_arg = Int32GetDatum(0);
 	worker.bgw_notify_pid = 0;
 	sprintf(worker.bgw_library_name, "pg_cron");
+	sprintf(worker.bgw_function_name, "PgCronWorkerMain");
 	snprintf(worker.bgw_name, BGW_MAXLEN, "pg_cron_scheduler");
 
 	RegisterBackgroundWorker(&worker);
@@ -200,7 +206,7 @@ pg_cron_sighup(SIGNAL_ARGS)
  * PgCronWorkerMain is the main entry-point for the background worker
  * that performs tasks.
  */
-static void
+void
 PgCronWorkerMain(Datum arg)
 {
 	MemoryContext CronLoopContext = NULL;
@@ -566,7 +572,11 @@ WaitForCronTasks(List *taskList)
 		int waitFlags = WL_LATCH_SET | WL_POSTMASTER_DEATH | WL_TIMEOUT;
 
 		/* nothing to do, wait for new jobs */
+#if (PG_VERSION_NUM >= 100000)
+		rc = WaitLatch(MyLatch, waitFlags, MaxWait, PG_WAIT_EXTENSION);
+#else
 		rc = WaitLatch(MyLatch, waitFlags, MaxWait);
+#endif
 
 		ResetLatch(MyLatch);
 

COMMIT_HASH:c6f9445f21b537475cfd54e0a0a58d15b54d03de|AUTHOR_NAME:Murat Tuncer|AUTHOR_EMAIL:mtuncer@citusdata.com|DATE:2017-08-11 15:16:31 +0300|TITLE:Disable implicit fallthrough error in gcc-7 compiler|MESSAGE:
diff --git a/Makefile b/Makefile
index 36f2e4c..7365dbc 100644
--- a/Makefile
+++ b/Makefile
@@ -9,7 +9,7 @@ DATA = $(wildcard $(EXTENSION)--*--*.sql)
 # compilation configuration
 MODULE_big = $(EXTENSION)
 OBJS = $(patsubst %.c,%.o,$(wildcard src/*.c))
-PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Iinclude -I$(libpq_srcdir)
+PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter  -Wno-implicit-fallthrough -Iinclude -I$(libpq_srcdir)
 SHLIB_LINK = $(libpq)
 EXTRA_CLEAN += $(addprefix src/,*.gcno *.gcda) # clean up after profiling runs
 

COMMIT_HASH:f7a2c11d176d70fb6be496d16bf5da67f19de31f|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2017-06-30 15:24:02 +0200|TITLE:Add 1.0.1 CHANGELOG entry|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index d5e132e..af4f98c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,9 @@
+### pg_cron v1.0.1 (June 30, 2017) ###
+
+* Fixes a memory leak that occurs when a connection fails immediately
+* Fixes a memory leak due to switching memory context when loading metadata
+* Fixes a segmentation fault that can occur when using an error message after PQclear
+
 ### pg_cron v1.0.0 (January 27, 2017) ###
 
 * Use WaitLatch instead of pg_usleep when there are no tasks

COMMIT_HASH:25347e6689ac539ce605a6f553aa253427176a6f|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2017-06-30 15:18:56 +0200|TITLE:Don't use PQresultErrorMessage result after PQclear|MESSAGE:
diff --git a/include/task_states.h b/include/task_states.h
index 94f19ab..dbd5db6 100644
--- a/include/task_states.h
+++ b/include/task_states.h
@@ -41,6 +41,7 @@ typedef struct CronTask
 	bool isSocketReady;
 	bool isActive;
 	char *errorMessage;
+	bool freeErrorMessage;
 } CronTask;
 
 
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 67a0249..e2f5992 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -1025,7 +1025,8 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 					case PGRES_BAD_RESPONSE:
 					case PGRES_FATAL_ERROR:
 					{
-						task->errorMessage = PQresultErrorMessage(result);
+						task->errorMessage = strdup(PQresultErrorMessage(result));
+						task->freeErrorMessage = true;
 						task->pollingStatus = 0;
 						task->state = CRON_TASK_ERROR;
 
@@ -1101,6 +1102,11 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			{
 				ereport(LOG, (errmsg("cron job %ld %s",
 									 jobId, task->errorMessage)));
+
+				if (task->freeErrorMessage)
+				{
+					free(task->errorMessage);
+				}
 			}
 			else
 			{
diff --git a/src/task_states.c b/src/task_states.c
index c829b5f..8f38871 100644
--- a/src/task_states.c
+++ b/src/task_states.c
@@ -143,6 +143,7 @@ InitializeCronTask(CronTask *task, int64 jobId)
 	task->isSocketReady = false;
 	task->isActive = true;
 	task->errorMessage = NULL;
+	task->freeErrorMessage = false;
 }
 
 

COMMIT_HASH:56bab41788fe59e899edae723cb71a34c4e6720e|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2017-06-02 08:37:14 +0200|TITLE:Free memory of connections that fail immediately|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 26a45c8..67a0249 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -818,6 +818,9 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			connectionStatus = PQstatus(connection);
 			if (connectionStatus == CONNECTION_BAD)
 			{
+				/* make sure we call PQfinish on the connection */
+				task->connection = connection;
+
 				task->errorMessage = "connection failed";
 				task->pollingStatus = 0;
 				task->state = CRON_TASK_ERROR;

COMMIT_HASH:e03ae5cfaba0bac25cba11d347518604ad01f306|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2017-06-02 00:17:19 +0200|TITLE:Ensure that LoadCronJobList does not change memory context|MESSAGE:
diff --git a/src/job_metadata.c b/src/job_metadata.c
index b57284c..f6019d2 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -464,6 +464,7 @@ LoadCronJobList(void)
 	int scanKeyCount = 0;
 	HeapTuple heapTuple = NULL;
 	TupleDesc tupleDescriptor = NULL;
+	MemoryContext originalContext = CurrentMemoryContext;
 
 	SetCurrentStatementStartTimestamp();
 	StartTransactionCommand();
@@ -514,6 +515,8 @@ LoadCronJobList(void)
 	CommitTransactionCommand();
 	pgstat_report_activity(STATE_IDLE, NULL);
 
+	MemoryContextSwitchTo(originalContext);
+
 	return jobList;
 }
 

COMMIT_HASH:d1084756553eb882fa10e6ce8b6b9ac1877577e3|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2017-01-27 15:26:44 +0100|TITLE:Add 1.0.0 CHANGELOG entry|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 2375adb..d5e132e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,7 @@
+### pg_cron v1.0.0 (January 27, 2017) ###
+
+* Use WaitLatch instead of pg_usleep when there are no tasks
+
 ### pg_cron v1.0.0-rc.1 (December 14, 2016) ###
 
 * Initial 1.0 candidate

COMMIT_HASH:eee57b322dd4157bbc13c7de34a7f95832926bd6|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2017-01-27 15:20:44 +0100|TITLE:Merge pull request #15 from citusdata/bugfix/wait_latch|MESSAGE:Replace pg_usleep with WaitLatch, check for postmaster death
COMMIT_HASH:0da1930b03bf57beb148c9ee32ecf55ff5d09b36|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-12-15 14:09:51 +0100|TITLE:Replace pg_usleep with WaitLatch, check for postmaster death|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 54e43e2..26a45c8 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -172,6 +172,11 @@ static void
 pg_cron_sigterm(SIGNAL_ARGS)
 {
 	got_sigterm = true;
+
+	if (MyProc != NULL)
+	{
+		SetLatch(&MyProc->procLatch);
+	}
 }
 
 
@@ -183,6 +188,11 @@ static void
 pg_cron_sighup(SIGNAL_ARGS)
 {
 	CronJobCacheValid = false;
+
+	if (MyProc != NULL)
+	{
+		SetLatch(&MyProc->procLatch);
+	}
 }
 
 
@@ -552,8 +562,19 @@ WaitForCronTasks(List *taskList)
 	}
 	else
 	{
-		/* wait for new jobs */
-		pg_usleep(MaxWait*1000L);
+		int rc = 0;
+		int waitFlags = WL_LATCH_SET | WL_POSTMASTER_DEATH | WL_TIMEOUT;
+
+		/* nothing to do, wait for new jobs */
+		rc = WaitLatch(MyLatch, waitFlags, MaxWait);
+
+		ResetLatch(MyLatch);
+
+		if (rc & WL_POSTMASTER_DEATH)
+		{
+			/* postmaster died and we should bail out immediately */
+			proc_exit(1);
+		}
 	}
 }
 

COMMIT_HASH:71ba42cbb8c48ea0a6cc05886110c27a0c391d94|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-12-22 11:09:50 +0100|TITLE:Remove Debian packages from README until issues are resolved|MESSAGE:
diff --git a/README.md b/README.md
index 85ea956..2fb6039 100644
--- a/README.md
+++ b/README.md
@@ -57,6 +57,7 @@ curl https://install.citusdata.com/community/rpm.sh | sudo bash
 # Install the pg_cron extension
 sudo yum install -y pg_cron_96
 ```
+<!---
 
 Install on Debian, Ubuntu with PostgreSQL 9.6:
 
@@ -67,6 +68,7 @@ curl https://install.citusdata.com/community/deb.sh | sudo bash
 # Install the pg_cron extension
 sudo apt-get -y install postgresql-9.6-pgcron
 ```
+-->
 
 You can also install pg_cron by building it from source:
 

COMMIT_HASH:f386a682d1579522f515274264e22d1783a657bb|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-12-21 11:02:14 +0100|TITLE:Clarify security model|MESSAGE:
diff --git a/README.md b/README.md
index 07ccec4..85ea956 100644
--- a/README.md
+++ b/README.md
@@ -99,7 +99,7 @@ GRANT USAGE ON SCHEMA cron TO marco;
 
 Internally, pg_cron uses libpq to open a new connection to the local database. It may be necessary to enable `trust` authentication for connections coming from localhost in [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html) for the user running the cron job. Alternatively, you can add the password to a [.pgpass file](https://www.postgresql.org/docs/current/static/libpq-pgpass.html), which libpq will use when opening a connection.
 
-For security, jobs are executed in the same database with the same permissions as the current user. In addition, users are only able to see their own jobs in the `cron.job` table.
+For security, jobs are executed in the database in which the `cron.schedule` function is called with the same permissions as the current user. In addition, users are only able to see their own jobs in the `cron.job` table.
 
 ## Advanced usage
 

COMMIT_HASH:6e01d984d3c5ec5820ef6ed8c73f3083f0ec0868|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-12-21 11:00:02 +0100|TITLE:Add a note on how to grant cron schema usage|MESSAGE:
diff --git a/README.md b/README.md
index d431151..07ccec4 100644
--- a/README.md
+++ b/README.md
@@ -90,17 +90,22 @@ shared_preload_libraries = 'pg_cron'
 After restarting PostgreSQL, you can create the pg_cron functions and metadata tables using `CREATE EXTENSION pg_cron`. By default, the pg_cron background worker expects its metadata tables to be created in the "postgres" database. However, you can configure this by setting the `cron.database_name` configuration parameter in postgresql.conf.
 
 ```sql
--- run using psql:
+-- run as superuser:
 CREATE EXTENSION pg_cron;
+
+-- optionally, grant usage to regular users:
+GRANT USAGE ON SCHEMA cron TO marco;
 ```
 
 Internally, pg_cron uses libpq to open a new connection to the local database. It may be necessary to enable `trust` authentication for connections coming from localhost in [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html) for the user running the cron job. Alternatively, you can add the password to a [.pgpass file](https://www.postgresql.org/docs/current/static/libpq-pgpass.html), which libpq will use when opening a connection.
 
+For security, jobs are executed in the same database with the same permissions as the current user. In addition, users are only able to see their own jobs in the `cron.job` table.
+
 ## Advanced usage
 
-Since pg_cron uses libpq, you can also run periodic jobs on other machines. This can be especially useful when you are using the [Citus extension](https://www.citusdata.com/product) to distribute tables across many PostgreSQL servers and need to run periodic jobs across all of them.
+Since pg_cron uses libpq, you can also run periodic jobs on other databases or other machines. This can be especially useful when you are using the [Citus extension](https://www.citusdata.com/product) to distribute tables across many PostgreSQL servers and need to run periodic jobs across all of them.
 
-If you are superuser, then you can manually modify the cron.job table and use custom values for nodename and nodeport to connect to a different machine:
+If you are superuser, then you can manually modify the `cron.job` table and use custom values for nodename and nodeport to connect to a different machine:
 
 ```sql
 INSERT INTO cron.job (schedule, command, nodename, nodeport, database, username)

COMMIT_HASH:732f24b953b1f72b33ed8c36c79cade2c22b2ecc|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-12-15 17:51:14 +0100|TITLE:Add instructions for installation from package repo|MESSAGE:
diff --git a/README.md b/README.md
index c2c9466..d431151 100644
--- a/README.md
+++ b/README.md
@@ -46,18 +46,41 @@ An easy way to create a cron schedule is: [crontab.guru](http://crontab.guru/).
 
 The code in pg_cron that handles parsing and scheduling comes directly from the cron source code by Paul Vixie, hence the same options are supported.
 
-## Setting up pg_cron
+## Installing pg_cron
 
-You can install pg_cron by building it from source:
+Install on Red Hat, CentOS, Fedora, Amazon Linux with PostgreSQL 9.6:
+
+```bash
+# Add Citus Data package repository
+curl https://install.citusdata.com/community/rpm.sh | sudo bash
+
+# Install the pg_cron extension
+sudo yum install -y pg_cron_96
+```
+
+Install on Debian, Ubuntu with PostgreSQL 9.6:
+
+```bash
+# Add Citus Data package repository
+curl https://install.citusdata.com/community/deb.sh | sudo bash
+
+# Install the pg_cron extension
+sudo apt-get -y install postgresql-9.6-pgcron
+```
+
+You can also install pg_cron by building it from source:
 
 ```bash
 git clone https://github.com/citusdata/pg_cron.git
 cd pg_cron
-PATH=/usr/local/pgsql/bin/:$PATH make
-sudo PATH=/usr/local/pgsql/bin/:$PATH make install
+# Ensure pg_config is in your path, e.g.
+export PATH=/usr/pgsql-9.6/bin:$PATH
+make && sudo PATH=$PATH make install
 ```
 
-To start the pg_cron background worker when PostgreSQL starts, you need to add pg_cron to `shared_preload_libraries` in postgresql.conf and restart PostgreSQL. Note that pg_cron does not run any jobs as a long a server is in [hot standby](https://www.postgresql.org/docs/current/static/hot-standby.html) mode, but it automatically starts when the server is promoted.
+## Setting up pg_cron
+
+ To start the pg_cron background worker when PostgreSQL starts, you need to add pg_cron to `shared_preload_libraries` in postgresql.conf and restart PostgreSQL. Note that pg_cron does not run any jobs as a long a server is in [hot standby](https://www.postgresql.org/docs/current/static/hot-standby.html) mode, but it automatically starts when the server is promoted.
 
 ```
 # add to postgresql.conf:

COMMIT_HASH:689c29ead50fea05b6dc61ffe619c762826da6c2|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-12-15 17:17:04 +0100|TITLE:Add CHANGELOG|MESSAGE:
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 0000000..2375adb
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,3 @@
+### pg_cron v1.0.0-rc.1 (December 14, 2016) ###
+
+* Initial 1.0 candidate

COMMIT_HASH:73ed99fdd6cb2e3f9d8a51427d39b5ca3c7c8271|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-12-15 11:54:54 +0100|TITLE:Remove ancient __P usage|MESSAGE:
diff --git a/include/cron.h b/include/cron.h
index 457bc29..02480cf 100644
--- a/include/cron.h
+++ b/include/cron.h
@@ -219,12 +219,12 @@ typedef struct _file_buffer {
 	int			unget_count;
 } file_buffer;
 
-void	unget_char __P((int, FILE *)),
-		free_entry __P((entry *)),
-		skip_comments __P((FILE *));
+void	unget_char(int, FILE *),
+		free_entry(entry *),
+		skip_comments(FILE *);
 
-int		get_char __P((FILE *)),
-		get_string __P((char *, int, FILE *, char *));
+int		get_char(FILE *),
+		get_string(char *, int, FILE *, char *);
 
 entry * parse_cron_entry(char *);
 
diff --git a/src/entry.c b/src/entry.c
index 25231ff..f7308e4 100644
--- a/src/entry.c
+++ b/src/entry.c
@@ -35,10 +35,10 @@ typedef	enum ecode {
 	e_cmd, e_timespec, e_username, e_cmd_len
 } ecode_e;
 
-static char	get_list __P((bitstr_t *, int, int, char *[], int, FILE *)),
-		get_range __P((bitstr_t *, int, int, char *[], int, FILE *)),
-		get_number __P((int *, int, char *[], int, FILE *));
-static int	set_element __P((bitstr_t *, int, int, int));
+static char	get_list(bitstr_t *, int, int, char *[], int, FILE *),
+		get_range(bitstr_t *, int, int, char *[], int, FILE *),
+		get_number(int *, int, char *[], int, FILE *);
+static int	set_element(bitstr_t *, int, int, int);
 
 
 void

COMMIT_HASH:97c92c6413a273be0e19e8b53d0969aaf9622fb9|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-12-15 11:39:36 +0100|TITLE:Set background worker restart time to 1 second|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index a7e42c5..54e43e2 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -152,7 +152,7 @@ _PG_init(void)
 	/* set up common data for all our workers */
 	worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
 	worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
-	worker.bgw_restart_time = BGW_NEVER_RESTART;
+	worker.bgw_restart_time = 1;
 	worker.bgw_main = PgCronWorkerMain;
 	worker.bgw_main_arg = Int32GetDatum(0);
 	worker.bgw_notify_pid = 0;

COMMIT_HASH:65fadf9be68951e8a9f12ffaab5a2cbe22b58f03|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-12-14 16:41:38 +0100|TITLE:Merge pull request #11 from alexeyklyukin/master|MESSAGE:Avoid freeing a NULL pointer
COMMIT_HASH:e604cabe52b2611d7ba4dd69f61396b9cc6bf7e2|AUTHOR_NAME:Oleksii Kliukin|AUTHOR_EMAIL:oleksii.kliukin@zalando.de|DATE:2016-12-14 14:03:01 +0100|TITLE:Avoid freeing a NULL pointer|MESSAGE:
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 9ef0555..b57284c 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -180,8 +180,6 @@ cron_schedule(PG_FUNCTION_ARGS)
 	parsedSchedule = parse_cron_entry(schedule);
 	if (parsedSchedule == NULL)
 	{
-		free_entry(parsedSchedule);
-
 		ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
 						errmsg("invalid schedule: %s", schedule)));
 	}

COMMIT_HASH:d525a61443c44a4e7fb62e4e5da541375578df62|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-11-24 16:39:23 +0100|TITLE:Add version requirement to README|MESSAGE:
diff --git a/README.md b/README.md
index cef1a7b..c2c9466 100644
--- a/README.md
+++ b/README.md
@@ -4,7 +4,7 @@
 
 ## What is pg_cron?
 
-pg_cron is a simple cron-based job scheduler for PostgreSQL that runs inside the database as an extension. It uses the same syntax as regular cron, but it allows you to schedule PostgreSQL commands directly from the database:
+pg_cron is a simple cron-based job scheduler for PostgreSQL (9.5 or higher) that runs inside the database as an extension. It uses the same syntax as regular cron, but it allows you to schedule PostgreSQL commands directly from the database:
 
 ```sql
 -- Delete old data on Saturday at 3:30am (GMT)

COMMIT_HASH:62a385ae3df380ef90e60d4e26db0e8e6bd51e7d|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-11-18 06:42:05 +0100|TITLE:Change to pg_cron version 1.0|MESSAGE:
diff --git a/.gitignore b/.gitignore
index b437813..a5a3a00 100644
--- a/.gitignore
+++ b/.gitignore
@@ -36,3 +36,5 @@ lib*.pc
 /autom4te.cache
 /Makefile.global
 /src/Makefile.custom
+
+pg_cron--?.?.sql
diff --git a/META.json b/META.json
index 31d3e85..b081388 100644
--- a/META.json
+++ b/META.json
@@ -2,7 +2,7 @@
     "name": "pg_cron",
     "abstract": "Periodic job scheduler for PostgreSQL",
     "description": "Sets up a background worker that periodically runs queries in the background",
-    "version": "0.1",
+    "version": "1.0",
     "maintainer": "\"Marco Slot\" <marco@citusdata.com>",
     "license": {
 		"PostgreSQL": "http://www.postgresql.org/about/licence"
@@ -17,9 +17,9 @@
     "provides": {
         "pg_cron": {
             "abstract": "Periodic background job scheduler",
-            "file": "sql/pg_cron--0.1.sql",
+            "file": "pg_cron--1.0.sql",
             "docfile": "README.md",
-            "version": "0.1"
+            "version": "1.0"
         }
     },
     "release_status": "stable",
diff --git a/Makefile b/Makefile
index d47ff2f..36f2e4c 100644
--- a/Makefile
+++ b/Makefile
@@ -1,11 +1,10 @@
 # src/test/modules/pg_cron/Makefile
 
-# grab name and version from META.json file
-EXTENSION = $(shell grep -m 1 '"name":' META.json | sed -e 's/[[:space:]]*"name":[[:space:]]*"\([^"]*\)",/\1/')
-EXTVERSION = $(shell grep default_version $(EXTENSION).control | sed -e "s/default_version[[:space:]]*=[[:space:]]*'\([^']*\)'/\1/")
+EXTENSION = pg_cron
+EXTVERSION = 1.0
 
-# installation scripts
-DATA = $(wildcard updates/*--*.sql)
+DATA_built = $(EXTENSION)--$(EXTVERSION).sql
+DATA = $(wildcard $(EXTENSION)--*--*.sql)
 
 # compilation configuration
 MODULE_big = $(EXTENSION)
@@ -14,28 +13,9 @@ PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Iinclude -I$
 SHLIB_LINK = $(libpq)
 EXTRA_CLEAN += $(addprefix src/,*.gcno *.gcda) # clean up after profiling runs
 
-# add coverage flags if requested
-ifeq ($(enable_coverage),yes)
-PG_CPPFLAGS += --coverage
-SHLIB_LINK += --coverage
-endif
-
-# be explicit about the default target
-all:
-
-# delegate to subdirectory makefiles as needed
-include sql/Makefile
-
-# detect whether to build with pgxs or build in-tree
-ifndef NO_PGXS
 PG_CONFIG = pg_config
 PGXS := $(shell $(PG_CONFIG) --pgxs)
 include $(PGXS)
-else
-SHLIB_PREREQS = submake-libpq
-subdir = contrib/$(EXTENSION)
-top_builddir = ../..
-include $(top_builddir)/src/Makefile.global
-include $(top_srcdir)/contrib/contrib-global.mk
-endif
 
+$(EXTENSION)--1.0.sql: $(EXTENSION).sql $(EXTENSION)--0.1--1.0.sql
+	cat $^ > $@
diff --git a/pg_cron--0.1--1.0.sql b/pg_cron--0.1--1.0.sql
new file mode 100644
index 0000000..beee92d
--- /dev/null
+++ b/pg_cron--0.1--1.0.sql
@@ -0,0 +1,3 @@
+/* pg_cron--0.1--1.0.sql */
+
+SELECT pg_catalog.pg_extension_config_dump('cron.job', '');
diff --git a/pg_cron.control b/pg_cron.control
index d010f1e..b523c15 100644
--- a/pg_cron.control
+++ b/pg_cron.control
@@ -1,4 +1,4 @@
 comment = 'Job scheduler for PostgreSQL'
-default_version = '0.1'
+default_version = '1.0'
 module_pathname = '$libdir/pg_cron'
-relocatable = true
+relocatable = false
diff --git a/sql/pg_cron.sql b/pg_cron.sql
similarity index 100%
rename from sql/pg_cron.sql
rename to pg_cron.sql
diff --git a/sql/.gitignore b/sql/.gitignore
deleted file mode 100644
index 72dc612..0000000
--- a/sql/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-# ignore latest install file
-pg_cron--?.?.sql
-pg_cron--?.?-*.sql
-!pg_cron--?.?-*--?.?-*.sql
diff --git a/sql/Makefile b/sql/Makefile
deleted file mode 100644
index dcb1ca0..0000000
--- a/sql/Makefile
+++ /dev/null
@@ -1,5 +0,0 @@
-DATA_built += sql/$(EXTENSION)--$(EXTVERSION).sql
-
-# define build process for latest install file
-sql/$(EXTENSION)--$(EXTVERSION).sql: sql/$(EXTENSION).sql
-	cp $< $@

COMMIT_HASH:819d7b00de3224dcfd87ba5cd880a1578642dff8|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-11-10 03:26:11 +0100|TITLE:Fix the NextJobId declaration|MESSAGE:
diff --git a/src/job_metadata.c b/src/job_metadata.c
index 1629e7c..9ef0555 100644
--- a/src/job_metadata.c
+++ b/src/job_metadata.c
@@ -54,7 +54,7 @@
 /* forward declarations */
 static HTAB * CreateCronJobHash(void);
 
-static int64 NextJobId();
+static int64 NextJobId(void);
 static Oid CronExtensionOwner(void);
 static void InvalidateJobCacheCallback(Datum argument, Oid relationId);
 static void InvalidateJobCache(void);

COMMIT_HASH:4998f28040eedd7119f15bc8ef9f0144724b70e1|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-11-07 23:38:39 +0100|TITLE:Add optional logging output on cron job completion|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 5b5afb9..a7e42c5 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -787,7 +787,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			{
 				char *command = cronJob->command;
 
-				ereport(LOG, (errmsg("cron job %ld statement: %s",
+				ereport(LOG, (errmsg("cron job %ld starting: %s",
 									 jobId, command)));
 			}
 
@@ -984,13 +984,17 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 				switch (executionStatus)
 				{
-					case PGRES_TUPLES_OK:
-					{
-						break;
-					}
-
 					case PGRES_COMMAND_OK:
 					{
+						if (CronLogStatement)
+						{
+							char *cmdStatus = PQcmdStatus(result);
+							char *cmdTuples = PQcmdTuples(result);
+
+							ereport(LOG, (errmsg("cron job %ld completed: %s %s",
+												 jobId, cmdStatus, cmdTuples)));
+						}
+
 						break;
 					}
 
@@ -1020,11 +1024,24 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 						return;
 					}
 
+					case PGRES_TUPLES_OK:
 					case PGRES_EMPTY_QUERY:
 					case PGRES_SINGLE_TUPLE:
 					case PGRES_NONFATAL_ERROR:
 					default:
 					{
+						if (CronLogStatement)
+						{
+							int tupleCount = PQntuples(result);
+							char *rowString = ngettext("row", "rows",
+													   tupleCount);
+
+							ereport(LOG, (errmsg("cron job %ld completed: "
+												 "%d %s",
+												 jobId, tupleCount,
+												 rowString)));
+						}
+
 						break;
 					}
 
@@ -1061,6 +1078,10 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				ereport(LOG, (errmsg("cron job %ld %s",
 									 jobId, task->errorMessage)));
 			}
+			else
+			{
+				ereport(LOG, (errmsg("cron job %ld failed", jobId)));
+			}
 
 			task->startDeadline = 0;
 			task->isSocketReady = false;

COMMIT_HASH:4101333ae25e101f265d7adb020ae54b251b9ea9|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-11-07 18:53:17 +0100|TITLE:Refactor job metadadata and task state logic into separate files|MESSAGE:
diff --git a/include/cron_job.h b/include/cron_job.h
index 170ee2a..661382d 100644
--- a/include/cron_job.h
+++ b/include/cron_job.h
@@ -11,6 +11,7 @@
 #ifndef CRON_JOB_H
 #define CRON_JOB_H
 
+
 /* ----------------
  *		cron_job definition.
  * ----------------
@@ -48,4 +49,5 @@ typedef FormData_cron_job *Form_cron_job;
 #define Anum_cron_job_database 6
 #define Anum_cron_job_username 7
 
+
 #endif /* CRON_JOB_H */
diff --git a/include/job_metadata.h b/include/job_metadata.h
new file mode 100644
index 0000000..5a67771
--- /dev/null
+++ b/include/job_metadata.h
@@ -0,0 +1,43 @@
+/*-------------------------------------------------------------------------
+ *
+ * job_metadata.h
+ *	  definition of job metadata functions
+ *
+ * Copyright (c) 2010-2015, Citus Data, Inc.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#ifndef JOB_METADATA_H
+#define JOB_METADATA_H
+
+
+#include "nodes/pg_list.h"
+
+
+/* job metadata data structure */
+typedef struct CronJob
+{
+	int64 jobId;
+	char *scheduleText;
+	entry schedule;
+	char *command;
+	char *nodeName;
+	int nodePort;
+	char *database;
+	char *userName;
+} CronJob;
+
+
+/* global settings */
+extern bool CronJobCacheValid;
+
+
+/* functions for retrieving job metadata */
+extern void InitializeJobMetadataCache(void);
+extern void ResetJobMetadataCache(void);
+extern List * LoadCronJobList(void);
+extern CronJob * GetCronJob(int64 jobId);
+
+
+#endif
diff --git a/include/pg_cron.h b/include/pg_cron.h
index 8962e48..437de1f 100644
--- a/include/pg_cron.h
+++ b/include/pg_cron.h
@@ -11,54 +11,9 @@
 #ifndef PG_CRON_H
 #define PG_CRON_H
 
-#include "cron_job.h"
-#include "libpq-fe.h"
-#include "utils/timestamp.h"
 
-typedef enum
-{
-	CLOCK_JUMP_BACKWARD = 0,
-	CLOCK_PROGRESSED = 1,
-	CLOCK_JUMP_FORWARD = 2,
-	CLOCK_CHANGE = 3
-} ClockProgress;
+/* global settings */
+extern char *CronTableDatabaseName;
 
-typedef enum
-{
-	CRON_TASK_WAITING = 0,
-	CRON_TASK_START = 1,
-	CRON_TASK_CONNECTING = 2,
-	CRON_TASK_SENDING = 3,
-	CRON_TASK_RUNNING = 4,
-	CRON_TASK_RECEIVING = 5,
-	CRON_TASK_DONE = 6,
-	CRON_TASK_ERROR = 7
-} CronTaskState;
-
-typedef struct CronJob
-{
-	int64 jobId;
-	char *scheduleText;
-	entry schedule;
-	char *command;
-	char *nodeName;
-	int nodePort;
-	char *database;
-	char *userName;
-} CronJob;
-
-typedef struct CronTask
-{
-	int64 jobId;
-	int64 runId;
-	CronTaskState state;
-	uint pendingRunCount;
-	PGconn *connection;
-	PostgresPollingStatusType pollingStatus;
-	TimestampTz startDeadline;
-	bool isSocketReady;
-	bool isActive;
-	char *errorMessage;
-} CronTask;
 
 #endif
diff --git a/include/task_states.h b/include/task_states.h
new file mode 100644
index 0000000..94f19ab
--- /dev/null
+++ b/include/task_states.h
@@ -0,0 +1,54 @@
+/*-------------------------------------------------------------------------
+ *
+ * task_states.h
+ *	  definition of task state functions
+ *
+ * Copyright (c) 2010-2015, Citus Data, Inc.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#ifndef TASK_STATES_H
+#define TASK_STATES_H
+
+
+#include "job_metadata.h"
+#include "libpq-fe.h"
+#include "utils/timestamp.h"
+
+
+typedef enum
+{
+	CRON_TASK_WAITING = 0,
+	CRON_TASK_START = 1,
+	CRON_TASK_CONNECTING = 2,
+	CRON_TASK_SENDING = 3,
+	CRON_TASK_RUNNING = 4,
+	CRON_TASK_RECEIVING = 5,
+	CRON_TASK_DONE = 6,
+	CRON_TASK_ERROR = 7
+} CronTaskState;
+
+typedef struct CronTask
+{
+	int64 jobId;
+	int64 runId;
+	CronTaskState state;
+	uint pendingRunCount;
+	PGconn *connection;
+	PostgresPollingStatusType pollingStatus;
+	TimestampTz startDeadline;
+	bool isSocketReady;
+	bool isActive;
+	char *errorMessage;
+} CronTask;
+
+
+extern void InitializeTaskStateHash(void);
+extern void RefreshTaskHash(void);
+extern List * CurrentTaskList(void);
+extern void InitializeCronTask(CronTask *task, int64 jobId);
+extern void RemoveTask(int64 jobId);
+
+
+#endif
diff --git a/src/job_metadata.c b/src/job_metadata.c
new file mode 100644
index 0000000..1629e7c
--- /dev/null
+++ b/src/job_metadata.c
@@ -0,0 +1,619 @@
+/*-------------------------------------------------------------------------
+ *
+ * src/job_metadata.c
+ *
+ * Functions for reading and manipulating pg_cron metadata.
+ *
+ * Copyright (c) 2016, Citus Data, Inc.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#include "postgres.h"
+#include "fmgr.h"
+#include "miscadmin.h"
+
+#include "cron.h"
+#include "pg_cron.h"
+#include "job_metadata.h"
+#include "cron_job.h"
+
+#include "access/genam.h"
+#include "access/heapam.h"
+#include "access/htup_details.h"
+#include "access/skey.h"
+#include "access/xact.h"
+#include "access/xlog.h"
+#include "catalog/pg_extension.h"
+#include "catalog/indexing.h"
+#include "catalog/namespace.h"
+#include "commands/extension.h"
+#include "commands/sequence.h"
+#include "commands/trigger.h"
+#include "postmaster/postmaster.h"
+#include "pgstat.h"
+#include "storage/lock.h"
+#include "utils/builtins.h"
+#include "utils/fmgroids.h"
+#include "utils/inval.h"
+#include "utils/lsyscache.h"
+#include "utils/memutils.h"
+#include "utils/rel.h"
+#include "utils/relcache.h"
+#include "utils/snapmgr.h"
+#include "utils/syscache.h"
+
+
+#define EXTENSION_NAME "pg_cron"
+#define CRON_SCHEMA_NAME "cron"
+#define JOBS_TABLE_NAME "job"
+#define JOB_ID_INDEX_NAME "job_pkey"
+#define JOB_ID_SEQUENCE_NAME "cron.jobid_seq"
+
+
+/* forward declarations */
+static HTAB * CreateCronJobHash(void);
+
+static int64 NextJobId();
+static Oid CronExtensionOwner(void);
+static void InvalidateJobCacheCallback(Datum argument, Oid relationId);
+static void InvalidateJobCache(void);
+static Oid CronJobRelationId(void);
+
+static CronJob * TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple);
+static bool PgCronHasBeenLoaded(void);
+
+
+/* SQL-callable functions */
+PG_FUNCTION_INFO_V1(cron_schedule);
+PG_FUNCTION_INFO_V1(cron_unschedule);
+PG_FUNCTION_INFO_V1(cron_job_cache_invalidate);
+
+
+/* global variables */
+static MemoryContext CronJobContext = NULL;
+static HTAB *CronJobHash = NULL;
+static Oid CachedCronJobRelationId = InvalidOid;
+bool CronJobCacheValid = false;
+
+
+/*
+ * InitializeJobMetadataCache initializes the data structures for caching
+ * job metadata.
+ */
+void
+InitializeJobMetadataCache(void)
+{
+	/* watch for invalidation events */
+	CacheRegisterRelcacheCallback(InvalidateJobCacheCallback, (Datum) 0);
+
+	CronJobContext = AllocSetContextCreate(CurrentMemoryContext,
+										   "pg_cron job context",
+										   ALLOCSET_DEFAULT_MINSIZE,
+										   ALLOCSET_DEFAULT_INITSIZE,
+										   ALLOCSET_DEFAULT_MAXSIZE);
+
+	CronJobHash = CreateCronJobHash();
+}
+
+
+/*
+ * ResetJobMetadataCache resets the job metadata cache to its initial
+ * state.
+ */
+void
+ResetJobMetadataCache(void)
+{
+	MemoryContextResetAndDeleteChildren(CronJobContext);
+
+	CronJobHash = CreateCronJobHash();
+}
+
+
+/*
+ * CreateCronJobHash creates the hash for caching job metadata.
+ */
+static HTAB *
+CreateCronJobHash(void)
+{
+	HTAB *taskHash = NULL;
+	HASHCTL info;
+	int hashFlags = 0;
+
+	memset(&info, 0, sizeof(info));
+	info.keysize = sizeof(int64);
+	info.entrysize = sizeof(CronJob);
+	info.hash = tag_hash;
+	info.hcxt = CronJobContext;
+	hashFlags = (HASH_ELEM | HASH_FUNCTION | HASH_CONTEXT);
+
+	taskHash = hash_create("pg_cron jobs", 32, &info, hashFlags);
+
+	return taskHash;
+}
+
+
+/*
+ * GetCronJob gets the cron job with the given id.
+ */
+CronJob *
+GetCronJob(int64 jobId)
+{
+	CronJob *job = NULL;
+	int64 hashKey = jobId;
+	bool isPresent = false;
+
+	job = hash_search(CronJobHash, &hashKey, HASH_FIND, &isPresent);
+
+	return job;
+}
+
+
+/*
+ * cluster_schedule schedules a cron job.
+ */
+Datum
+cron_schedule(PG_FUNCTION_ARGS)
+{
+	text *scheduleText = PG_GETARG_TEXT_P(0);
+	text *commandText = PG_GETARG_TEXT_P(1);
+
+	char *schedule = text_to_cstring(scheduleText);
+	char *command = text_to_cstring(commandText);
+	entry *parsedSchedule = NULL;
+
+	int64 jobId = 0;
+	Datum jobIdDatum = 0;
+
+	Oid cronSchemaId = InvalidOid;
+	Oid cronJobsRelationId = InvalidOid;
+
+	Relation cronJobsTable = NULL;
+	TupleDesc tupleDescriptor = NULL;
+	HeapTuple heapTuple = NULL;
+	Datum values[Natts_cron_job];
+	bool isNulls[Natts_cron_job];
+
+	Oid userId = GetUserId();
+	char *userName = GetUserNameFromId(userId, false);
+
+	parsedSchedule = parse_cron_entry(schedule);
+	if (parsedSchedule == NULL)
+	{
+		free_entry(parsedSchedule);
+
+		ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+						errmsg("invalid schedule: %s", schedule)));
+	}
+
+	free_entry(parsedSchedule);
+
+	/* form new job tuple */
+	memset(values, 0, sizeof(values));
+	memset(isNulls, false, sizeof(isNulls));
+
+	jobId = NextJobId();
+	jobIdDatum = Int64GetDatum(jobId);
+
+	values[Anum_cron_job_jobid - 1] = jobIdDatum;
+	values[Anum_cron_job_schedule - 1] = CStringGetTextDatum(schedule);
+	values[Anum_cron_job_command - 1] = CStringGetTextDatum(command);
+	values[Anum_cron_job_nodename - 1] = CStringGetTextDatum("localhost");
+	values[Anum_cron_job_nodeport - 1] = Int32GetDatum(PostPortNumber);
+	values[Anum_cron_job_database - 1] = CStringGetTextDatum(CronTableDatabaseName);
+	values[Anum_cron_job_username - 1] = CStringGetTextDatum(userName);
+
+	cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
+	cronJobsRelationId = get_relname_relid(JOBS_TABLE_NAME, cronSchemaId);
+
+	/* open jobs relation and insert new tuple */
+	cronJobsTable = heap_open(cronJobsRelationId, RowExclusiveLock);
+
+	tupleDescriptor = RelationGetDescr(cronJobsTable);
+	heapTuple = heap_form_tuple(tupleDescriptor, values, isNulls);
+
+	simple_heap_insert(cronJobsTable, heapTuple);
+	CatalogUpdateIndexes(cronJobsTable, heapTuple);
+	CommandCounterIncrement();
+
+	/* close relation and invalidate previous cache entry */
+	heap_close(cronJobsTable, RowExclusiveLock);
+
+	InvalidateJobCache();
+
+	PG_RETURN_INT64(jobId);
+}
+
+
+/*
+ * NextJobId returns a new, unique job ID using the job ID sequence.
+ */
+static int64
+NextJobId(void)
+{
+	text *sequenceName = NULL;
+	Oid sequenceId = InvalidOid;
+	List *sequenceNameList = NIL;
+	RangeVar *sequenceVar = NULL;
+	Datum sequenceIdDatum = InvalidOid;
+	Oid savedUserId = InvalidOid;
+	int savedSecurityContext = 0;
+	Datum jobIdDatum = 0;
+	int64 jobId = 0;
+	bool failOK = true;
+
+	/* resolve relationId from passed in schema and relation name */
+	sequenceName = cstring_to_text(JOB_ID_SEQUENCE_NAME);
+	sequenceNameList = textToQualifiedNameList(sequenceName);
+	sequenceVar = makeRangeVarFromNameList(sequenceNameList);
+	sequenceId = RangeVarGetRelid(sequenceVar, NoLock, failOK);
+	sequenceIdDatum = ObjectIdGetDatum(sequenceId);
+
+	GetUserIdAndSecContext(&savedUserId, &savedSecurityContext);
+	SetUserIdAndSecContext(CronExtensionOwner(), SECURITY_LOCAL_USERID_CHANGE);
+
+	/* generate new and unique colocation id from sequence */
+	jobIdDatum = DirectFunctionCall1(nextval_oid, sequenceIdDatum);
+
+	SetUserIdAndSecContext(savedUserId, savedSecurityContext);
+
+	jobId = DatumGetUInt32(jobIdDatum);
+
+	return jobId;
+}
+
+
+/*
+ * CronExtensionOwner returns the name of the user that owns the
+ * extension.
+ */
+static Oid
+CronExtensionOwner(void)
+{
+	Relation extensionRelation = NULL;
+	SysScanDesc scanDescriptor;
+	ScanKeyData entry[1];
+	HeapTuple extensionTuple = NULL;
+	Form_pg_extension extensionForm = NULL;
+	Oid extensionOwner = InvalidOid;
+
+	extensionRelation = heap_open(ExtensionRelationId, AccessShareLock);
+
+	ScanKeyInit(&entry[0],
+				Anum_pg_extension_extname,
+				BTEqualStrategyNumber, F_NAMEEQ,
+				CStringGetDatum(EXTENSION_NAME));
+
+	scanDescriptor = systable_beginscan(extensionRelation, ExtensionNameIndexId,
+										true, NULL, 1, entry);
+
+	extensionTuple = systable_getnext(scanDescriptor);
+	if (!HeapTupleIsValid(extensionTuple))
+	{
+		ereport(ERROR, (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),
+						errmsg("pg_cron extension not loaded")));
+	}
+
+	extensionForm = (Form_pg_extension) GETSTRUCT(extensionTuple);
+	extensionOwner = extensionForm->extowner;
+
+	systable_endscan(scanDescriptor);
+	heap_close(extensionRelation, AccessShareLock);
+
+	return extensionOwner;
+}
+
+
+/*
+ * cluster_unschedule removes a cron job.
+ */
+Datum
+cron_unschedule(PG_FUNCTION_ARGS)
+{
+	int64 jobId = PG_GETARG_INT64(0);
+
+	Oid cronSchemaId = InvalidOid;
+	Oid cronJobIndexId = InvalidOid;
+
+	Relation cronJobsTable = NULL;
+	SysScanDesc scanDescriptor = NULL;
+	ScanKeyData scanKey[1];
+	int scanKeyCount = 1;
+	bool indexOK = true;
+	TupleDesc tupleDescriptor = NULL;
+	HeapTuple heapTuple = NULL;
+	bool isNull = false;
+	Oid userId = InvalidOid;
+	char *userName = NULL;
+	Datum ownerNameDatum = 0;
+	char *ownerName = NULL;
+
+	cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
+	cronJobIndexId = get_relname_relid(JOB_ID_INDEX_NAME, cronSchemaId);
+
+	cronJobsTable = heap_open(CronJobRelationId(), RowExclusiveLock);
+
+	ScanKeyInit(&scanKey[0], Anum_cron_job_jobid,
+				BTEqualStrategyNumber, F_INT8EQ, Int64GetDatum(jobId));
+
+	scanDescriptor = systable_beginscan(cronJobsTable,
+										cronJobIndexId, indexOK,
+										NULL, scanKeyCount, scanKey);
+
+	tupleDescriptor = RelationGetDescr(cronJobsTable);
+
+	heapTuple = systable_getnext(scanDescriptor);
+	if (!HeapTupleIsValid(heapTuple))
+	{
+		ereport(ERROR, (errmsg("could not find valid entry for job "
+							   UINT64_FORMAT, jobId)));
+	}
+
+	/* check if the current user owns the row */
+	userId = GetUserId();
+	userName = GetUserNameFromId(userId, false);
+
+	ownerNameDatum = heap_getattr(heapTuple, Anum_cron_job_username,
+								  tupleDescriptor, &isNull);
+	ownerName = TextDatumGetCString(ownerNameDatum);
+	if (pg_strcasecmp(userName, ownerName) != 0)
+	{
+		/* otherwise, allow if the user has DELETE permission */
+		AclResult aclResult = pg_class_aclcheck(CronJobRelationId(), GetUserId(),
+												ACL_DELETE);
+		if (aclResult != ACLCHECK_OK)
+		{
+			aclcheck_error(aclResult, ACL_KIND_CLASS,
+						   get_rel_name(CronJobRelationId()));
+		}
+	}
+
+	simple_heap_delete(cronJobsTable, &heapTuple->t_self);
+	CommandCounterIncrement();
+
+	systable_endscan(scanDescriptor);
+	heap_close(cronJobsTable, RowExclusiveLock);
+
+	InvalidateJobCache();
+
+	PG_RETURN_BOOL(true);
+}
+
+
+/*
+ * cron_job_cache_invalidate invalidates the job cache in response to
+ * a trigger.
+ */
+Datum
+cron_job_cache_invalidate(PG_FUNCTION_ARGS)
+{
+	if (!CALLED_AS_TRIGGER(fcinfo))
+	{
+		ereport(ERROR, (errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),
+						errmsg("must be called as trigger")));
+	}
+
+	InvalidateJobCache();
+
+	PG_RETURN_DATUM(PointerGetDatum(NULL));
+}
+
+
+/*
+ * Invalidate job cache ensures the job cache is reloaded on the next
+ * iteration of pg_cron.
+ */
+static void
+InvalidateJobCache(void)
+{
+	HeapTuple classTuple = NULL;
+
+	classTuple = SearchSysCache1(RELOID, ObjectIdGetDatum(CronJobRelationId()));
+	if (HeapTupleIsValid(classTuple))
+	{
+		CacheInvalidateRelcacheByTuple(classTuple);
+		ReleaseSysCache(classTuple);
+	}
+}
+
+
+/*
+ * InvalidateJobCacheCallback invalidates the job cache in response to
+ * an invalidation event.
+ */
+static void
+InvalidateJobCacheCallback(Datum argument, Oid relationId)
+{
+	if (relationId == CachedCronJobRelationId ||
+		CachedCronJobRelationId == InvalidOid)
+	{
+		CronJobCacheValid = false;
+		CachedCronJobRelationId = InvalidOid;
+	}
+}
+
+
+/*
+ * CachedCronJobRelationId returns a cached oid of the cron.job relation.
+ */
+static Oid
+CronJobRelationId(void)
+{
+	if (CachedCronJobRelationId == InvalidOid)
+	{
+		Oid cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
+
+		CachedCronJobRelationId = get_relname_relid(JOBS_TABLE_NAME, cronSchemaId);
+	}
+
+	return CachedCronJobRelationId;
+}
+
+
+/*
+ * LoadCronJobList loads the current list of jobs from the
+ * cron.job table and adds each job to the CronJobHash.
+ */
+List *
+LoadCronJobList(void)
+{
+	List *jobList = NIL;
+
+	Relation cronJobTable = NULL;
+
+	SysScanDesc scanDescriptor = NULL;
+	ScanKeyData scanKey[1];
+	int scanKeyCount = 0;
+	HeapTuple heapTuple = NULL;
+	TupleDesc tupleDescriptor = NULL;
+
+	SetCurrentStatementStartTimestamp();
+	StartTransactionCommand();
+	PushActiveSnapshot(GetTransactionSnapshot());
+
+	/*
+	 * If the pg_cron extension has not been created yet or
+	 * we are on a hot standby, the job table is treated as
+	 * being empty.
+	 */
+	if (!PgCronHasBeenLoaded() || RecoveryInProgress())
+	{
+		PopActiveSnapshot();
+		CommitTransactionCommand();
+		pgstat_report_activity(STATE_IDLE, NULL);
+
+		return NIL;
+	}
+
+	cronJobTable = heap_open(CronJobRelationId(), AccessShareLock);
+
+	scanDescriptor = systable_beginscan(cronJobTable,
+										InvalidOid, false,
+										NULL, scanKeyCount, scanKey);
+
+	tupleDescriptor = RelationGetDescr(cronJobTable);
+
+	heapTuple = systable_getnext(scanDescriptor);
+	while (HeapTupleIsValid(heapTuple))
+	{
+		MemoryContext oldContext = NULL;
+		CronJob *job = NULL;
+
+		oldContext = MemoryContextSwitchTo(CronJobContext);
+
+		job = TupleToCronJob(tupleDescriptor, heapTuple);
+		jobList = lappend(jobList, job);
+
+		MemoryContextSwitchTo(oldContext);
+
+		heapTuple = systable_getnext(scanDescriptor);
+	}
+
+	systable_endscan(scanDescriptor);
+	heap_close(cronJobTable, AccessShareLock);
+
+	PopActiveSnapshot();
+	CommitTransactionCommand();
+	pgstat_report_activity(STATE_IDLE, NULL);
+
+	return jobList;
+}
+
+
+/*
+ * TupleToCronJob takes a heap tuple and converts it into a CronJob
+ * struct.
+ */
+static CronJob *
+TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
+{
+	CronJob *job = NULL;
+	int64 jobKey = 0;
+	bool isNull = false;
+	bool isPresent = false;
+	entry *parsedSchedule = NULL;
+
+	Datum jobId = heap_getattr(heapTuple, Anum_cron_job_jobid,
+							   tupleDescriptor, &isNull);
+	Datum schedule = heap_getattr(heapTuple, Anum_cron_job_schedule,
+								  tupleDescriptor, &isNull);
+	Datum command = heap_getattr(heapTuple, Anum_cron_job_command,
+								 tupleDescriptor, &isNull);
+	Datum nodeName = heap_getattr(heapTuple, Anum_cron_job_nodename,
+								  tupleDescriptor, &isNull);
+	Datum nodePort = heap_getattr(heapTuple, Anum_cron_job_nodeport,
+								  tupleDescriptor, &isNull);
+	Datum database = heap_getattr(heapTuple, Anum_cron_job_database,
+								  tupleDescriptor, &isNull);
+	Datum userName = heap_getattr(heapTuple, Anum_cron_job_username,
+								  tupleDescriptor, &isNull);
+
+	Assert(!HeapTupleHasNulls(heapTuple));
+
+	jobKey = DatumGetUInt32(jobId);
+	job = hash_search(CronJobHash, &jobKey, HASH_ENTER, &isPresent);
+
+	job->jobId = DatumGetUInt32(jobId);
+	job->scheduleText = TextDatumGetCString(schedule);
+	job->command = TextDatumGetCString(command);
+	job->nodeName = TextDatumGetCString(nodeName);
+	job->nodePort = DatumGetUInt32(nodePort);
+	job->userName = TextDatumGetCString(userName);
+	job->database = TextDatumGetCString(database);
+
+	parsedSchedule = parse_cron_entry(job->scheduleText);
+	if (parsedSchedule != NULL)
+	{
+		/* copy the schedule and free the allocated memory immediately */
+
+		job->schedule = *parsedSchedule;
+		free_entry(parsedSchedule);
+	}
+	else
+	{
+		ereport(LOG, (errmsg("invalid pg_cron schedule for job %ld: %s",
+							 jobId, job->scheduleText)));
+
+		/* a zeroed out schedule never runs */
+		memset(&job->schedule, 0, sizeof(entry));
+	}
+
+	return job;
+}
+
+
+/*
+ * PgCronHasBeenLoaded returns true if the pg_cron extension has been created
+ * in the current database and the extension script has been executed. Otherwise,
+ * it returns false. The result is cached as this is called very frequently.
+ */
+static bool
+PgCronHasBeenLoaded(void)
+{
+	bool extensionLoaded = false;
+	bool extensionPresent = false;
+	bool extensionScriptExecuted = true;
+
+	Oid extensionOid = get_extension_oid(EXTENSION_NAME, true);
+	if (extensionOid != InvalidOid)
+	{
+		extensionPresent = true;
+	}
+
+	if (extensionPresent)
+	{
+		/* check if pg_cron extension objects are still being created */
+		if (creating_extension && CurrentExtensionObject == extensionOid)
+		{
+			extensionScriptExecuted = false;
+		}
+		else if (IsBinaryUpgrade)
+		{
+			extensionScriptExecuted = false;
+		}
+	}
+
+	extensionLoaded = extensionPresent && extensionScriptExecuted;
+
+	return extensionLoaded;
+}
diff --git a/src/pg_cron.c b/src/pg_cron.c
index b56a68a..5b5afb9 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -27,7 +27,8 @@
 #include "cron.h"
 
 #include "pg_cron.h"
-#include "cron_job.h"
+#include "task_states.h"
+#include "job_metadata.h"
 
 #include "poll.h"
 #include "sys/time.h"
@@ -64,32 +65,26 @@
 #include "tcop/utility.h"
 
 
-#define CRON_SCHEMA_NAME "cron"
-#define JOBS_TABLE_NAME "job"
-#define JOB_ID_INDEX_NAME "job_pkey"
-#define JOB_ID_SEQUENCE_NAME "cron.jobid_seq"
+PG_MODULE_MAGIC;
 
 
-PG_MODULE_MAGIC;
+/* ways in which the clock can change between main loop iterations */
+typedef enum
+{
+	CLOCK_JUMP_BACKWARD = 0,
+	CLOCK_PROGRESSED = 1,
+	CLOCK_JUMP_FORWARD = 2,
+	CLOCK_CHANGE = 3
+} ClockProgress;
 
 
+/* forward declarations */
 void _PG_init(void);
 void _PG_fini(void);
 static void pg_cron_sigterm(SIGNAL_ARGS);
 static void pg_cron_sighup(SIGNAL_ARGS);
 static void PgCronWorkerMain(Datum arg);
 
-static int64 NextJobId();
-static Oid CronExtensionOwner(void);
-static void InvalidateJobCacheCallback(Datum argument, Oid relationId);
-static void InvalidateJobCache(void);
-static Oid CronJobRelationId(void);
-
-static void ReloadCronJobs(void);
-static List * LoadCronJobList(void);
-static CronJob * TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple);
-static bool PgCronHasBeenLoaded(void);
-
 static void StartAllPendingRuns(List *taskList, TimestampTz currentTime);
 static void StartPendingRuns(CronTask *task, ClockProgress clockProgress,
 							 TimestampTz lastMinute, TimestampTz currentTime);
@@ -99,41 +94,24 @@ static TimestampTz TimestampMinuteEnd(TimestampTz time);
 static bool ShouldRunTask(entry *schedule, TimestampTz currentMinute,
 						  bool doWild, bool doNonWild);
 
-static List * CurrentTaskList(void);
 static void WaitForCronTasks(List *taskList);
 static void PollForTasks(List *taskList);
 static void ManageCronTasks(List *taskList, TimestampTz currentTime);
 static void ManageCronTask(CronTask *task, TimestampTz currentTime);
 
-static HTAB * CreateCronJobHash(void);
-static HTAB * CreateCronTaskHash(void);
-static CronJob * GetCronJob(int64 jobId);
-static CronTask * GetCronTask(int64 jobId);
-static void InitializeCronTask(CronTask *task, int64 jobId);
 
+/* global settings */
+char *CronTableDatabaseName = "postgres";
+static bool CronLogStatement = true;
 
 /* flags set by signal handlers */
 static volatile sig_atomic_t got_sigterm = false;
 
-static MemoryContext CronJobContext = NULL;
-static MemoryContext CronTaskContext = NULL;
-static HTAB *CronJobHash = NULL;
-static HTAB *CronTaskHash = NULL;
-static bool CronJobCacheValid = false;
-static Oid CachedCronJobRelationId = InvalidOid;
-static bool RebootJobsScheduled = false;
-static int64 RunCount = 0;
-
-static char *CronTableDatabaseName = "postgres";
-static bool CronLogStatement = true;
+/* global variables */
+static int64 RunCount = 0; /* counter for assigning unique run IDs */
 static int CronTaskStartTimeout = 10000; /* maximum connection time */
 static const int MaxWait = 1000; /* maximum time in ms that poll() can block */
-
-
-/* declarations for dynamic loading */
-PG_FUNCTION_INFO_V1(cron_schedule);
-PG_FUNCTION_INFO_V1(cron_unschedule);
-PG_FUNCTION_INFO_V1(cron_job_cache_invalidate);
+static bool RebootJobsScheduled = false;
 
 
 /*
@@ -171,9 +149,6 @@ _PG_init(void)
 		GUC_SUPERUSER_ONLY,
 		NULL, NULL, NULL);
 
-	/* watch for invalidation events */
-	CacheRegisterRelcacheCallback(InvalidateJobCacheCallback, (Datum) 0);
-
 	/* set up common data for all our workers */
 	worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
 	worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
@@ -231,26 +206,14 @@ PgCronWorkerMain(Datum arg)
 	/* Connect to our database */
 	BackgroundWorkerInitializeConnection(CronTableDatabaseName, NULL);
 
-	CronJobContext = AllocSetContextCreate(CurrentMemoryContext,
-										   "pg_cron job context",
-										   ALLOCSET_DEFAULT_MINSIZE,
-										   ALLOCSET_DEFAULT_INITSIZE,
-										   ALLOCSET_DEFAULT_MAXSIZE);
-
-	CronTaskContext = AllocSetContextCreate(CurrentMemoryContext,
-											"pg_cron task context",
-											ALLOCSET_DEFAULT_MINSIZE,
-											ALLOCSET_DEFAULT_INITSIZE,
-											ALLOCSET_DEFAULT_MAXSIZE);
-
 	CronLoopContext = AllocSetContextCreate(CurrentMemoryContext,
 											"pg_cron loop context",
 											ALLOCSET_DEFAULT_MINSIZE,
 											ALLOCSET_DEFAULT_INITSIZE,
 											ALLOCSET_DEFAULT_MAXSIZE);
 
-	CronJobHash = CreateCronJobHash();
-	CronTaskHash = CreateCronTaskHash();
+	InitializeJobMetadataCache();
+	InitializeTaskStateHash();
 
 	ereport(LOG, (errmsg("pg_cron scheduler started")));
 
@@ -265,7 +228,7 @@ PgCronWorkerMain(Datum arg)
 
 		if (!CronJobCacheValid)
 		{
-			ReloadCronJobs();
+			RefreshTaskHash();
 		}
 
 		taskList = CurrentTaskList();
@@ -285,513 +248,6 @@ PgCronWorkerMain(Datum arg)
 }
 
 
-/*
- * cluster_schedule schedules a cron job.
- */
-Datum
-cron_schedule(PG_FUNCTION_ARGS)
-{
-	text *scheduleText = PG_GETARG_TEXT_P(0);
-	text *commandText = PG_GETARG_TEXT_P(1);
-
-	char *schedule = text_to_cstring(scheduleText);
-	char *command = text_to_cstring(commandText);
-	entry *parsedSchedule = NULL;
-
-	int64 jobId = 0;
-	Datum jobIdDatum = 0;
-
-	Oid cronSchemaId = InvalidOid;
-	Oid cronJobsRelationId = InvalidOid;
-
-	Relation cronJobsTable = NULL;
-	TupleDesc tupleDescriptor = NULL;
-	HeapTuple heapTuple = NULL;
-	Datum values[Natts_cron_job];
-	bool isNulls[Natts_cron_job];
-
-	Oid userId = GetUserId();
-	char *userName = GetUserNameFromId(userId, false);
-
-	parsedSchedule = parse_cron_entry(schedule);
-	if (parsedSchedule == NULL)
-	{
-		free_entry(parsedSchedule);
-
-		ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
-						errmsg("invalid schedule: %s", schedule)));
-	}
-
-	free_entry(parsedSchedule);
-
-	/* form new job tuple */
-	memset(values, 0, sizeof(values));
-	memset(isNulls, false, sizeof(isNulls));
-
-	jobId = NextJobId();
-	jobIdDatum = Int64GetDatum(jobId);
-
-	values[Anum_cron_job_jobid - 1] = jobIdDatum;
-	values[Anum_cron_job_schedule - 1] = CStringGetTextDatum(schedule);
-	values[Anum_cron_job_command - 1] = CStringGetTextDatum(command);
-	values[Anum_cron_job_nodename - 1] = CStringGetTextDatum("localhost");
-	values[Anum_cron_job_nodeport - 1] = Int32GetDatum(PostPortNumber);
-	values[Anum_cron_job_database - 1] = CStringGetTextDatum(CronTableDatabaseName);
-	values[Anum_cron_job_username - 1] = CStringGetTextDatum(userName);
-
-	cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
-	cronJobsRelationId = get_relname_relid(JOBS_TABLE_NAME, cronSchemaId);
-
-	/* open jobs relation and insert new tuple */
-	cronJobsTable = heap_open(cronJobsRelationId, RowExclusiveLock);
-
-	tupleDescriptor = RelationGetDescr(cronJobsTable);
-	heapTuple = heap_form_tuple(tupleDescriptor, values, isNulls);
-
-	simple_heap_insert(cronJobsTable, heapTuple);
-	CatalogUpdateIndexes(cronJobsTable, heapTuple);
-	CommandCounterIncrement();
-
-	/* close relation and invalidate previous cache entry */
-	heap_close(cronJobsTable, RowExclusiveLock);
-
-	InvalidateJobCache();
-
-	PG_RETURN_INT64(jobId);
-}
-
-
-/*
- * NextJobId returns a new, unique job ID using the job ID sequence.
- */
-static int64
-NextJobId(void)
-{
-	text *sequenceName = NULL;
-	Oid sequenceId = InvalidOid;
-	List *sequenceNameList = NIL;
-	RangeVar *sequenceVar = NULL;
-	Datum sequenceIdDatum = InvalidOid;
-	Oid savedUserId = InvalidOid;
-	int savedSecurityContext = 0;
-	Datum jobIdDatum = 0;
-	int64 jobId = 0;
-	bool failOK = true;
-
-	/* resolve relationId from passed in schema and relation name */
-	sequenceName = cstring_to_text(JOB_ID_SEQUENCE_NAME);
-	sequenceNameList = textToQualifiedNameList(sequenceName);
-	sequenceVar = makeRangeVarFromNameList(sequenceNameList);
-	sequenceId = RangeVarGetRelid(sequenceVar, NoLock, failOK);
-	sequenceIdDatum = ObjectIdGetDatum(sequenceId);
-
-	GetUserIdAndSecContext(&savedUserId, &savedSecurityContext);
-	SetUserIdAndSecContext(CronExtensionOwner(), SECURITY_LOCAL_USERID_CHANGE);
-
-	/* generate new and unique colocation id from sequence */
-	jobIdDatum = DirectFunctionCall1(nextval_oid, sequenceIdDatum);
-
-	SetUserIdAndSecContext(savedUserId, savedSecurityContext);
-
-	jobId = DatumGetUInt32(jobIdDatum);
-
-	return jobId;
-}
-
-
-/*
- * CronExtensionOwner returns the name of the user that owns the
- * extension.
- */
-static Oid
-CronExtensionOwner(void)
-{
-	Relation extensionRelation = NULL;
-	SysScanDesc scanDescriptor;
-	ScanKeyData entry[1];
-	HeapTuple extensionTuple = NULL;
-	Form_pg_extension extensionForm = NULL;
-	Oid extensionOwner = InvalidOid;
-
-	extensionRelation = heap_open(ExtensionRelationId, AccessShareLock);
-
-	ScanKeyInit(&entry[0],
-				Anum_pg_extension_extname,
-				BTEqualStrategyNumber, F_NAMEEQ,
-				CStringGetDatum("pg_cron"));
-
-	scanDescriptor = systable_beginscan(extensionRelation, ExtensionNameIndexId,
-										true, NULL, 1, entry);
-
-	extensionTuple = systable_getnext(scanDescriptor);
-	if (!HeapTupleIsValid(extensionTuple))
-	{
-		ereport(ERROR, (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),
-						errmsg("pg_cron extension not loaded")));
-	}
-
-	extensionForm = (Form_pg_extension) GETSTRUCT(extensionTuple);
-	extensionOwner = extensionForm->extowner;
-
-	systable_endscan(scanDescriptor);
-	heap_close(extensionRelation, AccessShareLock);
-
-	return extensionOwner;
-}
-
-
-/*
- * cluster_unschedule removes a cron job.
- */
-Datum
-cron_unschedule(PG_FUNCTION_ARGS)
-{
-	int64 jobId = PG_GETARG_INT64(0);
-
-	Oid cronSchemaId = InvalidOid;
-	Oid cronJobIndexId = InvalidOid;
-
-	Relation cronJobsTable = NULL;
-	SysScanDesc scanDescriptor = NULL;
-	ScanKeyData scanKey[1];
-	int scanKeyCount = 1;
-	bool indexOK = true;
-	TupleDesc tupleDescriptor = NULL;
-	HeapTuple heapTuple = NULL;
-	bool isNull = false;
-	Oid userId = InvalidOid;
-	char *userName = NULL;
-	Datum ownerNameDatum = 0;
-	char *ownerName = NULL;
-
-	cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
-	cronJobIndexId = get_relname_relid(JOB_ID_INDEX_NAME, cronSchemaId);
-
-	cronJobsTable = heap_open(CronJobRelationId(), RowExclusiveLock);
-
-	ScanKeyInit(&scanKey[0], Anum_cron_job_jobid,
-				BTEqualStrategyNumber, F_INT8EQ, Int64GetDatum(jobId));
-
-	scanDescriptor = systable_beginscan(cronJobsTable,
-										cronJobIndexId, indexOK,
-										NULL, scanKeyCount, scanKey);
-
-	tupleDescriptor = RelationGetDescr(cronJobsTable);
-
-	heapTuple = systable_getnext(scanDescriptor);
-	if (!HeapTupleIsValid(heapTuple))
-	{
-		ereport(ERROR, (errmsg("could not find valid entry for job "
-							   UINT64_FORMAT, jobId)));
-	}
-
-	/* check if the current user owns the row */
-	userId = GetUserId();
-	userName = GetUserNameFromId(userId, false);
-
-	ownerNameDatum = heap_getattr(heapTuple, Anum_cron_job_username,
-								  tupleDescriptor, &isNull);
-	ownerName = TextDatumGetCString(ownerNameDatum);
-	if (pg_strcasecmp(userName, ownerName) != 0)
-	{
-		/* otherwise, allow if the user has DELETE permission */
-		AclResult aclResult = pg_class_aclcheck(CronJobRelationId(), GetUserId(),
-												ACL_DELETE);
-		if (aclResult != ACLCHECK_OK)
-		{
-			aclcheck_error(aclResult, ACL_KIND_CLASS,
-						   get_rel_name(CronJobRelationId()));
-		}
-	}
-
-	simple_heap_delete(cronJobsTable, &heapTuple->t_self);
-	CommandCounterIncrement();
-
-	systable_endscan(scanDescriptor);
-	heap_close(cronJobsTable, RowExclusiveLock);
-
-	InvalidateJobCache();
-
-	PG_RETURN_BOOL(true);
-}
-
-
-/*
- * cron_job_cache_invalidate invalidates the job cache in response to
- * a trigger.
- */
-Datum
-cron_job_cache_invalidate(PG_FUNCTION_ARGS)
-{
-	if (!CALLED_AS_TRIGGER(fcinfo))
-	{
-		ereport(ERROR, (errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),
-						errmsg("must be called as trigger")));
-	}
-
-	InvalidateJobCache();
-
-	PG_RETURN_DATUM(PointerGetDatum(NULL));
-}
-
-
-/*
- * Invalidate job cache ensures the job cache is reloaded on the next
- * iteration of pg_cron.
- */
-static void
-InvalidateJobCache(void)
-{
-	HeapTuple classTuple = NULL;
-
-	classTuple = SearchSysCache1(RELOID, ObjectIdGetDatum(CronJobRelationId()));
-	if (HeapTupleIsValid(classTuple))
-	{
-		CacheInvalidateRelcacheByTuple(classTuple);
-		ReleaseSysCache(classTuple);
-	}
-}
-
-
-/*
- * InvalidateJobCacheCallback invalidates the job cache in response to
- * an invalidation event.
- */
-static void
-InvalidateJobCacheCallback(Datum argument, Oid relationId)
-{
-	if (relationId == CachedCronJobRelationId ||
-		CachedCronJobRelationId == InvalidOid)
-	{
-		CronJobCacheValid = false;
-		CachedCronJobRelationId = InvalidOid;
-	}
-}
-
-
-/*
- * CachedCronJobRelationId returns a cached oid of the cron.job relation.
- */
-static Oid
-CronJobRelationId(void)
-{
-	if (CachedCronJobRelationId == InvalidOid)
-	{
-		Oid cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
-
-		CachedCronJobRelationId = get_relname_relid(JOBS_TABLE_NAME, cronSchemaId);
-	}
-
-	return CachedCronJobRelationId;
-}
-
-
-/*
- * ReloadCronJobs reloads the cron jobs from the cron.job table.
- * If a job that has an active task has been removed, the task
- * is marked as inactive by this function.
- */
-static void
-ReloadCronJobs(void)
-{
-	List *jobList = NIL;
-	ListCell *jobCell = NULL;
-	CronTask *task = NULL;
-	HASH_SEQ_STATUS status;
-
-	/* destroy old job hash */
-	MemoryContextResetAndDeleteChildren(CronJobContext);
-
-	CronJobHash = CreateCronJobHash();
-
-	hash_seq_init(&status, CronTaskHash);
-
-	/* mark all tasks as inactive */
-	while ((task = hash_seq_search(&status)) != NULL)
-	{
-		task->isActive = false;
-	}
-
-	jobList = LoadCronJobList();
-
-	/* mark tasks that still have a job as active */
-	foreach(jobCell, jobList)
-	{
-		CronJob *job = (CronJob *) lfirst(jobCell);
-
-		CronTask *task = GetCronTask(job->jobId);
-		task->isActive = true;
-	}
-
-	CronJobCacheValid = true;
-}
-
-
-/*
- * LoadCronJobList loads the current list of jobs from the
- * cron.job table and adds each job to the CronJobHash.
- */
-static List *
-LoadCronJobList(void)
-{
-	List *jobList = NIL;
-
-	Relation cronJobTable = NULL;
-
-	SysScanDesc scanDescriptor = NULL;
-	ScanKeyData scanKey[1];
-	int scanKeyCount = 0;
-	HeapTuple heapTuple = NULL;
-	TupleDesc tupleDescriptor = NULL;
-
-	SetCurrentStatementStartTimestamp();
-	StartTransactionCommand();
-	PushActiveSnapshot(GetTransactionSnapshot());
-
-	/*
-	 * If the pg_cron extension has not been created yet or
-	 * we are on a hot standby, the job table is treated as
-	 * being empty.
-	 */
-	if (!PgCronHasBeenLoaded() || RecoveryInProgress())
-	{
-		PopActiveSnapshot();
-		CommitTransactionCommand();
-		pgstat_report_activity(STATE_IDLE, NULL);
-
-		return NIL;
-	}
-
-	cronJobTable = heap_open(CronJobRelationId(), AccessShareLock);
-
-	scanDescriptor = systable_beginscan(cronJobTable,
-										InvalidOid, false,
-										NULL, scanKeyCount, scanKey);
-
-	tupleDescriptor = RelationGetDescr(cronJobTable);
-
-	heapTuple = systable_getnext(scanDescriptor);
-	while (HeapTupleIsValid(heapTuple))
-	{
-		MemoryContext oldContext = NULL;
-		CronJob *job = NULL;
-
-		oldContext = MemoryContextSwitchTo(CronJobContext);
-
-		job = TupleToCronJob(tupleDescriptor, heapTuple);
-		jobList = lappend(jobList, job);
-
-		MemoryContextSwitchTo(oldContext);
-
-		heapTuple = systable_getnext(scanDescriptor);
-	}
-
-	systable_endscan(scanDescriptor);
-	heap_close(cronJobTable, AccessShareLock);
-
-	PopActiveSnapshot();
-	CommitTransactionCommand();
-	pgstat_report_activity(STATE_IDLE, NULL);
-
-	return jobList;
-}
-
-
-/*
- * TupleToCronJob takes a heap tuple and converts it into a CronJob
- * struct.
- */
-static CronJob *
-TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
-{
-	CronJob *job = NULL;
-	int64 jobKey = 0;
-	bool isNull = false;
-	bool isPresent = false;
-	entry *parsedSchedule = NULL;
-
-	Datum jobId = heap_getattr(heapTuple, Anum_cron_job_jobid,
-							   tupleDescriptor, &isNull);
-	Datum schedule = heap_getattr(heapTuple, Anum_cron_job_schedule,
-								  tupleDescriptor, &isNull);
-	Datum command = heap_getattr(heapTuple, Anum_cron_job_command,
-								 tupleDescriptor, &isNull);
-	Datum nodeName = heap_getattr(heapTuple, Anum_cron_job_nodename,
-								  tupleDescriptor, &isNull);
-	Datum nodePort = heap_getattr(heapTuple, Anum_cron_job_nodeport,
-								  tupleDescriptor, &isNull);
-	Datum database = heap_getattr(heapTuple, Anum_cron_job_database,
-								  tupleDescriptor, &isNull);
-	Datum userName = heap_getattr(heapTuple, Anum_cron_job_username,
-								  tupleDescriptor, &isNull);
-
-	Assert(!HeapTupleHasNulls(heapTuple));
-
-	jobKey = DatumGetUInt32(jobId);
-	job = hash_search(CronJobHash, &jobKey, HASH_ENTER, &isPresent);
-
-	job->jobId = DatumGetUInt32(jobId);
-	job->scheduleText = TextDatumGetCString(schedule);
-	job->command = TextDatumGetCString(command);
-	job->nodeName = TextDatumGetCString(nodeName);
-	job->nodePort = DatumGetUInt32(nodePort);
-	job->userName = TextDatumGetCString(userName);
-	job->database = TextDatumGetCString(database);
-
-	parsedSchedule = parse_cron_entry(job->scheduleText);
-	if (parsedSchedule != NULL)
-	{
-		/* copy the schedule and free the allocated memory immediately */
-
-		job->schedule = *parsedSchedule;
-		free_entry(parsedSchedule);
-	}
-	else
-	{
-		ereport(LOG, (errmsg("invalid pg_cron schedule for job %ld: %s",
-							 jobId, job->scheduleText)));
-
-		/* a zeroed out schedule never runs */
-		memset(&job->schedule, 0, sizeof(entry));
-	}
-
-	return job;
-}
-
-
-/*
- * PgCronHasBeenLoaded returns true if the pg_cron extension has been created
- * in the current database and the extension script has been executed. Otherwise,
- * it returns false. The result is cached as this is called very frequently.
- */
-static bool
-PgCronHasBeenLoaded(void)
-{
-	bool extensionLoaded = false;
-	bool extensionPresent = false;
-	bool extensionScriptExecuted = true;
-
-	Oid extensionOid = get_extension_oid("pg_cron", true);
-	if (extensionOid != InvalidOid)
-	{
-		extensionPresent = true;
-	}
-
-	if (extensionPresent)
-	{
-		/* check if PgCron extension objects are still being created */
-		if (creating_extension && CurrentExtensionObject == extensionOid)
-		{
-			extensionScriptExecuted = false;
-		}
-	}
-
-	extensionLoaded = extensionPresent && extensionScriptExecuted;
-
-	return extensionLoaded;
-}
-
-
 /*
  * StartPendingRuns goes through the list of tasks and kicks of
  * runs for tasks that should start, taking clock changes into
@@ -1081,28 +537,6 @@ ShouldRunTask(entry *schedule, TimestampTz currentTime, bool doWild,
 }
 
 
-/*
- * CurrentTaskList extracts the current list of tasks from the
- * cron task hash.
- */
-static List *
-CurrentTaskList(void)
-{
-	List *taskList = NIL;
-	CronTask *task = NULL;
-	HASH_SEQ_STATUS status;
-
-	hash_seq_init(&status, CronTaskHash);
-
-	while ((task = hash_seq_search(&status)) != NULL)
-	{
-		taskList = lappend(taskList, task);
-	}
-
-	return taskList;
-}
-
-
 /*
  * WaitForCronTasks blocks waiting for any active task for at most
  * 1 second.
@@ -1306,8 +740,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			if (!task->isActive)
 			{
 				/* remove task as well */
-				bool isPresent = false;
-				hash_search(CronTaskHash, &jobId, HASH_REMOVE, &isPresent);
+				RemoveTask(jobId);
 				break;
 			}
 
@@ -1620,8 +1053,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 			if (!task->isActive)
 			{
-				bool isPresent = false;
-				hash_search(CronTaskHash, &jobId, HASH_REMOVE, &isPresent);
+				RemoveTask(jobId);
 			}
 
 			if (task->errorMessage != NULL)
@@ -1645,98 +1077,3 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 	}
 }
-
-
-static HTAB *
-CreateCronJobHash(void)
-{
-	HTAB *taskHash = NULL;
-	HASHCTL info;
-	int hashFlags = 0;
-
-	memset(&info, 0, sizeof(info));
-	info.keysize = sizeof(int64);
-	info.entrysize = sizeof(CronJob);
-	info.hash = tag_hash;
-	info.hcxt = CronJobContext;
-	hashFlags = (HASH_ELEM | HASH_FUNCTION | HASH_CONTEXT);
-
-	taskHash = hash_create("pg_cron jobs", 32, &info, hashFlags);
-
-	return taskHash;
-}
-
-
-static HTAB *
-CreateCronTaskHash(void)
-{
-	HTAB *taskHash = NULL;
-	HASHCTL info;
-	int hashFlags = 0;
-
-	memset(&info, 0, sizeof(info));
-	info.keysize = sizeof(int64);
-	info.entrysize = sizeof(CronTask);
-	info.hash = tag_hash;
-	info.hcxt = CronTaskContext;
-	hashFlags = (HASH_ELEM | HASH_FUNCTION | HASH_CONTEXT);
-
-	taskHash = hash_create("pg_cron tasks", 32, &info, hashFlags);
-
-	return taskHash;
-}
-
-
-/*
- * GetCronTask gets the current task with the given job ID.
- */
-static CronTask *
-GetCronTask(int64 jobId)
-{
-	CronTask *task = NULL;
-	int64 hashKey = jobId;
-	bool isPresent = false;
-
-	task = hash_search(CronTaskHash, &hashKey, HASH_ENTER, &isPresent);
-	if (!isPresent)
-	{
-		InitializeCronTask(task, jobId);
-	}
-
-	return task;
-}
-
-
-/*
- * InitializeCronTask intializes a CronTask struct.
- */
-static void
-InitializeCronTask(CronTask *task, int64 jobId)
-{
-	task->runId = 0;
-	task->jobId = jobId;
-	task->state = CRON_TASK_WAITING;
-	task->pendingRunCount = 0;
-	task->connection = NULL;
-	task->pollingStatus = 0;
-	task->startDeadline = 0;
-	task->isSocketReady = false;
-	task->isActive = true;
-	task->errorMessage = NULL;
-}
-
-
-/*
- * GetCronJob gets the cron job with the given id.
- */
-static CronJob *
-GetCronJob(int64 jobId)
-{
-	CronJob *job = NULL;
-	int64 hashKey = jobId;
-	bool isPresent = false;
-
-	job = hash_search(CronJobHash, &hashKey, HASH_FIND, &isPresent);
-
-	return job;
-}
diff --git a/src/task_states.c b/src/task_states.c
new file mode 100644
index 0000000..c829b5f
--- /dev/null
+++ b/src/task_states.c
@@ -0,0 +1,180 @@
+/*-------------------------------------------------------------------------
+ *
+ * src/task_states.c
+ *
+ * Logic for storing and manipulating cron task states.
+ *
+ * Copyright (c) 2016, Citus Data, Inc.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#include "postgres.h"
+#include "fmgr.h"
+#include "miscadmin.h"
+
+#include "cron.h"
+#include "pg_cron.h"
+#include "task_states.h"
+
+#include "utils/hsearch.h"
+#include "utils/memutils.h"
+
+
+/* forward declarations */
+static HTAB * CreateCronTaskHash(void);
+static CronTask * GetCronTask(int64 jobId);
+
+/* global variables */
+static MemoryContext CronTaskContext = NULL;
+static HTAB *CronTaskHash = NULL;
+
+
+/*
+ * InitializeTaskStateHash initializes the hash for storing task states.
+ */
+void
+InitializeTaskStateHash(void)
+{
+	CronTaskContext = AllocSetContextCreate(CurrentMemoryContext,
+											"pg_cron task context",
+											ALLOCSET_DEFAULT_MINSIZE,
+											ALLOCSET_DEFAULT_INITSIZE,
+											ALLOCSET_DEFAULT_MAXSIZE);
+
+	CronTaskHash = CreateCronTaskHash();
+}
+
+
+/*
+ * CreateCronTaskHash creates the hash for storing cron task states.
+ */
+static HTAB *
+CreateCronTaskHash(void)
+{
+	HTAB *taskHash = NULL;
+	HASHCTL info;
+	int hashFlags = 0;
+
+	memset(&info, 0, sizeof(info));
+	info.keysize = sizeof(int64);
+	info.entrysize = sizeof(CronTask);
+	info.hash = tag_hash;
+	info.hcxt = CronTaskContext;
+	hashFlags = (HASH_ELEM | HASH_FUNCTION | HASH_CONTEXT);
+
+	taskHash = hash_create("pg_cron tasks", 32, &info, hashFlags);
+
+	return taskHash;
+}
+
+
+/*
+ * RefreshTaskHash reloads the cron jobs from the cron.job table.
+ * If a job that has an active task has been removed, the task
+ * is marked as inactive by this function.
+ */
+void
+RefreshTaskHash(void)
+{
+	List *jobList = NIL;
+	ListCell *jobCell = NULL;
+	CronTask *task = NULL;
+	HASH_SEQ_STATUS status;
+
+	ResetJobMetadataCache();
+
+	hash_seq_init(&status, CronTaskHash);
+
+	/* mark all tasks as inactive */
+	while ((task = hash_seq_search(&status)) != NULL)
+	{
+		task->isActive = false;
+	}
+
+	jobList = LoadCronJobList();
+
+	/* mark tasks that still have a job as active */
+	foreach(jobCell, jobList)
+	{
+		CronJob *job = (CronJob *) lfirst(jobCell);
+
+		CronTask *task = GetCronTask(job->jobId);
+		task->isActive = true;
+	}
+
+	CronJobCacheValid = true;
+}
+
+
+/*
+ * GetCronTask gets the current task with the given job ID.
+ */
+static CronTask *
+GetCronTask(int64 jobId)
+{
+	CronTask *task = NULL;
+	int64 hashKey = jobId;
+	bool isPresent = false;
+
+	task = hash_search(CronTaskHash, &hashKey, HASH_ENTER, &isPresent);
+	if (!isPresent)
+	{
+		InitializeCronTask(task, jobId);
+	}
+
+	return task;
+}
+
+
+/*
+ * InitializeCronTask intializes a CronTask struct.
+ */
+void
+InitializeCronTask(CronTask *task, int64 jobId)
+{
+	task->runId = 0;
+	task->jobId = jobId;
+	task->state = CRON_TASK_WAITING;
+	task->pendingRunCount = 0;
+	task->connection = NULL;
+	task->pollingStatus = 0;
+	task->startDeadline = 0;
+	task->isSocketReady = false;
+	task->isActive = true;
+	task->errorMessage = NULL;
+}
+
+
+/*
+ * CurrentTaskList extracts the current list of tasks from the
+ * cron task hash.
+ */
+List *
+CurrentTaskList(void)
+{
+	List *taskList = NIL;
+	CronTask *task = NULL;
+	HASH_SEQ_STATUS status;
+
+	hash_seq_init(&status, CronTaskHash);
+
+	while ((task = hash_seq_search(&status)) != NULL)
+	{
+		taskList = lappend(taskList, task);
+	}
+
+	return taskList;
+}
+
+
+/*
+ * RemoveTask remove the task for the given job ID.
+ */
+void
+RemoveTask(int64 jobId)
+{
+	bool isPresent = false;
+
+	hash_search(CronTaskHash, &jobId, HASH_REMOVE, &isPresent);
+}

COMMIT_HASH:e18037081628dcd3ac7ec085a2c0edd962cce094|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-11-07 15:39:31 +0100|TITLE:Use ereport for logging and add log_statement GUC|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 950548f..b56a68a 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -125,6 +125,7 @@ static bool RebootJobsScheduled = false;
 static int64 RunCount = 0;
 
 static char *CronTableDatabaseName = "postgres";
+static bool CronLogStatement = true;
 static int CronTaskStartTimeout = 10000; /* maximum connection time */
 static const int MaxWait = 1000; /* maximum time in ms that poll() can block */
 
@@ -160,6 +161,16 @@ _PG_init(void)
 		GUC_SUPERUSER_ONLY,
 		NULL, NULL, NULL);
 
+	DefineCustomBoolVariable(
+		"cron.log_statement",
+		gettext_noop("Log all cron statements prior to execution."),
+		NULL,
+		&CronLogStatement,
+		true,
+		PGC_POSTMASTER,
+		GUC_SUPERUSER_ONLY,
+		NULL, NULL, NULL);
+
 	/* watch for invalidation events */
 	CacheRegisterRelcacheCallback(InvalidateJobCacheCallback, (Datum) 0);
 
@@ -241,7 +252,7 @@ PgCronWorkerMain(Datum arg)
 	CronJobHash = CreateCronJobHash();
 	CronTaskHash = CreateCronTaskHash();
 
-	elog(LOG, "pg_cron scheduler started");
+	ereport(LOG, (errmsg("pg_cron scheduler started")));
 
 	MemoryContextSwitchTo(CronLoopContext);
 
@@ -268,7 +279,7 @@ PgCronWorkerMain(Datum arg)
 		MemoryContextReset(CronLoopContext);
 	}
 
-	elog(LOG, "pg_cron scheduler shutting down");
+	ereport(LOG, (errmsg("pg_cron scheduler shutting down")));
 
 	proc_exit(0);
 }
@@ -737,7 +748,8 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 	}
 	else
 	{
-		elog(LOG, "invalid pg_cron schedule for job %ld: %s", jobId, job->scheduleText);
+		ereport(LOG, (errmsg("invalid pg_cron schedule for job %ld: %s",
+							 jobId, job->scheduleText)));
 
 		/* a zeroed out schedule never runs */
 		memset(&job->schedule, 0, sizeof(entry));
@@ -1338,6 +1350,14 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 			Assert(sizeof(keywordArray) == sizeof(valueArray));
 
+			if (CronLogStatement)
+			{
+				char *command = cronJob->command;
+
+				ereport(LOG, (errmsg("cron job %ld statement: %s",
+									 jobId, command)));
+			}
+
 			connection = PQconnectStartParams(keywordArray, valueArray, false);
 			PQsetnonblocking(connection, 1);
 
@@ -1606,7 +1626,8 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 			if (task->errorMessage != NULL)
 			{
-				elog(LOG, "pg_cron job %ld: %s", jobId, task->errorMessage);
+				ereport(LOG, (errmsg("cron job %ld %s",
+									 jobId, task->errorMessage)));
 			}
 
 			task->startDeadline = 0;

COMMIT_HASH:1924d2a2fe4905aa7188a88cb0496b6690dd4b6f|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-11-07 14:47:07 +0100|TITLE:Stop granting scheduling permission to public|MESSAGE:
diff --git a/sql/pg_cron.sql b/sql/pg_cron.sql
index b5db37a..4c90ebc 100644
--- a/sql/pg_cron.sql
+++ b/sql/pg_cron.sql
@@ -13,10 +13,7 @@ END;
 $$;
 
 CREATE SCHEMA cron;
-GRANT USAGE ON SCHEMA cron TO public;
-
 CREATE SEQUENCE cron.jobid_seq;
-GRANT USAGE ON SEQUENCE cron.jobid_seq TO public;
 
 CREATE TABLE cron.job (
 	jobid bigint primary key default nextval('cron.jobid_seq'),
diff --git a/src/pg_cron.c b/src/pg_cron.c
index f60a2eb..950548f 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -39,6 +39,7 @@
 #include "access/htup_details.h"
 #include "access/xact.h"
 #include "access/xlog.h"
+#include "catalog/pg_extension.h"
 #include "catalog/indexing.h"
 #include "catalog/namespace.h"
 #include "commands/dbcommands.h"
@@ -78,6 +79,8 @@ static void pg_cron_sigterm(SIGNAL_ARGS);
 static void pg_cron_sighup(SIGNAL_ARGS);
 static void PgCronWorkerMain(Datum arg);
 
+static int64 NextJobId();
+static Oid CronExtensionOwner(void);
 static void InvalidateJobCacheCallback(Datum argument, Oid relationId);
 static void InvalidateJobCache(void);
 static Oid CronJobRelationId(void);
@@ -286,7 +289,6 @@ cron_schedule(PG_FUNCTION_ARGS)
 
 	int64 jobId = 0;
 	Datum jobIdDatum = 0;
-	Datum jobIdSequenceName = 0;
 
 	Oid cronSchemaId = InvalidOid;
 	Oid cronJobsRelationId = InvalidOid;
@@ -315,9 +317,8 @@ cron_schedule(PG_FUNCTION_ARGS)
 	memset(values, 0, sizeof(values));
 	memset(isNulls, false, sizeof(isNulls));
 
-	jobIdSequenceName = CStringGetTextDatum(JOB_ID_SEQUENCE_NAME);
-	jobIdDatum = DirectFunctionCall1(nextval, jobIdSequenceName);
-	jobId = DatumGetInt64(jobIdDatum);
+	jobId = NextJobId();
+	jobIdDatum = Int64GetDatum(jobId);
 
 	values[Anum_cron_job_jobid - 1] = jobIdDatum;
 	values[Anum_cron_job_schedule - 1] = CStringGetTextDatum(schedule);
@@ -349,6 +350,85 @@ cron_schedule(PG_FUNCTION_ARGS)
 }
 
 
+/*
+ * NextJobId returns a new, unique job ID using the job ID sequence.
+ */
+static int64
+NextJobId(void)
+{
+	text *sequenceName = NULL;
+	Oid sequenceId = InvalidOid;
+	List *sequenceNameList = NIL;
+	RangeVar *sequenceVar = NULL;
+	Datum sequenceIdDatum = InvalidOid;
+	Oid savedUserId = InvalidOid;
+	int savedSecurityContext = 0;
+	Datum jobIdDatum = 0;
+	int64 jobId = 0;
+	bool failOK = true;
+
+	/* resolve relationId from passed in schema and relation name */
+	sequenceName = cstring_to_text(JOB_ID_SEQUENCE_NAME);
+	sequenceNameList = textToQualifiedNameList(sequenceName);
+	sequenceVar = makeRangeVarFromNameList(sequenceNameList);
+	sequenceId = RangeVarGetRelid(sequenceVar, NoLock, failOK);
+	sequenceIdDatum = ObjectIdGetDatum(sequenceId);
+
+	GetUserIdAndSecContext(&savedUserId, &savedSecurityContext);
+	SetUserIdAndSecContext(CronExtensionOwner(), SECURITY_LOCAL_USERID_CHANGE);
+
+	/* generate new and unique colocation id from sequence */
+	jobIdDatum = DirectFunctionCall1(nextval_oid, sequenceIdDatum);
+
+	SetUserIdAndSecContext(savedUserId, savedSecurityContext);
+
+	jobId = DatumGetUInt32(jobIdDatum);
+
+	return jobId;
+}
+
+
+/*
+ * CronExtensionOwner returns the name of the user that owns the
+ * extension.
+ */
+static Oid
+CronExtensionOwner(void)
+{
+	Relation extensionRelation = NULL;
+	SysScanDesc scanDescriptor;
+	ScanKeyData entry[1];
+	HeapTuple extensionTuple = NULL;
+	Form_pg_extension extensionForm = NULL;
+	Oid extensionOwner = InvalidOid;
+
+	extensionRelation = heap_open(ExtensionRelationId, AccessShareLock);
+
+	ScanKeyInit(&entry[0],
+				Anum_pg_extension_extname,
+				BTEqualStrategyNumber, F_NAMEEQ,
+				CStringGetDatum("pg_cron"));
+
+	scanDescriptor = systable_beginscan(extensionRelation, ExtensionNameIndexId,
+										true, NULL, 1, entry);
+
+	extensionTuple = systable_getnext(scanDescriptor);
+	if (!HeapTupleIsValid(extensionTuple))
+	{
+		ereport(ERROR, (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),
+						errmsg("pg_cron extension not loaded")));
+	}
+
+	extensionForm = (Form_pg_extension) GETSTRUCT(extensionTuple);
+	extensionOwner = extensionForm->extowner;
+
+	systable_endscan(scanDescriptor);
+	heap_close(extensionRelation, AccessShareLock);
+
+	return extensionOwner;
+}
+
+
 /*
  * cluster_unschedule removes a cron job.
  */

COMMIT_HASH:a9a3696eaa8e8a7bc485ccf412d965f0091321ef|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-11-07 14:06:26 +0100|TITLE:Remove unused cron code|MESSAGE:
diff --git a/include/cron.h b/include/cron.h
index 70d0e0a..457bc29 100644
--- a/include/cron.h
+++ b/include/cron.h
@@ -19,6 +19,8 @@
  *
  * $Id: cron.h,v 2.10 1994/01/15 20:43:43 vixie Exp $
  *
+ * marco 07nov16 [remove code not needed by pg_cron]
+ * marco 04sep16 [integrate into pg_cron]
  * vix 14nov88 [rest of log is in RCS]
  * vix 14jan87 [0 or 7 can be sunday; thanks, mwm@berkeley]
  * vix 30dec86 [written]
@@ -30,27 +32,13 @@
 #include <sys/param.h>
 
 #include <stdio.h>
-#include <ctype.h>
 #include <bitstring.h>
-#include <pwd.h>
-#include <sys/wait.h>
-
-#include "pathnames.h"
-
 #if SYS_TIME_H
 # include <sys/time.h>
 #else
 # include <time.h>
 #endif
 
-
-#ifdef WITH_SELINUX
-#include <selinux/selinux.h>
-#endif
-
-#define SYSUSERNAME "root"
-
-
 	/* these are really immutable, and are
 	 *   defined for symbolic convenience only
 	 * TRUE, FALSE, and ERR must be distinct
@@ -233,35 +221,12 @@ typedef struct _file_buffer {
 
 void	unget_char __P((int, FILE *)),
 		free_entry __P((entry *)),
-		skip_comments __P((FILE *)),
-		log_it __P((char *, int, char *, char *)),
-		log_close __P((void)),
-		check_orphans __P((cron_db *));
-
-int		job_runqueue __P((void)),
-		set_debug_flags __P((char *)),
-		get_char __P((FILE *)),
-		get_string __P((char *, int, FILE *, char *)),
-		swap_uids __P((void)),
-		swap_uids_back __P((void)),
-		cron_pclose __P((FILE *)),
-		strcmp_until __P((char *, char *, int)),
-		allowed __P((char *)),
-		strdtb __P((char *));
-
-long            get_gmtoff(time_t *, struct tm *);
-
-char	*arpadate __P((time_t *)),
-		*mkprints __P((unsigned char *, unsigned int)),
-		*first_word __P((char *, char *));
-
-user		*load_user __P((int, struct passwd *, char *, char *, char *)),
-		*find_user __P((cron_db *, char *));
-
-entry * parse_cron_entry(char *);
+		skip_comments __P((FILE *));
 
-FILE		*cron_popen __P((char *, char *, entry *));
+int		get_char __P((FILE *)),
+		get_string __P((char *, int, FILE *, char *));
 
+entry * parse_cron_entry(char *);
 
 				/* in the C tradition, we only create
 				 * variables for the main program, just
@@ -305,16 +270,8 @@ char	*ecodes[] = {
 char	*ProgramName;
 int	LineNumber;
 time_t	StartTime;
-time_min timeRunning;
 time_min virtualTime;
 time_min clockTime;
-long GMToff;
-
-int	stay_foreground;
-int     lsbsysinit_mode;
-int     fqdn_in_subject;
-int     log_level = 1;
-char    cron_default_mail_charset[MAX_ENVSTR] = "";
 
 # if DEBUGGING
 int	DebugFlags;
@@ -328,15 +285,10 @@ extern	char	*copyright[],
 		*MonthNames[],
 		*DowNames[],
 		*ProgramName;
-extern  int     lsbsysinit_mode;
-extern  int     fqdn_in_subject;
-extern  int     log_level;
 extern	int	LineNumber;
 extern	time_t	StartTime;
-extern  time_min timeRunning;
 extern  time_min virtualTime;
 extern  time_min clockTime;
-extern  char     cron_default_mail_charset[MAX_ENVSTR];
 # if DEBUGGING
 extern	int	DebugFlags;
 extern	char	*DebugFlagNames[];
diff --git a/src/entry.c b/src/entry.c
index 6455a26..25231ff 100644
--- a/src/entry.c
+++ b/src/entry.c
@@ -15,7 +15,8 @@
  * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
  */
 
-/* vix 26jan87 [RCS'd; rest of log is in RCS file]
+/* marco 04sep16 [integrated into pg_cron]
+ * vix 26jan87 [RCS'd; rest of log is in RCS file]
  * vix 01jan87 [added line-level error recovery]
  * vix 31dec86 [added /step to the from-to range, per bob@acornrc]
  * vix 30dec86 [written]
diff --git a/src/misc.c b/src/misc.c
index b5a4baa..d28d9b8 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -15,7 +15,9 @@
  * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
  */
 
-/* vix 26jan87 [RCS has the rest of the log]
+/* marco 07nov16 [removed code not needed by pg_cron]
+ * marco 04sep16 [integrated into pg_cron]
+ * vix 26jan87 [RCS has the rest of the log]
  * vix 30dec86 [written]
  */
 
@@ -24,81 +26,10 @@
 #include <stdio.h>
 #include <time.h>
 #include <unistd.h>
-#include <sys/file.h>
-#include <sys/stat.h>
-#include <errno.h>
 #include <string.h>
-#include <fcntl.h>
-#include <grp.h>
-#ifdef WITH_AUDIT
-#include <libaudit.h>
-#endif
-#if defined(SYSLOG)
-# include <syslog.h>
-#endif
 #include "cron.h"
 
 
-#if defined(LOG_DAEMON) && !defined(LOG_CRON)
-#define LOG_CRON LOG_DAEMON
-#endif
-
-
-int
-strcmp_until(left, right, until)
-	char	*left;
-	char	*right;
-	int	until;
-{
-	register int	diff;
-
-	while (*left && *left != until && *left == *right) {
-		left++;
-		right++;
-	}
-
-	if ((*left=='\0' || *left == until) &&
-	    (*right=='\0' || *right == until)) {
-		diff = 0;
-	} else {
-		diff = *left - *right;
-	}
-
-	return diff;
-}
-
-
-/* strdtb(s) - delete trailing blanks in string 's' and return new length
- */
-int
-strdtb(s)
-	char	*s;
-{
-	char	*x = s;
-
-	/* scan forward to the null
-	 */
-	while (*x)
-		x++;
-
-	/* scan backward to either the first character before the string,
-	 * or the last non-blank in the string, whichever comes first.
-	 */
-	do	{x--;}
-	while (x >= s && isspace(*x));
-
-	/* one character beyond where we stopped above is where the null
-	 * goes.
-	 */
-	*++x = '\0';
-
-	/* the difference between the position of the null character and
-	 * the position of the first character of the string is the length.
-	 */
-	return x - s;
-}
-
-
 /* get_char(file) : like getc() but increment LineNumber on newlines
  */
 int
@@ -232,358 +163,3 @@ skip_comments(file)
 	if (ch != EOF)
 		unget_char(ch, file);
 }
-
-
-/* int in_file(char *string, FILE *file)
- *	return TRUE if one of the lines in file matches string exactly,
- *	FALSE otherwise.
- */
-static int
-in_file(string, file)
-	char *string;
-	FILE *file;
-{
-	char line[MAX_TEMPSTR];
-
-	rewind(file);
-	while (fgets(line, MAX_TEMPSTR, file)) {
-		if (line[0] != '\0')
-			line[strlen(line)-1] = '\0';
-		if (0 == strcmp(line, string))
-			return TRUE;
-	}
-	return FALSE;
-}
-
-
-/* int allowed(char *username)
- *	returns TRUE if (ALLOW_FILE exists and user is listed)
- *	or (DENY_FILE exists and user is NOT listed)
- *	or (neither file exists but user=="root" so it's okay)
- */
-int
-allowed(username)
-	char *username;
-{
-	static int	init = FALSE;
-	static FILE	*allow, *deny;
-	int     isallowed;
-
-        /* Root cannot be denied execution of cron jobs even if in the
-	 * 'DENY_FILE' so we return inmediately */
-        if (strcmp(username, ROOT_USER) == 0)
-                return (TRUE);
-
-	isallowed = FALSE;
-#if defined(ALLOW_ONLY_ROOT)
-	Debug(DMISC, "only root access is allowed")
-#else
-	if (!init) {
-		init = TRUE;
-#if defined(ALLOW_FILE) && defined(DENY_FILE)
-		allow = fopen(ALLOW_FILE, "r");
-		deny = fopen(DENY_FILE, "r");
-		Debug(DMISC, ("allow/deny enabled, %d/%d\n", !!allow, !!deny))
-#else
-		allow = NULL;
-		deny = NULL;
-#endif
-	}
-
-	if (allow) 
-		isallowed = in_file(username, allow);
-	else
-		isallowed = TRUE; /* Allow access if ALLOW_FILE does not exist */
-	if (deny && !allow)
-		isallowed = !in_file(username, deny);
-#endif
-
-#ifdef WITH_AUDIT
-       /* Log an audit message if the user is rejected */ 
-       if (isallowed == FALSE) {
-               int audit_fd = audit_open();
-               audit_log_user_message(audit_fd, AUDIT_USER_START, "cron deny",
-                       NULL, NULL, NULL, 0);
-               close(audit_fd);
-       }
-#endif
-	return isallowed;
-}
-
-
-void
-log_it(username, xpid, event, detail)
-	char	*username;
-	int	xpid;
-	char	*event;
-	char	*detail;
-{
-#if defined(LOG_FILE)
-	PID_T			pid = xpid;
-	char			*msg;
-	TIME_T			now = time((TIME_T) 0);
-	register struct tm	*t = localtime(&now);
-	int 			msg_size;
-#endif /*LOG_FILE*/
-
-
-#if defined(LOG_FILE)
-	/* we assume that MAX_TEMPSTR will hold the date, time, &punctuation.
-	 */
-	msg_size = strlen(username) + strlen(event) + strlen(detail) + MAX_TEMPSTR;
-	msg = malloc(msg_size);
-	if (msg == NULL) {
-	    /* damn, out of mem and we did not test that before... */
-	    fprintf(stderr, "%s: Run OUT OF MEMORY while %s\n",
-		    ProgramName, __FUNCTION__);
-	    return;
-	}
-	if (LogFD < OK) {
-		LogFD = open(LOG_FILE, O_WRONLY|O_APPEND|O_CREAT, 0600);
-		if (LogFD < OK) {
-			fprintf(stderr, "%s: %s: open: %s\n",
-				ProgramName, LOG_FILE, strerror(errno));
-		} else {
-			(void) fcntl(LogFD, F_SETFD, 1);
-		}
-	}
-
-	/* we have to snprintf() it because fprintf() doesn't always write
-	 * everything out in one chunk and this has to be atomically appended
-	 * to the log file.
-	 */
-	snprintf(msg, msg_size, "%s (%02d/%02d-%02d:%02d:%02d-%d) %s (%s)\n",
-		username,
-		t->tm_mon+1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec, pid,
-		event, detail);
-
-	/* we have to run strlen() because snprintf() returns (char*) on old BSD
-	 */
-	if (LogFD < OK || write(LogFD, msg, strlen(msg)) < OK) {
-		if (LogFD >= OK)
-			perror(LOG_FILE);
-		fprintf(stderr, "%s: can't write to log file\n", ProgramName);
-		write(STDERR, msg, strlen(msg));
-	}
-
-	free(msg);
-#endif /*LOG_FILE*/
-
-#if defined(SYSLOG)
-
-
-	    /* we don't use LOG_PID since the pid passed to us by
-	     * our client may not be our own.  therefore we want to
-	     * print the pid ourselves.
-	     */
-	    /* SteveG says: That comment is not consistent with the
-	       code, and makes no sense -- I suspect it's a remnant
-	       of a cut-n-paster... */
-# ifdef LOG_CRON
-	openlog(ProgramName, LOG_PID, LOG_CRON);
-# else
-	openlog(ProgramName, LOG_PID);
-# endif
-	  
-	syslog(LOG_INFO, "(%s) %s (%s)", username, event, detail);
-
-	closelog();
-#endif /*SYSLOG*/
-
-#if DEBUGGING
-	if (DebugFlags) {
-		fprintf(stderr, "log_it: (%s %d) %s (%s)\n",
-			username, xpid, event, detail);
-	}
-#endif
-}
-
-
-void
-log_close() {
-#if defined(LOG_FILE)
-	if (LogFD != ERR) {
-		close(LogFD);
-		LogFD = ERR;
-	}
-#endif
-#if defined(SYSLOG)
-	closelog();
-#endif
-}
-
-
-/* two warnings:
- *	(1) this routine is fairly slow
- *	(2) it returns a pointer to static storage
- */
-char *
-first_word(s, t)
-	register char *s;	/* string we want the first word of */
-	register char *t;	/* terminators, implicitly including \0 */
-{
-	static char retbuf[2][MAX_TEMPSTR + 1];	/* sure wish C had GC */
-	static int retsel = 0;
-	register char *rb, *rp;
-
-	/* select a return buffer */
-	retsel = 1-retsel;
-	rb = &retbuf[retsel][0];
-	rp = rb;
-
-	/* skip any leading terminators */
-	while (*s && (NULL != strchr(t, *s))) {
-		s++;
-	}
-
-	/* copy until next terminator or full buffer */
-	while (*s && (NULL == strchr(t, *s)) && (rp < &rb[MAX_TEMPSTR])) {
-		*rp++ = *s++;
-	}
-
-	/* finish the return-string and return it */
-	*rp = '\0';
-	return rb;
-}
-
-
-/* warning:
- *	heavily ascii-dependent.
- */
-static void
-mkprint(dst, src, len)
-	register char *dst;
-	register unsigned char *src;
-	register int len;
-{
-	while (len-- > 0)
-	{
-		register unsigned char ch = *src++;
-
-		if (ch < ' ') {			/* control character */
-			*dst++ = '^';
-			*dst++ = ch + '@';
-		} else if (ch < 0177) {		/* printable */
-			*dst++ = ch;
-		} else if (ch == 0177) {	/* delete/rubout */
-			*dst++ = '^';
-			*dst++ = '?';
-		} else {			/* parity character */
-		    /* well, the following snprintf is paranoid, but that will
-		     * keep grep happy */
-		    snprintf(dst, 5, "\\%03o", ch);
-		    dst += 4;
-		}
-	}
-	*dst = '\0';
-}
-
-
-/* warning:
- *	returns a pointer to malloc'd storage, you must call free yourself.
- */
-char *
-mkprints(src, len)
-	register unsigned char *src;
-	register unsigned int len;
-{
-	register char *dst = malloc(len*4 + 1);
-
-	if (dst)
-		mkprint(dst, src, len);
-
-	return dst;
-}
-
-
-#ifdef MAIL_DATE
-/* Sat, 27 Feb 1993 11:44:51 -0800 (CST)
- * 1234567890123456789012345678901234567
- */
-char *
-arpadate(clock)
-	time_t *clock;
-{
-	static char ret[64];	/* zone name might be >3 chars */
-	time_t t = clock ? *clock : time(NULL);
-	struct tm *tm = localtime(&t);
-	char *qmark;
-	size_t len;
-        long gmtoff = get_gmtoff(&t, tm);
-        int hours = gmtoff / 3600;
-        int minutes = (gmtoff - (hours * 3600)) / 60;
-
-	if (minutes < 0)
-		minutes = -minutes;
-
-	/* Defensive coding (almost) never hurts... */
-	len = strftime(ret, sizeof(ret), "%a, %e %b %Y %T ????? (%Z)", tm);
-	if (len == 0) {
-		ret[0] = '?';
-		ret[1] = '\0';
-		return ret;
-	}
-	qmark = strchr(ret, '?');
-	if (qmark && len - (qmark - ret) >= 6) {
-		snprintf(qmark, 6, "% .2d%.2d", hours, minutes);
-		qmark[5] = ' ';
-	}
-	return ret;
-}
-#endif /*MAIL_DATE*/
-
-
-#ifdef HAVE_SAVED_UIDS
-static uid_t save_euid, save_egid;
-int swap_uids()
-{
-	save_euid = geteuid(); save_egid = getegid();
-	return (setegid(getgid()) || seteuid(getuid())) ? -1 : 0;
-}
-int swap_uids_back()
-{
-	return (setegid(save_egid) || seteuid(save_euid)) ? -1 : 0;
-}
-#else /*HAVE_SAVED_UIDS*/
-int swap_uids()
-{
-	return (setregid(getegid(), getgid()) || setreuid(geteuid(), getuid()))
-		? -1 : 0;
-}
-int swap_uids_back() { return swap_uids(); }
-#endif /*HAVE_SAVED_UIDS*/
-
-
-/* Return the offset from GMT in seconds (algorithm taken from sendmail).
- *
- * warning:
- *	clobbers the static storage space used by localtime() and gmtime().
- *	If the local pointer is non-NULL it *must* point to a local copy.
- */
-#ifndef HAVE_TM_GMTOFF
-long get_gmtoff(time_t *clock, struct tm *local)
-{
-	struct tm gmt;
-	long offset;
-
-	gmt = *gmtime(clock);
-	if (local == NULL)
-		local = localtime(clock);
-
-	offset = (local->tm_sec - gmt.tm_sec) +
-	    ((local->tm_min - gmt.tm_min) * 60) +
-	    ((local->tm_hour - gmt.tm_hour) * 3600);
-
-	/* Timezone may cause year rollover to happen on a different day. */
-	if (local->tm_year < gmt.tm_year)
-		offset -= 24 * 3600;
-	else if (local->tm_year > gmt.tm_year)
-		offset += 24 * 3600;
-	else if (local->tm_yday < gmt.tm_yday)
-		offset -= 24 * 3600;
-	else if (local->tm_yday > gmt.tm_yday)
-		offset += 24 * 3600;
-
-	return (offset);
-}
-#endif /* HAVE_TM_GMTOFF */

COMMIT_HASH:288ca4d89919b221f0e4d43bb9d9045145f06d47|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-09-19 18:37:16 +0200|TITLE:Update .pgpass comment in readme.|MESSAGE:Fixes #5
diff --git a/README.md b/README.md
index 9bc7a00..cef1a7b 100644
--- a/README.md
+++ b/README.md
@@ -71,11 +71,11 @@ After restarting PostgreSQL, you can create the pg_cron functions and metadata t
 CREATE EXTENSION pg_cron;
 ```
 
-Internally, pg_cron uses libpq to open a new connection to the local database. It may be necessary to enable `trust` authentication for connections coming from localhost in [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html). Alternatively, you can create a [.pgpass file](https://www.postgresql.org/docs/current/static/libpq-pgpass.html) in the working directory of the database server.
+Internally, pg_cron uses libpq to open a new connection to the local database. It may be necessary to enable `trust` authentication for connections coming from localhost in [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html) for the user running the cron job. Alternatively, you can add the password to a [.pgpass file](https://www.postgresql.org/docs/current/static/libpq-pgpass.html), which libpq will use when opening a connection.
 
 ## Advanced usage
 
-Since pg_cron uses libpq, you can also run periodic jobs on other machines. This can be especially useful when you are using the [Citus extension](https://www.citusdata.com/product) to distribute tables across many PostgreSQL servers and need to run periodic jobs across all of them. 
+Since pg_cron uses libpq, you can also run periodic jobs on other machines. This can be especially useful when you are using the [Citus extension](https://www.citusdata.com/product) to distribute tables across many PostgreSQL servers and need to run periodic jobs across all of them.
 
 If you are superuser, then you can manually modify the cron.job table and use custom values for nodename and nodeport to connect to a different machine:
 

COMMIT_HASH:51d3b6de00f7edf78d7dc0d9f4c530be557849a4|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-11 15:16:10 +0200|TITLE:Fix URL in META.json|MESSAGE:
diff --git a/META.json b/META.json
index dce89e0..31d3e85 100644
--- a/META.json
+++ b/META.json
@@ -1,6 +1,6 @@
 {
     "name": "pg_cron",
-    "abstract": "Periodic background job scheduler for PostgreSQL",
+    "abstract": "Periodic job scheduler for PostgreSQL",
     "description": "Sets up a background worker that periodically runs queries in the background",
     "version": "0.1",
     "maintainer": "\"Marco Slot\" <marco@citusdata.com>",
@@ -26,12 +26,12 @@
     "resources": {
         "homepage": "https://citusdata.com/",
         "bugtracker": {
-            "web": "https://github.com/marcocitus/pg_cron/issues",
+            "web": "https://github.com/citusdata/pg_cron/issues",
             "mailto": "support@citusdata.com"
         },
         "repository": {
-          "url":  "git://github.com/marcocitus/pg_cron.git",
-          "web":  "https://github.com/marcocitus/pg_cron",
+          "url":  "git://github.com/citusdata/pg_cron.git",
+          "web":  "https://github.com/citusdata/pg_cron",
           "type": "git"
         }
     },
@@ -39,7 +39,7 @@
     "generated_by": "\"Marco Slot\" <marco@citusdata.com>",
 
     "tags": [
-        "cluster"
+        "cron", "background worker"
     ],
 
     "meta-spec": {

COMMIT_HASH:ab8a3768db31e409e9ce695538f3cb1111adea5f|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-11 15:12:35 +0200|TITLE:Make sure manually inserted, unparsable schedules are set to 0|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 82c2a1d..f60a2eb 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -658,6 +658,9 @@ TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
 	else
 	{
 		elog(LOG, "invalid pg_cron schedule for job %ld: %s", jobId, job->scheduleText);
+
+		/* a zeroed out schedule never runs */
+		memset(&job->schedule, 0, sizeof(entry));
 	}
 
 	return job;

COMMIT_HASH:1285b07490c4bfa243f22e1bbb06a62d8caaa901|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-10 11:49:15 +0200|TITLE:Verify cron.database_name setting during extension creation|MESSAGE:
diff --git a/sql/pg_cron.sql b/sql/pg_cron.sql
index 11120d3..b5db37a 100644
--- a/sql/pg_cron.sql
+++ b/sql/pg_cron.sql
@@ -1,3 +1,17 @@
+DO $$
+BEGIN
+   IF current_database() <> current_setting('cron.database_name') THEN
+      RAISE EXCEPTION 'can only create extension in database %',
+                      current_setting('cron.database_name')
+      USING DETAIL = 'Jobs must be scheduled from the database configured in '||
+                     'cron.database_name, since the pg_cron background worker '||
+                     'reads job descriptions from this database.',
+            HINT = format('Add cron.database_name = ''%s'' in postgresql.conf '||
+                          'to use the current database.', current_database());
+   END IF;
+END;
+$$;
+
 CREATE SCHEMA cron;
 GRANT USAGE ON SCHEMA cron TO public;
 

COMMIT_HASH:eee4f716f99e869b337a9213310055cc8e2ea3cd|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-09 14:39:56 +0200|TITLE:Make @reboot schedules work|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index e399fba..82c2a1d 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -118,6 +118,7 @@ static HTAB *CronJobHash = NULL;
 static HTAB *CronTaskHash = NULL;
 static bool CronJobCacheValid = false;
 static Oid CachedCronJobRelationId = InvalidOid;
+static bool RebootJobsScheduled = false;
 static int64 RunCount = 0;
 
 static char *CronTableDatabaseName = "postgres";
@@ -710,6 +711,24 @@ StartAllPendingRuns(List *taskList, TimestampTz currentTime)
 	ListCell *taskCell = NULL;
 	ClockProgress clockProgress;
 
+	if (!RebootJobsScheduled)
+	{
+		/* find jobs with @reboot as a schedule */
+		foreach(taskCell, taskList)
+		{
+			CronTask *task = (CronTask *) lfirst(taskCell);
+			CronJob *cronJob = GetCronJob(task->jobId);
+			entry *schedule = &cronJob->schedule;
+
+			if (schedule->flags & WHEN_REBOOT)
+			{
+				task->pendingRunCount += 1;
+			}
+		}
+
+		RebootJobsScheduled = true;
+	}
+
 	if (lastMinute == 0)
 	{
 		lastMinute = TimestampMinuteStart(currentTime);
@@ -769,7 +788,6 @@ StartAllPendingRuns(List *taskList, TimestampTz currentTime)
 }
 
 
-
 /*
  * StartPendingRuns kicks off pending runs for a task if it
  * should start, taking clock changes into consideration.

COMMIT_HASH:8c37bfa82f3f871d9aee75a4f317ea9990e820b7|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-09 01:01:54 +0200|TITLE:Make pendingRunCount unsigned|MESSAGE:
diff --git a/include/pg_cron.h b/include/pg_cron.h
index f2d299a..8962e48 100644
--- a/include/pg_cron.h
+++ b/include/pg_cron.h
@@ -52,7 +52,7 @@ typedef struct CronTask
 	int64 jobId;
 	int64 runId;
 	CronTaskState state;
-	int pendingRunCount;
+	uint pendingRunCount;
 	PGconn *connection;
 	PostgresPollingStatusType pollingStatus;
 	TimestampTz startDeadline;

COMMIT_HASH:0eddc323e35f71afec585f3fd0126463ee94d2a5|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-08 17:48:56 +0200|TITLE:Remove some unused cron code that was causing compile errors|MESSAGE:Fixes #3

diff --git a/include/cron.h b/include/cron.h
index 38ff136..70d0e0a 100644
--- a/include/cron.h
+++ b/include/cron.h
@@ -231,19 +231,8 @@ typedef struct _file_buffer {
 	int			unget_count;
 } file_buffer;
 
-void		set_cron_uid __P((void)),
-		set_cron_cwd __P((void)),
-		load_database __P((cron_db *)),
-		open_logfile __P((void)),
-		sigpipe_func __P((void)),
-		job_add __P((entry *, user *)),
-		do_command __P((entry *, user *)),
-		link_user __P((cron_db *, user *)),
-		unlink_user __P((cron_db *, user *)),
-		free_user __P((user *)),
-		unget_char __P((int, FILE *)),
+void	unget_char __P((int, FILE *)),
 		free_entry __P((entry *)),
-		acquire_daemonlock __P((int)),
 		skip_comments __P((FILE *)),
 		log_it __P((char *, int, char *, char *)),
 		log_close __P((void)),
diff --git a/src/misc.c b/src/misc.c
index ee4025f..b5a4baa 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -99,233 +99,6 @@ strdtb(s)
 }
 
 
-int
-set_debug_flags(flags)
-	char	*flags;
-{
-	/* debug flags are of the form    flag[,flag ...]
-	 *
-	 * if an error occurs, print a message to stdout and return FALSE.
-	 * otherwise return TRUE after setting ERROR_FLAGS.
-	 */
-
-#if !DEBUGGING
-
-	printf("this program was compiled without debugging enabled\n");
-	return FALSE;
-
-#else /* DEBUGGING */
-
-	char	*pc = flags;
-
-	DebugFlags = 0;
-
-	while (*pc) {
-		char	**test;
-		int	mask;
-
-		/* try to find debug flag name in our list.
-		 */
-		for (	test = DebugFlagNames, mask = 1;
-			*test && strcmp_until(*test, pc, ',');
-			test++, mask <<= 1
-		    )
-			;
-
-		if (!*test) {
-			fprintf(stderr,
-				"unrecognized debug flag <%s> <%s>\n",
-				flags, pc);
-			return FALSE;
-		}
-
-		DebugFlags |= mask;
-
-		/* skip to the next flag
-		 */
-		while (*pc && *pc != ',')
-			pc++;
-		if (*pc == ',')
-			pc++;
-	}
-
-	if (DebugFlags) {
-		int	flag;
-
-		fprintf(stderr, "debug flags enabled:");
-
-		for (flag = 0;  DebugFlagNames[flag];  flag++)
-			if (DebugFlags & (1 << flag))
-				fprintf(stderr, " %s", DebugFlagNames[flag]);
-		fprintf(stderr, "\n");
-	}
-
-	return TRUE;
-
-#endif /* DEBUGGING */
-}
-
-
-void
-set_cron_uid()
-{
-#if defined(BSD) || defined(POSIX)
-	if (seteuid(ROOT_UID) < OK) {
-		perror("seteuid");
-		exit(ERROR_EXIT);
-	}
-#else
-	if (setuid(ROOT_UID) < OK) {
-		perror("setuid");
-		exit(ERROR_EXIT);
-	}
-#endif
-}
-
-
-void
-set_cron_cwd()
-{
-	struct stat	sb;
-	mode_t		um;
-	struct group	*gr;
-	
-	/* first check for CRONDIR ("/var/cron" or some such)
-	 */
-	if (stat(CRONDIR, &sb) < OK && errno == ENOENT) {
-		perror(CRONDIR);
-
-		/* crontab(1) running SGID crontab shouldn't attempt to create
-		 * directories */
-		if (getuid() != 0 )
-			exit(ERROR_EXIT);
-
-		um = umask(000);
-		if (OK == mkdir(CRONDIR, CRONDIR_MODE)) {
-			fprintf(stderr, "%s: created\n", CRONDIR);
-			stat(CRONDIR, &sb);
-		} else {
-			fprintf(stderr, "%s: mkdir: %s\n", CRONDIR,
-				strerror(errno));
-			exit(ERROR_EXIT);
-		}
-		(void) umask(um);
-	}
-	if (!(sb.st_mode & S_IFDIR)) {
-		fprintf(stderr, "'%s' is not a directory, bailing out.\n",
-			CRONDIR);
-		exit(ERROR_EXIT);
-	}
-	if (chdir(CRONDIR) < OK) {
-		fprintf(stderr, "%s: chdir: %s\n", CRONDIR, strerror(errno));
-		exit(ERROR_EXIT);
-	}
-
-	/* CRONDIR okay (now==CWD), now look at SPOOL_DIR ("tabs" or some such)
-	 */
-	if (stat(SPOOL_DIR, &sb) < OK && errno == ENOENT) {
-		perror(SPOOL_DIR);
-
-		/* crontab(1) running SGID crontab shouldn't attempt to create
-		 * directories */
-		if (getuid() != 0 )
-			exit(ERROR_EXIT);
-
-		um = umask(000);
-		if (OK == mkdir(SPOOL_DIR, SPOOL_DIR_MODE)) {
-			fprintf(stderr, "%s: created\n", SPOOL_DIR);
-		} else {
-			fprintf(stderr, "%s: mkdir: %s\n", SPOOL_DIR,
-				strerror(errno));
-			exit(ERROR_EXIT);
-		}
-		(void) umask(um);
-
-		if (!(gr = getgrnam(SPOOL_DIR_GROUP))) {
-			fprintf(stderr, "%s: getgrnam: %s\n", SPOOL_DIR,
-				strerror(errno));
-			exit(ERROR_EXIT);
-		}
-		if (OK == chown(SPOOL_DIR, -1, gr->gr_gid)) {
-			fprintf(stderr, "%s: chowned\n", SPOOL_DIR);
-				stat(SPOOL_DIR, &sb);
-		} else {
-			fprintf(stderr, "%s: chown: %s\n", SPOOL_DIR,
-			strerror(errno));
-			exit(ERROR_EXIT);
-		}
-	}
-	if (!(sb.st_mode & S_IFDIR)) {
-		fprintf(stderr, "'%s' is not a directory, bailing out.\n",
-			SPOOL_DIR);
-		exit(ERROR_EXIT);
-	}
-}
-
-
-/* acquire_daemonlock() - write our PID into /etc/crond.pid, unless
- *	another daemon is already running, which we detect here.
- *
- * note: main() calls us twice; once before forking, once after.
- *	we maintain static storage of the file pointer so that we
- *	can rewrite our PID into the PIDFILE after the fork.
- *
- * it would be great if fflush() disassociated the file buffer.
- */
-void
-acquire_daemonlock(closeflag)
-	int closeflag;
-{
-	static	FILE	*fp = NULL;
-
-	if (closeflag && fp) {
-		fclose(fp);
-		fp = NULL;
-		return;
-	}
-
-	if (!fp) {
-		char	pidfile[MAX_FNAME];
-		char	buf[MAX_TEMPSTR];
-		int	fd, otherpid;
-
-		(void) snprintf(pidfile, MAX_FNAME, PIDFILE, PIDDIR);
-		if ((-1 == (fd = open(pidfile, O_RDWR|O_CREAT, 0644)))
-		    || (NULL == (fp = fdopen(fd, "r+")))
-		    ) {
-			snprintf(buf, MAX_TEMPSTR, "can't open or create %s: %s",
-				pidfile, strerror(errno));
-			fprintf(stderr, "%s: %s\n", ProgramName, buf);
-			log_it("CRON", getpid(), "DEATH", buf);
-			exit(ERROR_EXIT);
-		}
-
-		if (flock(fd, LOCK_EX|LOCK_NB) < OK) {
-			int save_errno = errno;
-
-			fscanf(fp, "%d", &otherpid);
-			snprintf(buf, MAX_TEMPSTR, "can't lock %s, otherpid may be %d: %s",
-				pidfile, otherpid, strerror(save_errno));
-			fprintf(stderr, "%s: %s\n", ProgramName, buf);
-			log_it("CRON", getpid(), "DEATH", buf);
-			exit(ERROR_EXIT);
-		}
-		snprintf(buf, MAX_TEMPSTR, "pidfile fd = %d", fd);
-		log_it("CRON", getpid(), "INFO", buf);
-		(void) fcntl(fd, F_SETFD, 1);
-	}
-
-	rewind(fp);
-	fprintf(fp, "%d\n", getpid());
-	fflush(fp);
-	(void) ftruncate(fileno(fp), ftell(fp));
-
-	/* abandon fd and fp even though the file is open. we need to
-	 * keep it open and locked, but we don't need the handles elsewhere.
-	 */
-	
-}
-
 /* get_char(file) : like getc() but increment LineNumber on newlines
  */
 int

COMMIT_HASH:3384dce612aff596a1a879d060dd1dfdf473c610|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-09-07 15:51:33 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index fd628ba..9bc7a00 100644
--- a/README.md
+++ b/README.md
@@ -44,7 +44,7 @@ The schedule uses the standard cron syntax, in which * means "run every time per
 
 An easy way to create a cron schedule is: [crontab.guru](http://crontab.guru/).
 
-The code in pg_cron that handles parsing and scheduling comes directly from the cron source code by Paul Vixie (@vixie), hence the same options are supported.
+The code in pg_cron that handles parsing and scheduling comes directly from the cron source code by Paul Vixie, hence the same options are supported.
 
 ## Setting up pg_cron
 

COMMIT_HASH:3f8554ca8be030766f65fce5cf3367cb83c6ba44|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-09-07 15:50:35 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 6ebacf6..fd628ba 100644
--- a/README.md
+++ b/README.md
@@ -44,6 +44,8 @@ The schedule uses the standard cron syntax, in which * means "run every time per
 
 An easy way to create a cron schedule is: [crontab.guru](http://crontab.guru/).
 
+The code in pg_cron that handles parsing and scheduling comes directly from the cron source code by Paul Vixie (@vixie), hence the same options are supported.
+
 ## Setting up pg_cron
 
 You can install pg_cron by building it from source:

COMMIT_HASH:1d6db3a511e4db923c2cf31d6dbc88a32fa47604|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-09-07 15:42:47 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 998b3ed..6ebacf6 100644
--- a/README.md
+++ b/README.md
@@ -4,7 +4,7 @@
 
 ## What is pg_cron?
 
-pg_cron is a simple cron-based job scheduler for PostgreSQL runs inside the database. It uses the same syntax as regular cron, but it allows you to schedule PostgreSQL commands directly from the database:
+pg_cron is a simple cron-based job scheduler for PostgreSQL that runs inside the database as an extension. It uses the same syntax as regular cron, but it allows you to schedule PostgreSQL commands directly from the database:
 
 ```sql
 -- Delete old data on Saturday at 3:30am (GMT)

COMMIT_HASH:bd546e8579060cd4d6655254ac5ca5fc7a6fd7e7|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-09-07 15:24:55 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 9b47ccc..998b3ed 100644
--- a/README.md
+++ b/README.md
@@ -4,7 +4,7 @@
 
 ## What is pg_cron?
 
-pg_cron is a simple cron-based job scheduler for PostgreSQL runs inside the database. It uses the same syntax and much of the same code as regular cron, but it allows you to schedule PostgreSQL commands directly from the database:
+pg_cron is a simple cron-based job scheduler for PostgreSQL runs inside the database. It uses the same syntax as regular cron, but it allows you to schedule PostgreSQL commands directly from the database:
 
 ```sql
 -- Delete old data on Saturday at 3:30am (GMT)

COMMIT_HASH:7d17584c96a474f6223d5bbfb5918648d1c74306|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-09-07 15:21:43 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 6449169..9b47ccc 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,10 @@
-# pg_cron
+[![Citus Banner](/github-banner.png)](https://www.citusdata.com/)
 
-pg_cron is a simple periodic job scheduler for PostgreSQL based on cron. It uses the same syntax as regular cron, but allows you to run PostgreSQL commands directly from the database:
+[![Slack Status](http://slack.citusdata.com/badge.svg)](https://slack.citusdata.com)
+
+## What is pg_cron?
+
+pg_cron is a simple cron-based job scheduler for PostgreSQL runs inside the database. It uses the same syntax and much of the same code as regular cron, but it allows you to schedule PostgreSQL commands directly from the database:
 
 ```sql
 -- Delete old data on Saturday at 3:30am (GMT)
@@ -40,7 +44,7 @@ The schedule uses the standard cron syntax, in which * means "run every time per
 
 An easy way to create a cron schedule is: [crontab.guru](http://crontab.guru/).
 
-# Set-up
+## Setting up pg_cron
 
 You can install pg_cron by building it from source:
 
@@ -67,7 +71,7 @@ CREATE EXTENSION pg_cron;
 
 Internally, pg_cron uses libpq to open a new connection to the local database. It may be necessary to enable `trust` authentication for connections coming from localhost in [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html). Alternatively, you can create a [.pgpass file](https://www.postgresql.org/docs/current/static/libpq-pgpass.html) in the working directory of the database server.
 
-# Advanced usage
+## Advanced usage
 
 Since pg_cron uses libpq, you can also run periodic jobs on other machines. This can be especially useful when you are using the [Citus extension](https://www.citusdata.com/product) to distribute tables across many PostgreSQL servers and need to run periodic jobs across all of them. 
 

COMMIT_HASH:ebbf355526f2eaacb7e0d6dc35dc324444c9c1bb|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-07 15:13:23 +0200|TITLE:Add Citus Data banner|MESSAGE:
diff --git a/github-banner.png b/github-banner.png
new file mode 100644
index 0000000..d7818f3
Binary files /dev/null and b/github-banner.png differ

COMMIT_HASH:32fc8de55012527e1f65071d2e9e94154435a860|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-06 23:42:13 +0200|TITLE:Remove unused cron.result table|MESSAGE:
diff --git a/sql/pg_cron.sql b/sql/pg_cron.sql
index 6545295..11120d3 100644
--- a/sql/pg_cron.sql
+++ b/sql/pg_cron.sql
@@ -17,15 +17,6 @@ GRANT SELECT ON cron.job TO public;
 ALTER TABLE cron.job ENABLE ROW LEVEL SECURITY;
 CREATE POLICY cron_job_policy ON cron.job USING (username = current_user);
 
-CREATE TABLE cron.result (
-	runid bigint,
-	jobid bigint not null,
-	starttime timestamptz,
-	endtime timestamptz,
-	status int not null,
-	output text
-);
-
 CREATE FUNCTION cron.schedule(schedule text, command text)
     RETURNS bigint
     LANGUAGE C STRICT

COMMIT_HASH:b002fd389b7f324573d4a9b1ba5b72524b003397|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-06 23:02:03 +0200|TITLE:Check whether the user has permission to unschedule|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 31cc1e1..e399fba 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -364,7 +364,13 @@ cron_unschedule(PG_FUNCTION_ARGS)
 	ScanKeyData scanKey[1];
 	int scanKeyCount = 1;
 	bool indexOK = true;
+	TupleDesc tupleDescriptor = NULL;
 	HeapTuple heapTuple = NULL;
+	bool isNull = false;
+	Oid userId = InvalidOid;
+	char *userName = NULL;
+	Datum ownerNameDatum = 0;
+	char *ownerName = NULL;
 
 	cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
 	cronJobIndexId = get_relname_relid(JOB_ID_INDEX_NAME, cronSchemaId);
@@ -378,6 +384,8 @@ cron_unschedule(PG_FUNCTION_ARGS)
 										cronJobIndexId, indexOK,
 										NULL, scanKeyCount, scanKey);
 
+	tupleDescriptor = RelationGetDescr(cronJobsTable);
+
 	heapTuple = systable_getnext(scanDescriptor);
 	if (!HeapTupleIsValid(heapTuple))
 	{
@@ -385,6 +393,25 @@ cron_unschedule(PG_FUNCTION_ARGS)
 							   UINT64_FORMAT, jobId)));
 	}
 
+	/* check if the current user owns the row */
+	userId = GetUserId();
+	userName = GetUserNameFromId(userId, false);
+
+	ownerNameDatum = heap_getattr(heapTuple, Anum_cron_job_username,
+								  tupleDescriptor, &isNull);
+	ownerName = TextDatumGetCString(ownerNameDatum);
+	if (pg_strcasecmp(userName, ownerName) != 0)
+	{
+		/* otherwise, allow if the user has DELETE permission */
+		AclResult aclResult = pg_class_aclcheck(CronJobRelationId(), GetUserId(),
+												ACL_DELETE);
+		if (aclResult != ACLCHECK_OK)
+		{
+			aclcheck_error(aclResult, ACL_KIND_CLASS,
+						   get_rel_name(CronJobRelationId()));
+		}
+	}
+
 	simple_heap_delete(cronJobsTable, &heapTuple->t_self);
 	CommandCounterIncrement();
 

COMMIT_HASH:55245f9e88a4e7b17efb69baf7fc6cd2e41ceaa3|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-06 13:28:00 +0200|TITLE:Add license file|MESSAGE:
diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..9b07ceb
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,7 @@
+Copyright (c) 2015, Citus Data
+
+Permission to use, copy, modify, and distribute this software and its documentation for any purpose, without fee, and without a written agreement is hereby granted, provided that the above copyright notice and this paragraph and the following two paragraphs appear in all copies.
+
+IN NO EVENT SHALL CITUS DATA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF CITUS DATA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+CITUS DATA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND CITUS DATA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

COMMIT_HASH:e24a5f7afcf6f9a58afdf5058fb9e361953ffd73|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-09-06 10:33:54 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index 9472944..6449169 100644
--- a/README.md
+++ b/README.md
@@ -53,7 +53,7 @@ sudo PATH=/usr/local/pgsql/bin/:$PATH make install
 
 To start the pg_cron background worker when PostgreSQL starts, you need to add pg_cron to `shared_preload_libraries` in postgresql.conf and restart PostgreSQL. Note that pg_cron does not run any jobs as a long a server is in [hot standby](https://www.postgresql.org/docs/current/static/hot-standby.html) mode, but it automatically starts when the server is promoted.
 
-``
+```
 # add to postgresql.conf:
 shared_preload_libraries = 'pg_cron'
 ```

COMMIT_HASH:4f786dbef408f737a7692e96be2fde57a7aa1484|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-06 10:28:10 +0200|TITLE:Clarify set-up section in README|MESSAGE:
diff --git a/README.md b/README.md
index 118ce94..9472944 100644
--- a/README.md
+++ b/README.md
@@ -51,22 +51,19 @@ PATH=/usr/local/pgsql/bin/:$PATH make
 sudo PATH=/usr/local/pgsql/bin/:$PATH make install
 ```
 
-After installing pg_cron, you can add it to your database using `CREATE EXTENSION pg_cron`. By default, pg_cron expects its metadata tables to be in the "postgres" database. However, you can configure this using the `cron.database_name` configuration parameter.
+To start the pg_cron background worker when PostgreSQL starts, you need to add pg_cron to `shared_preload_libraries` in postgresql.conf and restart PostgreSQL. Note that pg_cron does not run any jobs as a long a server is in [hot standby](https://www.postgresql.org/docs/current/static/hot-standby.html) mode, but it automatically starts when the server is promoted.
 
-```sql
--- run using psql:
-CREATE EXTENSION pg_cron;
-```
- 
-To start the pg_cron background worker when PostgreSQL starts, add it to shared_preload_libraries in postgresql.conf and restart PostgreSQL:
-
-```
+``
 # add to postgresql.conf:
 shared_preload_libraries = 'pg_cron'
-cron.database_name = 'postgres'
 ```
 
-Note that pg_cron does not run any jobs as a long a server is in [hot standby](https://www.postgresql.org/docs/current/static/hot-standby.html) mode, but if pg_cron is in `shared_preload_libraries` then it automatically starts when the server is promoted.
+After restarting PostgreSQL, you can create the pg_cron functions and metadata tables using `CREATE EXTENSION pg_cron`. By default, the pg_cron background worker expects its metadata tables to be created in the "postgres" database. However, you can configure this by setting the `cron.database_name` configuration parameter in postgresql.conf.
+
+```sql
+-- run using psql:
+CREATE EXTENSION pg_cron;
+```
 
 Internally, pg_cron uses libpq to open a new connection to the local database. It may be necessary to enable `trust` authentication for connections coming from localhost in [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html). Alternatively, you can create a [.pgpass file](https://www.postgresql.org/docs/current/static/libpq-pgpass.html) in the working directory of the database server.
 
@@ -77,8 +74,8 @@ Since pg_cron uses libpq, you can also run periodic jobs on other machines. This
 If you are superuser, then you can manually modify the cron.job table and use custom values for nodename and nodeport to connect to a different machine:
 
 ```sql
-INSERT INTO cron.job (schedule, command, nodename, nodeport, username) 
-VALUES ('0 4 * * *', 'VACUUM', 'worker-node-1', 5432, 'marco');
+INSERT INTO cron.job (schedule, command, nodename, nodeport, database, username)
+VALUES ('0 4 * * *', 'VACUUM', 'worker-node-1', 5432, 'postgres', 'marco');
 ```
 
 You can use [.pgpass](https://www.postgresql.org/docs/current/static/libpq-pgpass.html) to allow pg_cron to authenticate with the remote server.

COMMIT_HASH:cd80a44538ceff0e4233c7a132f6392b91a24e9b|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-06 10:27:28 +0200|TITLE:Specify a default jobid for manual inserts into cron.job|MESSAGE:
diff --git a/sql/pg_cron.sql b/sql/pg_cron.sql
index b603e49..6545295 100644
--- a/sql/pg_cron.sql
+++ b/sql/pg_cron.sql
@@ -5,7 +5,7 @@ CREATE SEQUENCE cron.jobid_seq;
 GRANT USAGE ON SEQUENCE cron.jobid_seq TO public;
 
 CREATE TABLE cron.job (
-	jobid bigint primary key,
+	jobid bigint primary key default nextval('cron.jobid_seq'),
 	schedule text not null,
 	command text not null,
 	nodename text not null default 'localhost',

COMMIT_HASH:2110573cec31fd12a552bacc9a6cfc0e57f5fb1d|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-06 10:18:08 +0200|TITLE:Have a break|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index 6eeb3cc..31cc1e1 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -1168,6 +1168,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 				/* remove task as well */
 				bool isPresent = false;
 				hash_search(CronTaskHash, &jobId, HASH_REMOVE, &isPresent);
+				break;
 			}
 
 			/* check whether runs are pending */

COMMIT_HASH:c231d095dfc9945c04acd37a977bbdfb072535a1|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-05 23:18:38 +0200|TITLE:Improve error handling on connection failure|MESSAGE:
diff --git a/src/pg_cron.c b/src/pg_cron.c
index aaff758..6eeb3cc 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -1018,12 +1018,10 @@ PollForTasks(List *taskList)
 		PostgresPollingStatusType pollingStatus = task->pollingStatus;
 		struct pollfd *pollFileDescriptor = &pollFDs[taskIndex];
 
-		if (task->state == CRON_TASK_WAITING &&
-			task->pendingRunCount > 0)
+		if ((task->state == CRON_TASK_WAITING && task->pendingRunCount > 0) ||
+			task->state == CRON_TASK_ERROR || task->state == CRON_TASK_DONE)
 		{
-			/*
-			 * We have a task that can start, don't wait.
-			 */
+			/* there is work to be done, don't wait */
 			pfree(pollFDs);
 			return;
 		}
@@ -1087,7 +1085,12 @@ PollForTasks(List *taskList)
 	TimestampDifference(currentTime, nextEventTime, &waitSeconds, &waitMicros);
 
 	pollTimeout = waitSeconds * 1000 + waitMicros / 1000;
-	if (pollTimeout > MaxWait)
+	if (pollTimeout <= 0)
+	{
+		pfree(pollFDs);
+		return;
+	}
+	else if (pollTimeout > MaxWait)
 	{
 		/*
 		 * We never wait more than 1 second, this gives us a chance to react
@@ -1212,7 +1215,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			connectionStatus = PQstatus(connection);
 			if (connectionStatus == CONNECTION_BAD)
 			{
-				task->errorMessage = PQerrorMessage(connection);
+				task->errorMessage = "connection failed";
 				task->pollingStatus = 0;
 				task->state = CRON_TASK_ERROR;
 				break;
@@ -1255,7 +1258,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			connectionStatus = PQstatus(connection);
 			if (connectionStatus == CONNECTION_BAD)
 			{
-				task->errorMessage = PQerrorMessage(connection);
+				task->errorMessage = "connection failed";
 				task->pollingStatus = 0;
 				task->state = CRON_TASK_ERROR;
 				break;
@@ -1278,7 +1281,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			}
 			else if (pollingStatus == PGRES_POLLING_FAILED)
 			{
-				task->errorMessage = PQerrorMessage(connection);
+				task->errorMessage = "connection failed";
 				task->pollingStatus = 0;
 				task->state = CRON_TASK_ERROR;
 			}
@@ -1330,7 +1333,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			connectionStatus = PQstatus(connection);
 			if (connectionStatus == CONNECTION_BAD)
 			{
-				task->errorMessage = PQerrorMessage(connection);
+				task->errorMessage = "connection lost";
 				task->pollingStatus = 0;
 				task->state = CRON_TASK_ERROR;
 				break;
@@ -1372,7 +1375,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 			connectionStatus = PQstatus(connection);
 			if (connectionStatus == CONNECTION_BAD)
 			{
-				task->errorMessage = PQerrorMessage(connection);
+				task->errorMessage = "connection lost";
 				task->pollingStatus = 0;
 				task->state = CRON_TASK_ERROR;
 				break;
@@ -1415,6 +1418,9 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 						task->errorMessage = PQresultErrorMessage(result);
 						task->pollingStatus = 0;
 						task->state = CRON_TASK_ERROR;
+
+						PQclear(result);
+
 						return;
 					}
 
@@ -1426,6 +1432,9 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 						task->errorMessage = "COPY not supported";
 						task->pollingStatus = 0;
 						task->state = CRON_TASK_ERROR;
+
+						PQclear(result);
+
 						return;
 					}
 
@@ -1468,7 +1477,7 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 
 			if (task->errorMessage != NULL)
 			{
-				elog(LOG, "error running job %ld: %s", jobId, task->errorMessage);
+				elog(LOG, "pg_cron job %ld: %s", jobId, task->errorMessage);
 			}
 
 			task->startDeadline = 0;

COMMIT_HASH:ec55b7bba7b2d88d3732278f788e79c311d6f907|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco.slot@gmail.com|DATE:2016-09-05 09:16:17 +0200|TITLE:Fix compile errors on Linux|MESSAGE:
diff --git a/include/cron.h b/include/cron.h
index 8d5175e..38ff136 100644
--- a/include/cron.h
+++ b/include/cron.h
@@ -319,7 +319,7 @@ time_t	StartTime;
 time_min timeRunning;
 time_min virtualTime;
 time_min clockTime;
-static long GMToff;
+long GMToff;
 
 int	stay_foreground;
 int     lsbsysinit_mode;
diff --git a/src/pg_cron.c b/src/pg_cron.c
index a050f32..aaff758 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -357,7 +357,6 @@ cron_unschedule(PG_FUNCTION_ARGS)
 	int64 jobId = PG_GETARG_INT64(0);
 
 	Oid cronSchemaId = InvalidOid;
-	Oid cronJobsRelationId = InvalidOid;
 	Oid cronJobIndexId = InvalidOid;
 
 	Relation cronJobsTable = NULL;
@@ -367,9 +366,7 @@ cron_unschedule(PG_FUNCTION_ARGS)
 	bool indexOK = true;
 	HeapTuple heapTuple = NULL;
 
-
 	cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
-	cronJobsRelationId = get_relname_relid(JOBS_TABLE_NAME, cronSchemaId);
 	cronJobIndexId = get_relname_relid(JOB_ID_INDEX_NAME, cronSchemaId);
 
 	cronJobsTable = heap_open(CronJobRelationId(), RowExclusiveLock);

COMMIT_HASH:c29d2ed9289fcdce4d6bf8c866d45739e77fe84a|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-09-04 12:08:32 +0200|TITLE:Update README.md|MESSAGE:
diff --git a/README.md b/README.md
index a502c58..118ce94 100644
--- a/README.md
+++ b/README.md
@@ -1,2 +1,84 @@
 # pg_cron
-Run periodic jobs in PostgreSQL
+
+pg_cron is a simple periodic job scheduler for PostgreSQL based on cron. It uses the same syntax as regular cron, but allows you to run PostgreSQL commands directly from the database:
+
+```sql
+-- Delete old data on Saturday at 3:30am (GMT)
+SELECT cron.schedule('30 3 * * 6', $$DELETE FROM events WHERE event_time < now() - interval '1 week'$$);
+ schedule
+----------
+       42
+
+-- Vacuum every day at 10:00am (GMT)
+SELECT cron.schedule('0 10 * * *', 'VACUUM');
+ schedule
+----------
+       43
+    
+-- Stop scheduling a job
+SELECT cron.unschedule(43);
+ unschedule
+------------
+          t
+```
+
+pg_cron can run multiple jobs in parallel, but it runs at most one instance of a job at a time. If a second run is supposed to start before the first one finishes, then the second run is queued and started as soon as the first run completes.
+
+The schedule uses the standard cron syntax, in which * means "run every time period", and a specific number means "but only at this time":
+
+```
+ ┌───────────── min (0 - 59)
+ │ ┌────────────── hour (0 - 23)
+ │ │ ┌─────────────── day of month (1 - 31)
+ │ │ │ ┌──────────────── month (1 - 12)
+ │ │ │ │ ┌───────────────── day of week (0 - 6) (0 to 6 are Sunday to
+ │ │ │ │ │                  Saturday, or use names; 7 is also Sunday)
+ │ │ │ │ │
+ │ │ │ │ │
+ * * * * * 
+```
+
+An easy way to create a cron schedule is: [crontab.guru](http://crontab.guru/).
+
+# Set-up
+
+You can install pg_cron by building it from source:
+
+```bash
+git clone https://github.com/citusdata/pg_cron.git
+cd pg_cron
+PATH=/usr/local/pgsql/bin/:$PATH make
+sudo PATH=/usr/local/pgsql/bin/:$PATH make install
+```
+
+After installing pg_cron, you can add it to your database using `CREATE EXTENSION pg_cron`. By default, pg_cron expects its metadata tables to be in the "postgres" database. However, you can configure this using the `cron.database_name` configuration parameter.
+
+```sql
+-- run using psql:
+CREATE EXTENSION pg_cron;
+```
+ 
+To start the pg_cron background worker when PostgreSQL starts, add it to shared_preload_libraries in postgresql.conf and restart PostgreSQL:
+
+```
+# add to postgresql.conf:
+shared_preload_libraries = 'pg_cron'
+cron.database_name = 'postgres'
+```
+
+Note that pg_cron does not run any jobs as a long a server is in [hot standby](https://www.postgresql.org/docs/current/static/hot-standby.html) mode, but if pg_cron is in `shared_preload_libraries` then it automatically starts when the server is promoted.
+
+Internally, pg_cron uses libpq to open a new connection to the local database. It may be necessary to enable `trust` authentication for connections coming from localhost in [pg_hba.conf](https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html). Alternatively, you can create a [.pgpass file](https://www.postgresql.org/docs/current/static/libpq-pgpass.html) in the working directory of the database server.
+
+# Advanced usage
+
+Since pg_cron uses libpq, you can also run periodic jobs on other machines. This can be especially useful when you are using the [Citus extension](https://www.citusdata.com/product) to distribute tables across many PostgreSQL servers and need to run periodic jobs across all of them. 
+
+If you are superuser, then you can manually modify the cron.job table and use custom values for nodename and nodeport to connect to a different machine:
+
+```sql
+INSERT INTO cron.job (schedule, command, nodename, nodeport, username) 
+VALUES ('0 4 * * *', 'VACUUM', 'worker-node-1', 5432, 'marco');
+```
+
+You can use [.pgpass](https://www.postgresql.org/docs/current/static/libpq-pgpass.html) to allow pg_cron to authenticate with the remote server.

COMMIT_HASH:7eae9527abfbb077c7bc09520696d41e9786ef72|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-09-04 02:52:40 +0200|TITLE:Initial working version|MESSAGE:
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..b437813
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,38 @@
+# Global excludes across all subdirectories
+*.o
+*.so
+*.so.[0-9]
+*.so.[0-9].[0-9]
+*.sl
+*.sl.[0-9]
+*.sl.[0-9].[0-9]
+*.dylib
+*.dll
+*.a
+*.mo
+*.pot
+objfiles.txt
+.deps/
+*.gcno
+*.gcda
+*.gcov
+*.gcov.out
+lcov.info
+coverage/
+*.vcproj
+*.vcxproj
+win32ver.rc
+*.exe
+lib*dll.def
+lib*.pc
+
+# Local excludes in root directory
+/config.log
+/config.status
+/pgsql.sln
+/pgsql.sln.cache
+/Debug/
+/Release/
+/autom4te.cache
+/Makefile.global
+/src/Makefile.custom
diff --git a/include/bitstring.h b/include/bitstring.h
new file mode 100644
index 0000000..d054de3
--- /dev/null
+++ b/include/bitstring.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 1989 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Paul Vixie.
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by the University of California, Berkeley.  The name of the
+ * University may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	@(#)bitstring.h	5.2 (Berkeley) 4/4/90
+ */
+
+typedef	unsigned char bitstr_t;
+
+/* internal macros */
+				/* byte of the bitstring bit is in */
+#define	_bit_byte(bit) \
+	((bit) >> 3)
+
+				/* mask for the bit within its byte */
+#define	_bit_mask(bit) \
+	(1 << ((bit)&0x7))
+
+/* external macros */
+				/* bytes in a bitstring of nbits bits */
+#define	bitstr_size(nbits) \
+	((((nbits) - 1) >> 3) + 1)
+
+				/* allocate a bitstring */
+#define	bit_alloc(nbits) \
+	(bitstr_t *)malloc(1, \
+	    (unsigned int)bitstr_size(nbits) * sizeof(bitstr_t))
+
+				/* allocate a bitstring on the stack */
+#define	bit_decl(name, nbits) \
+	(name)[bitstr_size(nbits)]
+
+				/* is bit N of bitstring name set? */
+#define	bit_test(name, bit) \
+	((name)[_bit_byte(bit)] & _bit_mask(bit))
+
+				/* set bit N of bitstring name */
+#define	bit_set(name, bit) \
+	(name)[_bit_byte(bit)] |= _bit_mask(bit)
+
+				/* clear bit N of bitstring name */
+#define	bit_clear(name, bit) \
+	(name)[_bit_byte(bit)] &= ~_bit_mask(bit)
+
+				/* clear bits start ... stop in bitstring */
+#define	bit_nclear(name, start, stop) { \
+	register bitstr_t *_name = name; \
+	register int _start = start, _stop = stop; \
+	register int _startbyte = _bit_byte(_start); \
+	register int _stopbyte = _bit_byte(_stop); \
+	if (_startbyte == _stopbyte) { \
+		_name[_startbyte] &= ((0xff >> (8 - (_start&0x7))) | \
+				      (0xff << ((_stop&0x7) + 1))); \
+	} else { \
+		_name[_startbyte] &= 0xff >> (8 - (_start&0x7)); \
+		while (++_startbyte < _stopbyte) \
+			_name[_startbyte] = 0; \
+		_name[_stopbyte] &= 0xff << ((_stop&0x7) + 1); \
+	} \
+}
+
+				/* set bits start ... stop in bitstring */
+#define	bit_nset(name, start, stop) { \
+	register bitstr_t *_name = name; \
+	register int _start = start, _stop = stop; \
+	register int _startbyte = _bit_byte(_start); \
+	register int _stopbyte = _bit_byte(_stop); \
+	if (_startbyte == _stopbyte) { \
+		_name[_startbyte] |= ((0xff << (_start&0x7)) & \
+				    (0xff >> (7 - (_stop&0x7)))); \
+	} else { \
+		_name[_startbyte] |= 0xff << ((_start)&0x7); \
+		while (++_startbyte < _stopbyte) \
+	    		_name[_startbyte] = 0xff; \
+		_name[_stopbyte] |= 0xff >> (7 - (_stop&0x7)); \
+	} \
+}
+
+				/* find first bit clear in name */
+#define	bit_ffc(name, nbits, value) { \
+	register bitstr_t *_name = name; \
+	register int _byte, _nbits = nbits; \
+	register int _stopbyte = _bit_byte(_nbits), _value = -1; \
+	for (_byte = 0; _byte <= _stopbyte; ++_byte) \
+		if (_name[_byte] != 0xff) { \
+			_value = _byte << 3; \
+			for (_stopbyte = _name[_byte]; (_stopbyte&0x1); \
+			    ++_value, _stopbyte >>= 1); \
+			break; \
+		} \
+	*(value) = _value; \
+}
+
+				/* find first bit set in name */
+#define	bit_ffs(name, nbits, value) { \
+	register bitstr_t *_name = name; \
+	register int _byte, _nbits = nbits; \
+	register int _stopbyte = _bit_byte(_nbits), _value = -1; \
+	for (_byte = 0; _byte <= _stopbyte; ++_byte) \
+		if (_name[_byte]) { \
+			_value = _byte << 3; \
+			for (_stopbyte = _name[_byte]; !(_stopbyte&0x1); \
+			    ++_value, _stopbyte >>= 1); \
+			break; \
+		} \
+	*(value) = _value; \
+}
diff --git a/include/cron.h b/include/cron.h
new file mode 100644
index 0000000..8d5175e
--- /dev/null
+++ b/include/cron.h
@@ -0,0 +1,355 @@
+/* Copyright 1988,1990,1993,1994 by Paul Vixie
+ * All rights reserved
+ *
+ * Distribute freely, except: don't remove my name from the source or
+ * documentation (don't take credit for my work), mark your changes (don't
+ * get me blamed for your possible bugs), don't alter or remove this
+ * notice.  May be sold if buildable source is provided to buyer.  No
+ * warrantee of any kind, express or implied, is included with this
+ * software; use at your own risk, responsibility for damages (if any) to
+ * anyone resulting from the use of this software rests entirely with the
+ * user.
+ *
+ * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
+ * I'll try to keep a version up to date.  I can be reached as follows:
+ * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
+ */
+
+/* cron.h - header for vixie's cron
+ *
+ * $Id: cron.h,v 2.10 1994/01/15 20:43:43 vixie Exp $
+ *
+ * vix 14nov88 [rest of log is in RCS]
+ * vix 14jan87 [0 or 7 can be sunday; thanks, mwm@berkeley]
+ * vix 30dec86 [written]
+ */
+
+/* reorder these #include's at your peril */
+
+#include <sys/types.h>
+#include <sys/param.h>
+
+#include <stdio.h>
+#include <ctype.h>
+#include <bitstring.h>
+#include <pwd.h>
+#include <sys/wait.h>
+
+#include "pathnames.h"
+
+#if SYS_TIME_H
+# include <sys/time.h>
+#else
+# include <time.h>
+#endif
+
+
+#ifdef WITH_SELINUX
+#include <selinux/selinux.h>
+#endif
+
+#define SYSUSERNAME "root"
+
+
+	/* these are really immutable, and are
+	 *   defined for symbolic convenience only
+	 * TRUE, FALSE, and ERR must be distinct
+	 * ERR must be < OK.
+	 */
+#define TRUE		1
+#define FALSE		0
+	/* system calls return this on success */
+#define OK		0
+	/*   or this on error */
+#define ERR		(-1)
+
+	/* turn this on to get '-x' code */
+#ifndef DEBUGGING
+#define DEBUGGING	FALSE
+#endif
+
+#define READ_PIPE	0	/* which end of a pipe pair do you read? */
+#define WRITE_PIPE	1	/*   or write to? */
+#define STDIN		0	/* what is stdin's file descriptor? */
+#define STDOUT		1	/*   stdout's? */
+#define STDERR		2	/*   stderr's? */
+#define ERROR_EXIT	1	/* exit() with this will scare the shell */
+#define	OK_EXIT		0	/* exit() with this is considered 'normal' */
+#define	MAX_FNAME	100	/* max length of internally generated fn */
+#define	MAX_COMMAND	1000	/* max length of internally generated cmd */
+#define	MAX_TEMPSTR	1000	/* max length of envvar=value\0 strings */
+#define	MAX_ENVSTR	MAX_TEMPSTR	/* DO NOT change - buffer overruns otherwise */
+#define	MAX_UNAME	20	/* max length of username, should be overkill */
+#define	ROOT_UID	0	/* don't change this, it really must be root */
+#define	ROOT_USER	"root"	/* ditto */
+
+				/* NOTE: these correspond to DebugFlagNames,
+				 *	defined below.
+				 */
+#define	DEXT		0x0001	/* extend flag for other debug masks */
+#define	DSCH		0x0002	/* scheduling debug mask */
+#define	DPROC		0x0004	/* process control debug mask */
+#define	DPARS		0x0008	/* parsing debug mask */
+#define	DLOAD		0x0010	/* database loading debug mask */
+#define	DMISC		0x0020	/* misc debug mask */
+#define	DTEST		0x0040	/* test mode: don't execute any commands */
+#define	DBIT		0x0080	/* bit twiddling shown (long) */
+
+#define	CRON_TAB(u)	"%s/%s", SPOOL_DIR, u
+#define	REG		register
+#define	PPC_NULL	((char **)NULL)
+
+#ifndef MAXHOSTNAMELEN
+#define MAXHOSTNAMELEN 64
+#endif
+
+#define	Skip_Blanks(c, f) \
+			while (c == '\t' || c == ' ') \
+				c = get_char(f);
+
+#define	Skip_Nonblanks(c, f) \
+			while (c!='\t' && c!=' ' && c!='\n' && c != EOF && c != '\0') \
+				c = get_char(f);
+
+#define	Skip_Line(c, f) \
+			do {c = get_char(f);} while (c != '\n' && c != EOF);
+
+#if DEBUGGING
+# define Debug(mask, message) \
+			if ( (DebugFlags & (mask) )  ) \
+				printf message;
+#else /* !DEBUGGING */
+# define Debug(mask, message) \
+			;
+#endif /* DEBUGGING */
+
+#define	MkLower(ch)	(isupper(ch) ? tolower(ch) : ch)
+#define	MkUpper(ch)	(islower(ch) ? toupper(ch) : ch)
+#define	Set_LineNum(ln)	{Debug(DPARS|DEXT,("linenum=%d\n",ln)); \
+			 LineNumber = ln; \
+			}
+
+typedef int time_min;
+
+/* Log levels */
+#define	CRON_LOG_JOBSTART	0x01
+#define	CRON_LOG_JOBEND		0x02
+#define	CRON_LOG_JOBFAILED	0x04
+#define	CRON_LOG_JOBPID		0x08
+
+#define SECONDS_PER_MINUTE 60
+
+#define	FIRST_MINUTE	0
+#define	LAST_MINUTE	59
+#define	MINUTE_COUNT	(LAST_MINUTE - FIRST_MINUTE + 1)
+
+#define	FIRST_HOUR	0
+#define	LAST_HOUR	23
+#define	HOUR_COUNT	(LAST_HOUR - FIRST_HOUR + 1)
+
+#define	FIRST_DOM	1
+#define	LAST_DOM	31
+#define	DOM_COUNT	(LAST_DOM - FIRST_DOM + 1)
+
+#define	FIRST_MONTH	1
+#define	LAST_MONTH	12
+#define	MONTH_COUNT	(LAST_MONTH - FIRST_MONTH + 1)
+
+/* note on DOW: 0 and 7 are both Sunday, for compatibility reasons. */
+#define	FIRST_DOW	0
+#define	LAST_DOW	7
+#define	DOW_COUNT	(LAST_DOW - FIRST_DOW + 1)
+
+			/* each user's crontab will be held as a list of
+			 * the following structure.
+			 *
+			 * These are the cron commands.
+			 */
+
+typedef	struct _entry {
+	struct _entry	*next;
+	uid_t		uid;	
+	gid_t		gid;
+	char		**envp;
+	char		*cmd;
+	bitstr_t	bit_decl(minute, MINUTE_COUNT);
+	bitstr_t	bit_decl(hour,   HOUR_COUNT);
+	bitstr_t	bit_decl(dom,    DOM_COUNT);
+	bitstr_t	bit_decl(month,  MONTH_COUNT);
+	bitstr_t	bit_decl(dow,    DOW_COUNT);
+	int		flags;
+#define	DOM_STAR	0x01
+#define	DOW_STAR	0x02
+#define	WHEN_REBOOT	0x04
+#define MIN_STAR	0x08
+#define HR_STAR		0x10
+} entry;
+
+			/* the crontab database will be a list of the
+			 * following structure, one element per user
+			 * plus one for the system.
+			 *
+			 * These are the crontabs.
+			 */
+
+typedef	struct _user {
+	struct _user	*next, *prev;	/* links */
+	char		*name;
+	time_t		mtime;		/* last modtime of crontab */
+	entry		*crontab;	/* this person's crontab */
+#ifdef WITH_SELINUX
+        security_context_t scontext;    /* SELinux security context */
+#endif
+} user;
+
+typedef	struct _cron_db {
+	user		*head, *tail;	/* links */
+	time_t		user_mtime;     /* last modtime on spooldir */
+	time_t		sys_mtime;      /* last modtime on system crontab */
+#ifdef DEBIAN
+	time_t		sysd_mtime;     /* last modtime on system crondir */
+#endif
+} cron_db;
+
+typedef struct _orphan {
+	struct _orphan  *next;          /* link */
+	char            *uname;
+	char            *fname;
+	char            *tabname;
+} orphan;
+
+/*
+ * Buffer used to mimick getc(FILE*) and ungetc(FILE*)
+ */
+#define MAX_FILE_BUFFER_LENGTH 1000
+
+typedef struct _file_buffer {
+	char 		data[MAX_FILE_BUFFER_LENGTH];
+	int			length;
+	int			pointer;
+	char		unget_data[MAX_FILE_BUFFER_LENGTH];
+	int			unget_count;
+} file_buffer;
+
+void		set_cron_uid __P((void)),
+		set_cron_cwd __P((void)),
+		load_database __P((cron_db *)),
+		open_logfile __P((void)),
+		sigpipe_func __P((void)),
+		job_add __P((entry *, user *)),
+		do_command __P((entry *, user *)),
+		link_user __P((cron_db *, user *)),
+		unlink_user __P((cron_db *, user *)),
+		free_user __P((user *)),
+		unget_char __P((int, FILE *)),
+		free_entry __P((entry *)),
+		acquire_daemonlock __P((int)),
+		skip_comments __P((FILE *)),
+		log_it __P((char *, int, char *, char *)),
+		log_close __P((void)),
+		check_orphans __P((cron_db *));
+
+int		job_runqueue __P((void)),
+		set_debug_flags __P((char *)),
+		get_char __P((FILE *)),
+		get_string __P((char *, int, FILE *, char *)),
+		swap_uids __P((void)),
+		swap_uids_back __P((void)),
+		cron_pclose __P((FILE *)),
+		strcmp_until __P((char *, char *, int)),
+		allowed __P((char *)),
+		strdtb __P((char *));
+
+long            get_gmtoff(time_t *, struct tm *);
+
+char	*arpadate __P((time_t *)),
+		*mkprints __P((unsigned char *, unsigned int)),
+		*first_word __P((char *, char *));
+
+user		*load_user __P((int, struct passwd *, char *, char *, char *)),
+		*find_user __P((cron_db *, char *));
+
+entry * parse_cron_entry(char *);
+
+FILE		*cron_popen __P((char *, char *, entry *));
+
+
+				/* in the C tradition, we only create
+				 * variables for the main program, just
+				 * extern them elsewhere.
+				 */
+
+#ifdef MAIN_PROGRAM
+# if !defined(LINT) && !defined(lint)
+char	*copyright[] = {
+		"@(#) Copyright 1988,1989,1990,1993,1994 by Paul Vixie",
+		"@(#) All rights reserved"
+	};
+# endif
+
+char	*MonthNames[] = {
+		"Jan", "Feb", "Mar", "Apr", "May", "Jun",
+		"Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
+		NULL
+	};
+
+char	*DowNames[] = {
+		"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun",
+		NULL
+	};
+
+char	*ecodes[] = {
+		"no error",
+		"bad minute",
+		"bad hour",
+		"bad day-of-month",
+		"bad month",
+		"bad day-of-week",
+		"bad command",
+		"bad time specifier",
+		"bad username",
+		"command too long",
+		NULL
+	};
+
+
+char	*ProgramName;
+int	LineNumber;
+time_t	StartTime;
+time_min timeRunning;
+time_min virtualTime;
+time_min clockTime;
+static long GMToff;
+
+int	stay_foreground;
+int     lsbsysinit_mode;
+int     fqdn_in_subject;
+int     log_level = 1;
+char    cron_default_mail_charset[MAX_ENVSTR] = "";
+
+# if DEBUGGING
+int	DebugFlags;
+char	*DebugFlagNames[] = {	/* sync with #defines */
+		"ext", "sch", "proc", "pars", "load", "misc", "test", "bit",
+		NULL		/* NULL must be last element */
+	};
+# endif /* DEBUGGING */
+#else /*MAIN_PROGRAM*/
+extern	char	*copyright[],
+		*MonthNames[],
+		*DowNames[],
+		*ProgramName;
+extern  int     lsbsysinit_mode;
+extern  int     fqdn_in_subject;
+extern  int     log_level;
+extern	int	LineNumber;
+extern	time_t	StartTime;
+extern  time_min timeRunning;
+extern  time_min virtualTime;
+extern  time_min clockTime;
+extern  char     cron_default_mail_charset[MAX_ENVSTR];
+# if DEBUGGING
+extern	int	DebugFlags;
+extern	char	*DebugFlagNames[];
+# endif /* DEBUGGING */
+#endif /*MAIN_PROGRAM*/
diff --git a/include/cron_job.h b/include/cron_job.h
new file mode 100644
index 0000000..170ee2a
--- /dev/null
+++ b/include/cron_job.h
@@ -0,0 +1,51 @@
+/*-------------------------------------------------------------------------
+ *
+ * cron_job.h
+ *	  definition of the relation that holds cron jobs (cron.job).
+ *
+ * Copyright (c) 2016, Citus Data, Inc.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#ifndef CRON_JOB_H
+#define CRON_JOB_H
+
+/* ----------------
+ *		cron_job definition.
+ * ----------------
+ */
+typedef struct FormData_cron_job
+{
+	int64 jobId;
+#ifdef CATALOG_VARLEN
+	text schedule;
+	text command;
+	text nodeName;
+	int nodePort;
+	text database;
+	text userName;
+#endif
+} FormData_cron_job;
+
+/* ----------------
+ *      Form_cron_jobs corresponds to a pointer to a tuple with
+ *      the format of cron_job relation.
+ * ----------------
+ */
+typedef FormData_cron_job *Form_cron_job;
+
+/* ----------------
+ *      compiler constants for cron_job
+ * ----------------
+ */
+#define Natts_cron_job 7
+#define Anum_cron_job_jobid 1
+#define Anum_cron_job_schedule 2
+#define Anum_cron_job_command 3
+#define Anum_cron_job_nodename 4
+#define Anum_cron_job_nodeport 5
+#define Anum_cron_job_database 6
+#define Anum_cron_job_username 7
+
+#endif /* CRON_JOB_H */
diff --git a/include/job_metadata.h b/include/job_metadata.h
deleted file mode 100644
index 73cdd27..0000000
--- a/include/job_metadata.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*-------------------------------------------------------------------------
- *
- * include/job_metadata.h
- *
- * Declarations for public functions and types related to job metadata.
- *
- * Copyright (c) 2016, Citus Data, Inc.
- *
- *-------------------------------------------------------------------------
- */
-
-#pragma once
-
-#include "postgres.h"
-
-#include "access/htup.h"
-#include "access/tupdesc.h"
-#include "nodes/pg_list.h"
-
-
-/*
- * CronJob represents a periodic job.
- */
-typedef struct CronJob
-{
-	char *jobName;
-	char *cronString;
-	char *query;
-	char *connectionString;
-
-} CronJob;
-
-
-extern List * LoadCronJobList(void);
-extern void LogCronTaskResult(char *jobName, int taskStatus);
diff --git a/include/pathnames.h b/include/pathnames.h
new file mode 100644
index 0000000..a9a745c
--- /dev/null
+++ b/include/pathnames.h
@@ -0,0 +1,111 @@
+/* Copyright 1993,1994 by Paul Vixie
+ * All rights reserved
+ *
+ * Distribute freely, except: don't remove my name from the source or
+ * documentation (don't take credit for my work), mark your changes (don't
+ * get me blamed for your possible bugs), don't alter or remove this
+ * notice.  May be sold if buildable source is provided to buyer.  No
+ * warrantee of any kind, express or implied, is included with this
+ * software; use at your own risk, responsibility for damages (if any) to
+ * anyone resulting from the use of this software rests entirely with the
+ * user.
+ *
+ * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
+ * I'll try to keep a version up to date.  I can be reached as follows:
+ * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
+ */
+
+/*
+ * $Id: pathnames.h,v 1.3 1994/01/15 20:43:43 vixie Exp $
+ */
+
+#ifndef CRONDIR
+			/* CRONDIR is where crond(8) and crontab(1) both chdir
+			 * to; SPOOL_DIR, ALLOW_FILE, DENY_FILE, and LOG_FILE
+			 * are all relative to this directory.
+			 */
+#define CRONDIR		"/var/spool/cron"
+#endif
+
+			/* SPOOLDIR is where the crontabs live.
+			 * This directory will have its modtime updated
+			 * whenever crontab(1) changes a crontab; this is
+			 * the signal for crond(8) to look at each individual
+			 * crontab file and reload those whose modtimes are
+			 * newer than they were last time around (or which
+			 * didn't exist last time around...)
+			 */
+#define SPOOL_DIR	"crontabs"
+
+			/* undefining these turns off their features.  note
+			 * that ALLOW_FILE and DENY_FILE must both be defined
+			 * in order to enable the allow/deny code.  If neither
+			 * LOG_FILE or SYSLOG is defined, we don't log.  If
+			 * both are defined, we log both ways.
+			 */
+#ifdef DEBIAN
+#define	ALLOW_FILE	"/etc/cron.allow"		/*-*/
+#define DENY_FILE	"/etc/cron.deny"		/*-*/
+#else
+#define	ALLOW_FILE	"allow"		/*-*/
+#define DENY_FILE	"deny"		/*-*/
+#endif
+/* #define LOG_FILE	"log"		  -*/
+
+			/* where should the daemon stick its PID?
+			 */
+#ifdef _PATH_VARRUN
+# define PIDDIR	_PATH_VARRUN
+#else
+# define PIDDIR "/etc/"
+#endif
+#define PIDFILE		"%scrond.pid"
+
+			/* 4.3BSD-style crontab */
+#define SYSCRONTAB	"/etc/crontab"
+#ifdef DEBIAN
+                        /* where package specific crontabs live */ 
+#define SYSCRONDIR      "/etc/cron.d"
+#endif
+			/* what editor to use if no EDITOR or VISUAL
+			 * environment variable specified.
+			 */
+#if defined(DEBIAN)
+# define EDITOR "/usr/bin/sensible-editor"
+#elif defined(_PATH_VI)
+# define EDITOR _PATH_VI
+#else
+# define EDITOR "/usr/ucb/vi"
+#endif
+
+#ifndef _PATH_BSHELL
+# define _PATH_BSHELL "/bin/sh"
+#endif
+
+#ifndef _PATH_DEFPATH
+# define _PATH_DEFPATH "/usr/bin:/bin"
+#endif
+
+#ifndef _PATH_DEFPATH_ROOT
+# define _PATH_DEFPATH_ROOT "/usr/sbin:/usr/bin:/sbin:/bin"
+#endif
+
+
+#ifndef CRONDIR_MODE
+			/* Create mode for CRONDIR; must be in sync with
+			 * packaging
+			 */
+#define CRONDIR_MODE 0755
+#endif
+#ifndef SPOOL_DIR_MODE
+			/* Create mode for SPOOL_DIR; must be in sync with
+			 * packaging
+			 */
+#define SPOOL_DIR_MODE 01730
+#endif
+#ifndef SPOOL_DIR_GROUP
+			/* Chown SPOOL_DIR to this group (needed by Debian's
+			 * SGID crontab feature)
+			 */ 
+#define SPOOL_DIR_GROUP "crontab"
+#endif
diff --git a/include/pg_cron.h b/include/pg_cron.h
new file mode 100644
index 0000000..f2d299a
--- /dev/null
+++ b/include/pg_cron.h
@@ -0,0 +1,64 @@
+/*-------------------------------------------------------------------------
+ *
+ * pg_cron.h
+ *	  definition of pg_cron data types
+ *
+ * Copyright (c) 2010-2015, Citus Data, Inc.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#ifndef PG_CRON_H
+#define PG_CRON_H
+
+#include "cron_job.h"
+#include "libpq-fe.h"
+#include "utils/timestamp.h"
+
+typedef enum
+{
+	CLOCK_JUMP_BACKWARD = 0,
+	CLOCK_PROGRESSED = 1,
+	CLOCK_JUMP_FORWARD = 2,
+	CLOCK_CHANGE = 3
+} ClockProgress;
+
+typedef enum
+{
+	CRON_TASK_WAITING = 0,
+	CRON_TASK_START = 1,
+	CRON_TASK_CONNECTING = 2,
+	CRON_TASK_SENDING = 3,
+	CRON_TASK_RUNNING = 4,
+	CRON_TASK_RECEIVING = 5,
+	CRON_TASK_DONE = 6,
+	CRON_TASK_ERROR = 7
+} CronTaskState;
+
+typedef struct CronJob
+{
+	int64 jobId;
+	char *scheduleText;
+	entry schedule;
+	char *command;
+	char *nodeName;
+	int nodePort;
+	char *database;
+	char *userName;
+} CronJob;
+
+typedef struct CronTask
+{
+	int64 jobId;
+	int64 runId;
+	CronTaskState state;
+	int pendingRunCount;
+	PGconn *connection;
+	PostgresPollingStatusType pollingStatus;
+	TimestampTz startDeadline;
+	bool isSocketReady;
+	bool isActive;
+	char *errorMessage;
+} CronTask;
+
+#endif
diff --git a/sql/.gitignore b/sql/.gitignore
new file mode 100644
index 0000000..72dc612
--- /dev/null
+++ b/sql/.gitignore
@@ -0,0 +1,4 @@
+# ignore latest install file
+pg_cron--?.?.sql
+pg_cron--?.?-*.sql
+!pg_cron--?.?-*--?.?-*.sql
diff --git a/sql/pg_cron.sql b/sql/pg_cron.sql
index e955bd3..b603e49 100644
--- a/sql/pg_cron.sql
+++ b/sql/pg_cron.sql
@@ -1,34 +1,53 @@
-CREATE SCHEMA cron
+CREATE SCHEMA cron;
+GRANT USAGE ON SCHEMA cron TO public;
 
-	CREATE TABLE jobs (
-		job_name text not null,
-		cron_string not null,
-		query text not null,
-		connection_string text not null,
-		PRIMARY KEY (job_name)
-	)
+CREATE SEQUENCE cron.jobid_seq;
+GRANT USAGE ON SEQUENCE cron.jobid_seq TO public;
 
-	CREATE TABLE results (
-		id bigint primary key default nextval('task_id_sequence'),
-		job_name text not null,
-		start_time timestamptz,
-		end_time timestamptz,
-		status int not null,
-		output text
-	)
+CREATE TABLE cron.job (
+	jobid bigint primary key,
+	schedule text not null,
+	command text not null,
+	nodename text not null default 'localhost',
+	nodeport int not null default inet_server_port(),
+	database text not null default current_database(),
+	username text not null default current_user
+);
+GRANT SELECT ON cron.job TO public;
+ALTER TABLE cron.job ENABLE ROW LEVEL SECURITY;
+CREATE POLICY cron_job_policy ON cron.job USING (username = current_user);
 
-	CREATE SEQUENCE task_id_sequence NO CYCLE;
+CREATE TABLE cron.result (
+	runid bigint,
+	jobid bigint not null,
+	starttime timestamptz,
+	endtime timestamptz,
+	status int not null,
+	output text
+);
 
-CREATE FUNCTION cron.schedule(text,text,text,text)
-    RETURNS text
+CREATE FUNCTION cron.schedule(schedule text, command text)
+    RETURNS bigint
     LANGUAGE C STRICT
-    AS 'MODULE_PATHNAME', $$pg_cron_schedule$$;
-COMMENT ON FUNCTION cron.schedule(text,text,text,text)
+    AS 'MODULE_PATHNAME', $$cron_schedule$$;
+COMMENT ON FUNCTION cron.schedule(text,text)
     IS 'schedule a pg_cron job';
 
-CREATE FUNCTION cron.unschedule(text)
-    RETURNS text
+CREATE FUNCTION cron.unschedule(job_id bigint)
+    RETURNS bool
     LANGUAGE C STRICT
-    AS 'MODULE_PATHNAME', $$pg_cron_schedule$$;
-COMMENT ON FUNCTION cron.unschedule(text)
+    AS 'MODULE_PATHNAME', $$cron_unschedule$$;
+COMMENT ON FUNCTION cron.unschedule(bigint)
     IS 'unschedule a pg_cron job';
+
+CREATE FUNCTION cron.job_cache_invalidate()
+    RETURNS trigger
+    LANGUAGE C
+    AS 'MODULE_PATHNAME', $$cron_job_cache_invalidate$$;
+COMMENT ON FUNCTION cron.job_cache_invalidate()
+    IS 'invalidate job cache';
+
+CREATE TRIGGER cron_job_cache_invalidate
+    AFTER INSERT OR UPDATE OR DELETE OR TRUNCATE
+    ON cron.job
+    FOR STATEMENT EXECUTE PROCEDURE cron.job_cache_invalidate();
diff --git a/src/entry.c b/src/entry.c
new file mode 100644
index 0000000..6455a26
--- /dev/null
+++ b/src/entry.c
@@ -0,0 +1,465 @@
+/* Copyright 1988,1990,1993,1994 by Paul Vixie
+ * All rights reserved
+ *
+ * Distribute freely, except: don't remove my name from the source or
+ * documentation (don't take credit for my work), mark your changes (don't
+ * get me blamed for your possible bugs), don't alter or remove this
+ * notice.  May be sold if buildable source is provided to buyer.  No
+ * warrantee of any kind, express or implied, is included with this
+ * software; use at your own risk, responsibility for damages (if any) to
+ * anyone resulting from the use of this software rests entirely with the
+ * user.
+ *
+ * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
+ * I'll try to keep a version up to date.  I can be reached as follows:
+ * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
+ */
+
+/* vix 26jan87 [RCS'd; rest of log is in RCS file]
+ * vix 01jan87 [added line-level error recovery]
+ * vix 31dec86 [added /step to the from-to range, per bob@acornrc]
+ * vix 30dec86 [written]
+ */
+
+
+#include "postgres.h"
+
+#include "stdlib.h"
+#include "string.h"
+#include "cron.h"
+
+
+typedef	enum ecode {
+	e_none, e_minute, e_hour, e_dom, e_month, e_dow,
+	e_cmd, e_timespec, e_username, e_cmd_len
+} ecode_e;
+
+static char	get_list __P((bitstr_t *, int, int, char *[], int, FILE *)),
+		get_range __P((bitstr_t *, int, int, char *[], int, FILE *)),
+		get_number __P((int *, int, char *[], int, FILE *));
+static int	set_element __P((bitstr_t *, int, int, int));
+
+
+void
+free_entry(e)
+	entry	*e;
+{
+	free(e->cmd);
+	free(e);
+}
+
+
+/* return NULL if eof or syntax error occurs;
+ * otherwise return a pointer to a new entry.
+ *
+ * Note: This function is a modified version of load_entry in Vixie
+ * cron. It only parses the schedule part of a cron entry and uses
+ * an in-memry buffer.
+ */
+entry *
+parse_cron_entry(char *schedule)
+{
+	/* this function reads one crontab entry -- the next -- from a file.
+	 * it skips any leading blank lines, ignores comments, and returns
+	 * EOF if for any reason the entry can't be read and parsed.
+	 *
+	 * the entry is also parsed here.
+	 *
+	 * syntax:
+	 *   user crontab:
+	 *	minutes hours doms months dows cmd\n
+	 *   system crontab (/etc/crontab):
+	 *	minutes hours doms months dows USERNAME cmd\n
+	 */
+
+	ecode_e	ecode = e_none;
+	entry *e = NULL;
+	int	ch = 0;
+	char cmd[MAX_COMMAND];
+	file_buffer buffer = {{},0,0,{},0};
+	FILE *file = (FILE *) &buffer;
+
+	int scheduleLength = strlen(schedule); 
+	if (scheduleLength >= MAX_FILE_BUFFER_LENGTH)
+	{
+		ecode = e_cmd_len;
+		goto eof;
+	}
+
+	strcpy(buffer.data, schedule);
+	buffer.length = scheduleLength;
+	buffer.pointer = 0;
+
+	Debug(DPARS, ("load_entry()...about to eat comments\n"))
+
+	skip_comments(file);
+
+	ch = get_char(file);
+	if (ch == EOF)
+		return NULL;
+
+	/* ch is now the first useful character of a useful line.
+	 * it may be an @special or it may be the first character
+	 * of a list of minutes.
+	 */
+
+	e = (entry *) calloc(sizeof(entry), sizeof(char));
+
+	if (ch == '@') {
+		/* all of these should be flagged and load-limited; i.e.,
+		 * instead of @hourly meaning "0 * * * *" it should mean
+		 * "close to the front of every hour but not 'til the
+		 * system load is low".  Problems are: how do you know
+		 * what "low" means? (save me from /etc/cron.conf!) and:
+		 * how to guarantee low variance (how low is low?), which
+		 * means how to we run roughly every hour -- seems like
+		 * we need to keep a history or let the first hour set
+		 * the schedule, which means we aren't load-limited
+		 * anymore.  too much for my overloaded brain. (vix, jan90)
+		 * HINT
+		 */
+		ch = get_string(cmd, MAX_COMMAND, file, " \t\n");
+		if (!strcmp("reboot", cmd)) {
+			e->flags |= WHEN_REBOOT;
+		} else if (!strcmp("yearly", cmd) || !strcmp("annually", cmd)){
+			bit_set(e->minute, 0);
+			bit_set(e->hour, 0);
+			bit_set(e->dom, 0);
+			bit_set(e->month, 0);
+			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
+                        e->flags |= DOW_STAR; 
+		} else if (!strcmp("monthly", cmd)) {
+			bit_set(e->minute, 0);
+			bit_set(e->hour, 0);
+			bit_set(e->dom, 0);
+			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
+			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
+                        e->flags |= DOW_STAR;
+		} else if (!strcmp("weekly", cmd)) {
+			bit_set(e->minute, 0);
+			bit_set(e->hour, 0);
+			bit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));
+			e->flags |= DOM_STAR;
+			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
+			bit_nset(e->dow, 0,0);
+		} else if (!strcmp("daily", cmd) || !strcmp("midnight", cmd)) {
+			bit_set(e->minute, 0);
+			bit_set(e->hour, 0);
+			bit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));
+			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
+			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
+		} else if (!strcmp("hourly", cmd)) {
+			bit_set(e->minute, 0);
+			bit_nset(e->hour, 0, (LAST_HOUR-FIRST_HOUR+1));
+			bit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));
+			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
+			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
+			e->flags |= HR_STAR;
+		} else {
+			ecode = e_timespec;
+			goto eof;
+		}
+	} else {
+		Debug(DPARS, ("load_entry()...about to parse numerics\n"))
+
+		if (ch == '*')
+			e->flags |= MIN_STAR;
+		ch = get_list(e->minute, FIRST_MINUTE, LAST_MINUTE,
+			      PPC_NULL, ch, file);
+		if (ch == EOF) {
+			ecode = e_minute;
+			goto eof;
+		}
+
+		/* hours
+		 */
+
+		if (ch == '*')
+			e->flags |= HR_STAR;
+		ch = get_list(e->hour, FIRST_HOUR, LAST_HOUR,
+			      PPC_NULL, ch, file);
+		if (ch == EOF) {
+			ecode = e_hour;
+			goto eof;
+		}
+
+		/* DOM (days of month)
+		 */
+
+		if (ch == '*')
+			e->flags |= DOM_STAR;
+		ch = get_list(e->dom, FIRST_DOM, LAST_DOM,
+			      PPC_NULL, ch, file);
+		if (ch == EOF) {
+			ecode = e_dom;
+			goto eof;
+		}
+
+		/* month
+		 */
+
+		ch = get_list(e->month, FIRST_MONTH, LAST_MONTH,
+			      MonthNames, ch, file);
+		if (ch == EOF) {
+			ecode = e_month;
+			goto eof;
+		}
+
+		/* DOW (days of week)
+		 */
+
+		if (ch == '*')
+			e->flags |= DOW_STAR;
+		ch = get_list(e->dow, FIRST_DOW, LAST_DOW,
+			      DowNames, ch, file);
+		if (ch == EOF) {
+			ecode = e_month;
+			goto eof;
+		}
+	}
+
+	/* make sundays equivilent */
+	if (bit_test(e->dow, 0) || bit_test(e->dow, 7)) {
+		bit_set(e->dow, 0);
+		bit_set(e->dow, 7);
+	}
+
+	/* success, fini, return pointer to the entry we just created...
+	 */
+	return e;
+
+ eof:
+	elog(LOG, "failed to parse entry %d", ecode);
+	if (e->cmd)
+		free(e->cmd);
+	free(e);
+	while (ch != EOF && ch != '\n')
+		ch = get_char(file);
+	return NULL;
+}
+
+
+static char
+get_list(bits, low, high, names, ch, file)
+	bitstr_t	*bits;		/* one bit per flag, default=FALSE */
+	int		low, high;	/* bounds, impl. offset for bitstr */
+	char		*names[];	/* NULL or *[] of names for these elements */
+	int		ch;		/* current character being processed */
+	FILE		*file;		/* file being read */
+{
+	register int	done;
+
+	/* we know that we point to a non-blank character here;
+	 * must do a Skip_Blanks before we exit, so that the
+	 * next call (or the code that picks up the cmd) can
+	 * assume the same thing.
+	 */
+
+	Debug(DPARS|DEXT, ("get_list()...entered\n"))
+
+	/* list = range {"," range}
+	 */
+	
+	/* clear the bit string, since the default is 'off'.
+	 */
+	bit_nclear(bits, 0, (high-low+1));
+
+	/* process all ranges
+	 */
+	done = FALSE;
+	while (!done) {
+		ch = get_range(bits, low, high, names, ch, file);
+		if (ch == ',')
+			ch = get_char(file);
+		else
+			done = TRUE;
+	}
+
+	/* exiting.  skip to some blanks, then skip over the blanks.
+	 */
+	Skip_Nonblanks(ch, file)
+	Skip_Blanks(ch, file)
+
+	Debug(DPARS|DEXT, ("get_list()...exiting w/ %02x\n", ch))
+
+	return ch;
+}
+
+
+static char
+get_range(bits, low, high, names, ch, file)
+	bitstr_t	*bits;		/* one bit per flag, default=FALSE */
+	int		low, high;	/* bounds, impl. offset for bitstr */
+	char		*names[];	/* NULL or names of elements */
+	int		ch;		/* current character being processed */
+	FILE 		*file;		/* file being read */
+{
+	/* range = number | number "-" number [ "/" number ]
+	 */
+
+	register int	i;
+	auto int	num1, num2, num3;
+
+	Debug(DPARS|DEXT, ("get_range()...entering, exit won't show\n"))
+
+	if (ch == '*') {
+		/* '*' means "first-last" but can still be modified by /step
+		 */
+		num1 = low;
+		num2 = high;
+		ch = get_char(file);
+		if (ch == EOF)
+			return EOF;
+	} else {
+		if (EOF == (ch = get_number(&num1, low, names, ch, file)))
+			return EOF;
+
+		if (ch != '-') {
+			/* not a range, it's a single number.
+			 */
+
+			/* Unsupported syntax: Step specified without range,
+			   eg:   1/20 * * * * /bin/echo "this fails"
+			 */
+			if (ch == '/')
+				return EOF;
+
+			if (EOF == set_element(bits, low, high, num1))
+				return EOF;
+			return ch;
+		} else {
+			/* eat the dash
+			 */
+			ch = get_char(file);
+			if (ch == EOF)
+				return EOF;
+
+			/* get the number following the dash
+			 */
+			ch = get_number(&num2, low, names, ch, file);
+			if (ch == EOF)
+				return EOF;
+		}
+	}
+
+	/* check for step size
+	 */
+	if (ch == '/') {
+		/* eat the slash
+		 */
+		ch = get_char(file);
+		if (ch == EOF)
+			return EOF;
+
+		/* get the step size -- note: we don't pass the
+		 * names here, because the number is not an
+		 * element id, it's a step size.  'low' is
+		 * sent as a 0 since there is no offset either.
+		 */
+		ch = get_number(&num3, 0, PPC_NULL, ch, file);
+		if (ch == EOF || num3 <= 0)
+			return EOF;
+	} else {
+		/* no step.  default==1.
+		 */
+		num3 = 1;
+	}
+
+	/* Explicitly check for sane values. Certain combinations of ranges and
+	 * steps which should return EOF don't get picked up by the code below,
+	 * eg:
+	 *	5-64/30 * * * *	touch /dev/null
+	 *
+	 * Code adapted from set_elements() where this error was probably intended
+	 * to be catched.
+	 */
+	if (num1 < low || num1 > high || num2 < low || num2 > high)
+		return EOF;
+
+	/* range. set all elements from num1 to num2, stepping
+	 * by num3.  (the step is a downward-compatible extension
+	 * proposed conceptually by bob@acornrc, syntactically
+	 * designed then implmented by paul vixie).
+	 */
+	for (i = num1;  i <= num2;  i += num3)
+		if (EOF == set_element(bits, low, high, i))
+			return EOF;
+
+	return ch;
+}
+
+
+static char
+get_number(numptr, low, names, ch, file)
+	int	*numptr;	/* where does the result go? */
+	int	low;		/* offset applied to result if symbolic enum used */
+	char	*names[];	/* symbolic names, if any, for enums */
+	int	ch;		/* current character */
+	FILE 		*file;		/* source */
+{
+	char	temp[MAX_TEMPSTR], *pc;
+	int	len, i, all_digits;
+
+	/* collect alphanumerics into our fixed-size temp array
+	 */
+	pc = temp;
+	len = 0;
+	all_digits = TRUE;
+	while (isalnum(ch)) {
+		if (++len >= MAX_TEMPSTR)
+			return EOF;
+
+		*pc++ = ch;
+
+		if (!isdigit(ch))
+			all_digits = FALSE;
+
+		ch = get_char(file);
+	}
+	*pc = '\0';
+
+        if (len == 0) {
+            return EOF;
+        }
+
+	/* try to find the name in the name list
+	 */
+	if (names) {
+		for (i = 0;  names[i] != NULL;  i++) {
+			Debug(DPARS|DEXT,
+				("get_num, compare(%s,%s)\n", names[i], temp))
+			if (!strcasecmp(names[i], temp)) {
+				*numptr = i+low;
+				return ch;
+			}
+		}
+	}
+
+	/* no name list specified, or there is one and our string isn't
+	 * in it.  either way: if it's all digits, use its magnitude.
+	 * otherwise, it's an error.
+	 */
+	if (all_digits) {
+		*numptr = atoi(temp);
+		return ch;
+	}
+
+	return EOF;
+}
+
+
+static int
+set_element(bits, low, high, number)
+	bitstr_t	*bits; 		/* one bit per flag, default=FALSE */
+	int		low;
+	int		high;
+	int		number;
+{
+	Debug(DPARS|DEXT, ("set_element(?,%d,%d,%d)\n", low, high, number))
+
+	if (number < low || number > high)
+		return EOF;
+
+	bit_set(bits, (number-low));
+	return OK;
+}
diff --git a/src/job_metadata.c b/src/job_metadata.c
deleted file mode 100644
index 612357e..0000000
--- a/src/job_metadata.c
+++ /dev/null
@@ -1,167 +0,0 @@
-/*-------------------------------------------------------------------------
- *
- * src/job_metadata.c
- *
- * Implementation of functions related to job metadata.
- *
- * Copyright (c) 2016, Citus Data, Inc.
- *
- *-------------------------------------------------------------------------
- */
-
-#include "postgres.h"
-
-#include "job_metadata.h"
-
-#include "access/htup.h"
-#include "access/tupdesc.h"
-#include "access/xact.h"
-#include "executor/spi.h"
-#include "lib/stringinfo.h"
-#include "nodes/pg_list.h"
-#include "pgstat.h"
-#include "utils/builtins.h"
-#include "utils/memutils.h"
-#include "utils/snapmgr.h"
-
-
-/* human-readable names for addressing columns of job metadata */
-#define TLIST_NUM_JOB_NAME 1
-#define TLIST_NUM_CRON_STRING 2
-#define TLIST_NUM_QUERY 3
-#define TLIST_NUM_CONNECTION_STRING 4
-
-
-static void StartSPITransaction(void);
-extern CronJob * TupleToCronJob(HeapTuple heapTuple,
-								TupleDesc tupleDescriptor);
-static void EndSPITransaction(void);
-
-
-/*
- * LoadCronJobList loads a list of periodic jobs.
- */
-List *
-LoadCronJobList(void)
-{
-	List *cronJobList = NIL;
-	int spiStatus PG_USED_FOR_ASSERTS_ONLY = 0;
-	StringInfoData query;
-
-	MemoryContext upperContext = CurrentMemoryContext, oldContext = NULL;
-
-	StartSPITransaction();
-
-	initStringInfo(&query);
-	appendStringInfo(&query,
-					 "SELECT job_name, cron_string, query, connection_string "
-					 "FROM cron.jobs");
-
-	pgstat_report_activity(STATE_RUNNING, query.data);
-
-	spiStatus = SPI_execute(query.data, false, 0);
-	Assert(spiStatus == SPI_OK_SELECT);
-
-	oldContext = MemoryContextSwitchTo(upperContext);
-
-	for (uint32 rowNumber = 0; rowNumber < SPI_processed; rowNumber++)
-	{
-		HeapTuple heapTuple = SPI_tuptable->vals[rowNumber];
-		CronJob *cronJob = TupleToCronJob(heapTuple,
-										  SPI_tuptable->tupdesc);
-		cronJobList = lappend(cronJobList, cronJob);
-	}
-
-	MemoryContextSwitchTo(oldContext);
-
-	pgstat_report_activity(STATE_IDLE, NULL);
-
-	EndSPITransaction();
-
-	return cronJobList;
-}
-
-
-/*
- * TupleToCronJob constructs a job description from a heap tuple obtained
- * via SPI.
- */
-CronJob *
-TupleToCronJob(HeapTuple heapTuple, TupleDesc tupleDescriptor)
-{
-	CronJob *cronJob = NULL;
-	bool isNull[4] = {false, false, false, false};
-
-	Datum jobNameDatum = SPI_getbinval(heapTuple, tupleDescriptor,
-									   TLIST_NUM_JOB_NAME, &isNull[0]);
-	Datum cronStringDatum = SPI_getbinval(heapTuple, tupleDescriptor,
-										  TLIST_NUM_CRON_STRING, &isNull[1]);
-	Datum queryDatum = SPI_getbinval(heapTuple, tupleDescriptor,
-									 TLIST_NUM_QUERY, &isNull[2]);
-	Datum connectionStringDatum = SPI_getbinval(heapTuple, tupleDescriptor,
-												TLIST_NUM_CONNECTION_STRING,
-												&isNull[3]);
-
-	cronJob = palloc0(sizeof(CronJob));
-	cronJob->jobName = TextDatumGetCString(jobNameDatum);
-	cronJob->cronString = TextDatumGetCString(cronStringDatum);
-	cronJob->query = TextDatumGetCString(queryDatum);
-	cronJob->connectionString = TextDatumGetCString(connectionStringDatum);
-
-	return cronJob;
-}
-
-
-/*
- * LogCronTaskResult logs the result of a cron task.
- */
-void
-LogCronTaskResult(char *jobName, int taskStatus)
-{
-	StringInfoData query;
-	int spiStatus PG_USED_FOR_ASSERTS_ONLY = 0;
-
-	StartSPITransaction();
-
-	initStringInfo(&query);
-	appendStringInfo(&query,
-					 "INSERT INTO cron.results "
-					 "(job_name, status) "
-					 "VALUES (%s,%d) "
-					 quote_literal_cstr(jobName),
-					 taskStatus);
-
-	pgstat_report_activity(STATE_RUNNING, query.data);
-
-	spiStatus = SPI_execute(query.data, false, 0);
-	Assert(spiStatus == SPI_OK_UPDATE);
-
-	pgstat_report_activity(STATE_IDLE, NULL);
-
-	EndSPITransaction();
-}
-
-
-/*
- * StartSPITransaction starts a transaction using SPI.
- */
-static void
-StartSPITransaction(void)
-{
-	SetCurrentStatementStartTimestamp();
-	StartTransactionCommand();
-	SPI_connect();
-	PushActiveSnapshot(GetTransactionSnapshot());
-}
-
-
-/*
- * EndSPITransaction finishes a transaction that was started using SPI.
- */
-static void
-EndSPITransaction(void)
-{
-	SPI_finish();
-	PopActiveSnapshot();
-	CommitTransactionCommand();
-}
diff --git a/src/misc.c b/src/misc.c
new file mode 100644
index 0000000..ee4025f
--- /dev/null
+++ b/src/misc.c
@@ -0,0 +1,816 @@
+/* Copyright 1988,1990,1993,1994 by Paul Vixie
+ * All rights reserved
+ *
+ * Distribute freely, except: don't remove my name from the source or
+ * documentation (don't take credit for my work), mark your changes (don't
+ * get me blamed for your possible bugs), don't alter or remove this
+ * notice.  May be sold if buildable source is provided to buyer.  No
+ * warrantee of any kind, express or implied, is included with this
+ * software; use at your own risk, responsibility for damages (if any) to
+ * anyone resulting from the use of this software rests entirely with the
+ * user.
+ *
+ * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
+ * I'll try to keep a version up to date.  I can be reached as follows:
+ * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
+ */
+
+/* vix 26jan87 [RCS has the rest of the log]
+ * vix 30dec86 [written]
+ */
+
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <time.h>
+#include <unistd.h>
+#include <sys/file.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <string.h>
+#include <fcntl.h>
+#include <grp.h>
+#ifdef WITH_AUDIT
+#include <libaudit.h>
+#endif
+#if defined(SYSLOG)
+# include <syslog.h>
+#endif
+#include "cron.h"
+
+
+#if defined(LOG_DAEMON) && !defined(LOG_CRON)
+#define LOG_CRON LOG_DAEMON
+#endif
+
+
+int
+strcmp_until(left, right, until)
+	char	*left;
+	char	*right;
+	int	until;
+{
+	register int	diff;
+
+	while (*left && *left != until && *left == *right) {
+		left++;
+		right++;
+	}
+
+	if ((*left=='\0' || *left == until) &&
+	    (*right=='\0' || *right == until)) {
+		diff = 0;
+	} else {
+		diff = *left - *right;
+	}
+
+	return diff;
+}
+
+
+/* strdtb(s) - delete trailing blanks in string 's' and return new length
+ */
+int
+strdtb(s)
+	char	*s;
+{
+	char	*x = s;
+
+	/* scan forward to the null
+	 */
+	while (*x)
+		x++;
+
+	/* scan backward to either the first character before the string,
+	 * or the last non-blank in the string, whichever comes first.
+	 */
+	do	{x--;}
+	while (x >= s && isspace(*x));
+
+	/* one character beyond where we stopped above is where the null
+	 * goes.
+	 */
+	*++x = '\0';
+
+	/* the difference between the position of the null character and
+	 * the position of the first character of the string is the length.
+	 */
+	return x - s;
+}
+
+
+int
+set_debug_flags(flags)
+	char	*flags;
+{
+	/* debug flags are of the form    flag[,flag ...]
+	 *
+	 * if an error occurs, print a message to stdout and return FALSE.
+	 * otherwise return TRUE after setting ERROR_FLAGS.
+	 */
+
+#if !DEBUGGING
+
+	printf("this program was compiled without debugging enabled\n");
+	return FALSE;
+
+#else /* DEBUGGING */
+
+	char	*pc = flags;
+
+	DebugFlags = 0;
+
+	while (*pc) {
+		char	**test;
+		int	mask;
+
+		/* try to find debug flag name in our list.
+		 */
+		for (	test = DebugFlagNames, mask = 1;
+			*test && strcmp_until(*test, pc, ',');
+			test++, mask <<= 1
+		    )
+			;
+
+		if (!*test) {
+			fprintf(stderr,
+				"unrecognized debug flag <%s> <%s>\n",
+				flags, pc);
+			return FALSE;
+		}
+
+		DebugFlags |= mask;
+
+		/* skip to the next flag
+		 */
+		while (*pc && *pc != ',')
+			pc++;
+		if (*pc == ',')
+			pc++;
+	}
+
+	if (DebugFlags) {
+		int	flag;
+
+		fprintf(stderr, "debug flags enabled:");
+
+		for (flag = 0;  DebugFlagNames[flag];  flag++)
+			if (DebugFlags & (1 << flag))
+				fprintf(stderr, " %s", DebugFlagNames[flag]);
+		fprintf(stderr, "\n");
+	}
+
+	return TRUE;
+
+#endif /* DEBUGGING */
+}
+
+
+void
+set_cron_uid()
+{
+#if defined(BSD) || defined(POSIX)
+	if (seteuid(ROOT_UID) < OK) {
+		perror("seteuid");
+		exit(ERROR_EXIT);
+	}
+#else
+	if (setuid(ROOT_UID) < OK) {
+		perror("setuid");
+		exit(ERROR_EXIT);
+	}
+#endif
+}
+
+
+void
+set_cron_cwd()
+{
+	struct stat	sb;
+	mode_t		um;
+	struct group	*gr;
+	
+	/* first check for CRONDIR ("/var/cron" or some such)
+	 */
+	if (stat(CRONDIR, &sb) < OK && errno == ENOENT) {
+		perror(CRONDIR);
+
+		/* crontab(1) running SGID crontab shouldn't attempt to create
+		 * directories */
+		if (getuid() != 0 )
+			exit(ERROR_EXIT);
+
+		um = umask(000);
+		if (OK == mkdir(CRONDIR, CRONDIR_MODE)) {
+			fprintf(stderr, "%s: created\n", CRONDIR);
+			stat(CRONDIR, &sb);
+		} else {
+			fprintf(stderr, "%s: mkdir: %s\n", CRONDIR,
+				strerror(errno));
+			exit(ERROR_EXIT);
+		}
+		(void) umask(um);
+	}
+	if (!(sb.st_mode & S_IFDIR)) {
+		fprintf(stderr, "'%s' is not a directory, bailing out.\n",
+			CRONDIR);
+		exit(ERROR_EXIT);
+	}
+	if (chdir(CRONDIR) < OK) {
+		fprintf(stderr, "%s: chdir: %s\n", CRONDIR, strerror(errno));
+		exit(ERROR_EXIT);
+	}
+
+	/* CRONDIR okay (now==CWD), now look at SPOOL_DIR ("tabs" or some such)
+	 */
+	if (stat(SPOOL_DIR, &sb) < OK && errno == ENOENT) {
+		perror(SPOOL_DIR);
+
+		/* crontab(1) running SGID crontab shouldn't attempt to create
+		 * directories */
+		if (getuid() != 0 )
+			exit(ERROR_EXIT);
+
+		um = umask(000);
+		if (OK == mkdir(SPOOL_DIR, SPOOL_DIR_MODE)) {
+			fprintf(stderr, "%s: created\n", SPOOL_DIR);
+		} else {
+			fprintf(stderr, "%s: mkdir: %s\n", SPOOL_DIR,
+				strerror(errno));
+			exit(ERROR_EXIT);
+		}
+		(void) umask(um);
+
+		if (!(gr = getgrnam(SPOOL_DIR_GROUP))) {
+			fprintf(stderr, "%s: getgrnam: %s\n", SPOOL_DIR,
+				strerror(errno));
+			exit(ERROR_EXIT);
+		}
+		if (OK == chown(SPOOL_DIR, -1, gr->gr_gid)) {
+			fprintf(stderr, "%s: chowned\n", SPOOL_DIR);
+				stat(SPOOL_DIR, &sb);
+		} else {
+			fprintf(stderr, "%s: chown: %s\n", SPOOL_DIR,
+			strerror(errno));
+			exit(ERROR_EXIT);
+		}
+	}
+	if (!(sb.st_mode & S_IFDIR)) {
+		fprintf(stderr, "'%s' is not a directory, bailing out.\n",
+			SPOOL_DIR);
+		exit(ERROR_EXIT);
+	}
+}
+
+
+/* acquire_daemonlock() - write our PID into /etc/crond.pid, unless
+ *	another daemon is already running, which we detect here.
+ *
+ * note: main() calls us twice; once before forking, once after.
+ *	we maintain static storage of the file pointer so that we
+ *	can rewrite our PID into the PIDFILE after the fork.
+ *
+ * it would be great if fflush() disassociated the file buffer.
+ */
+void
+acquire_daemonlock(closeflag)
+	int closeflag;
+{
+	static	FILE	*fp = NULL;
+
+	if (closeflag && fp) {
+		fclose(fp);
+		fp = NULL;
+		return;
+	}
+
+	if (!fp) {
+		char	pidfile[MAX_FNAME];
+		char	buf[MAX_TEMPSTR];
+		int	fd, otherpid;
+
+		(void) snprintf(pidfile, MAX_FNAME, PIDFILE, PIDDIR);
+		if ((-1 == (fd = open(pidfile, O_RDWR|O_CREAT, 0644)))
+		    || (NULL == (fp = fdopen(fd, "r+")))
+		    ) {
+			snprintf(buf, MAX_TEMPSTR, "can't open or create %s: %s",
+				pidfile, strerror(errno));
+			fprintf(stderr, "%s: %s\n", ProgramName, buf);
+			log_it("CRON", getpid(), "DEATH", buf);
+			exit(ERROR_EXIT);
+		}
+
+		if (flock(fd, LOCK_EX|LOCK_NB) < OK) {
+			int save_errno = errno;
+
+			fscanf(fp, "%d", &otherpid);
+			snprintf(buf, MAX_TEMPSTR, "can't lock %s, otherpid may be %d: %s",
+				pidfile, otherpid, strerror(save_errno));
+			fprintf(stderr, "%s: %s\n", ProgramName, buf);
+			log_it("CRON", getpid(), "DEATH", buf);
+			exit(ERROR_EXIT);
+		}
+		snprintf(buf, MAX_TEMPSTR, "pidfile fd = %d", fd);
+		log_it("CRON", getpid(), "INFO", buf);
+		(void) fcntl(fd, F_SETFD, 1);
+	}
+
+	rewind(fp);
+	fprintf(fp, "%d\n", getpid());
+	fflush(fp);
+	(void) ftruncate(fileno(fp), ftell(fp));
+
+	/* abandon fd and fp even though the file is open. we need to
+	 * keep it open and locked, but we don't need the handles elsewhere.
+	 */
+	
+}
+
+/* get_char(file) : like getc() but increment LineNumber on newlines
+ */
+int
+get_char(file)
+	FILE	*file;
+{
+	int	ch;
+
+	/*
+	 * Sneaky hack: we wrapped an in-memory buffer into a FILE*
+	 * to minimize changes to cron.c.
+	 *
+	 * This code replaces:
+	 * ch = getc(file);
+	 */
+	file_buffer *buffer = (file_buffer *) file;
+
+	if (buffer->unget_count > 0)
+	{
+		ch = buffer->unget_data[--buffer->unget_count];
+	}
+	else if (buffer->pointer == buffer->length)
+	{
+		ch = '\0';
+	}
+	else
+	{
+		ch = buffer->data[buffer->pointer++];
+	}
+
+	if (ch == '\n')
+		Set_LineNum(LineNumber + 1);
+	return ch;
+}
+
+
+/* unget_char(ch, file) : like ungetc but do LineNumber processing
+ */
+void
+unget_char(ch, file)
+	int	ch;
+	FILE	*file;
+{
+
+	/*
+	 * Sneaky hack: we wrapped an in-memory buffer into a FILE*
+	 * to minimize changes to cron.c.
+	 *
+	 * This code replaces:
+	 * ungetc(ch, file);
+	 */
+	file_buffer *buffer = (file_buffer *) file;
+
+	if (buffer->unget_count >= 1024)
+	{	
+		perror("ungetc limit exceeded");
+		exit(ERROR_EXIT);
+	}
+
+	buffer->unget_data[buffer->unget_count++] = ch;
+
+	if (ch == '\n')
+	       Set_LineNum(LineNumber - 1);
+}
+
+
+/* get_string(str, max, file, termstr) : like fgets() but
+ *		(1) has terminator string which should include \n
+ *		(2) will always leave room for the null
+ *		(3) uses get_char() so LineNumber will be accurate
+ *		(4) returns EOF or terminating character, whichever
+ */
+int
+get_string(string, size, file, terms)
+	char	*string;
+	int	size;
+	FILE	*file;
+	char	*terms;
+{
+	int	ch;
+
+	while (EOF != (ch = get_char(file)) && !strchr(terms, ch)) {
+		if (size > 1) {
+			*string++ = (char) ch;
+			size--;
+		}
+	}
+
+	if (size > 0)
+		*string = '\0';
+
+	return ch;
+}
+
+
+/* skip_comments(file) : read past comment (if any)
+ */
+void
+skip_comments(file)
+	FILE	*file;
+{
+	int	ch;
+
+	while (EOF != (ch = get_char(file))) {
+		/* ch is now the first character of a line.
+		 */
+
+		while (ch == ' ' || ch == '\t')
+			ch = get_char(file);
+
+		if (ch == EOF)
+			break;
+
+		/* ch is now the first non-blank character of a line.
+		 */
+
+		if (ch != '\n' && ch != '#')
+			break;
+
+		/* ch must be a newline or comment as first non-blank
+		 * character on a line.
+		 */
+
+		while (ch != '\n' && ch != EOF)
+			ch = get_char(file);
+
+		/* ch is now the newline of a line which we're going to
+		 * ignore.
+		 */
+	}
+	if (ch != EOF)
+		unget_char(ch, file);
+}
+
+
+/* int in_file(char *string, FILE *file)
+ *	return TRUE if one of the lines in file matches string exactly,
+ *	FALSE otherwise.
+ */
+static int
+in_file(string, file)
+	char *string;
+	FILE *file;
+{
+	char line[MAX_TEMPSTR];
+
+	rewind(file);
+	while (fgets(line, MAX_TEMPSTR, file)) {
+		if (line[0] != '\0')
+			line[strlen(line)-1] = '\0';
+		if (0 == strcmp(line, string))
+			return TRUE;
+	}
+	return FALSE;
+}
+
+
+/* int allowed(char *username)
+ *	returns TRUE if (ALLOW_FILE exists and user is listed)
+ *	or (DENY_FILE exists and user is NOT listed)
+ *	or (neither file exists but user=="root" so it's okay)
+ */
+int
+allowed(username)
+	char *username;
+{
+	static int	init = FALSE;
+	static FILE	*allow, *deny;
+	int     isallowed;
+
+        /* Root cannot be denied execution of cron jobs even if in the
+	 * 'DENY_FILE' so we return inmediately */
+        if (strcmp(username, ROOT_USER) == 0)
+                return (TRUE);
+
+	isallowed = FALSE;
+#if defined(ALLOW_ONLY_ROOT)
+	Debug(DMISC, "only root access is allowed")
+#else
+	if (!init) {
+		init = TRUE;
+#if defined(ALLOW_FILE) && defined(DENY_FILE)
+		allow = fopen(ALLOW_FILE, "r");
+		deny = fopen(DENY_FILE, "r");
+		Debug(DMISC, ("allow/deny enabled, %d/%d\n", !!allow, !!deny))
+#else
+		allow = NULL;
+		deny = NULL;
+#endif
+	}
+
+	if (allow) 
+		isallowed = in_file(username, allow);
+	else
+		isallowed = TRUE; /* Allow access if ALLOW_FILE does not exist */
+	if (deny && !allow)
+		isallowed = !in_file(username, deny);
+#endif
+
+#ifdef WITH_AUDIT
+       /* Log an audit message if the user is rejected */ 
+       if (isallowed == FALSE) {
+               int audit_fd = audit_open();
+               audit_log_user_message(audit_fd, AUDIT_USER_START, "cron deny",
+                       NULL, NULL, NULL, 0);
+               close(audit_fd);
+       }
+#endif
+	return isallowed;
+}
+
+
+void
+log_it(username, xpid, event, detail)
+	char	*username;
+	int	xpid;
+	char	*event;
+	char	*detail;
+{
+#if defined(LOG_FILE)
+	PID_T			pid = xpid;
+	char			*msg;
+	TIME_T			now = time((TIME_T) 0);
+	register struct tm	*t = localtime(&now);
+	int 			msg_size;
+#endif /*LOG_FILE*/
+
+
+#if defined(LOG_FILE)
+	/* we assume that MAX_TEMPSTR will hold the date, time, &punctuation.
+	 */
+	msg_size = strlen(username) + strlen(event) + strlen(detail) + MAX_TEMPSTR;
+	msg = malloc(msg_size);
+	if (msg == NULL) {
+	    /* damn, out of mem and we did not test that before... */
+	    fprintf(stderr, "%s: Run OUT OF MEMORY while %s\n",
+		    ProgramName, __FUNCTION__);
+	    return;
+	}
+	if (LogFD < OK) {
+		LogFD = open(LOG_FILE, O_WRONLY|O_APPEND|O_CREAT, 0600);
+		if (LogFD < OK) {
+			fprintf(stderr, "%s: %s: open: %s\n",
+				ProgramName, LOG_FILE, strerror(errno));
+		} else {
+			(void) fcntl(LogFD, F_SETFD, 1);
+		}
+	}
+
+	/* we have to snprintf() it because fprintf() doesn't always write
+	 * everything out in one chunk and this has to be atomically appended
+	 * to the log file.
+	 */
+	snprintf(msg, msg_size, "%s (%02d/%02d-%02d:%02d:%02d-%d) %s (%s)\n",
+		username,
+		t->tm_mon+1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec, pid,
+		event, detail);
+
+	/* we have to run strlen() because snprintf() returns (char*) on old BSD
+	 */
+	if (LogFD < OK || write(LogFD, msg, strlen(msg)) < OK) {
+		if (LogFD >= OK)
+			perror(LOG_FILE);
+		fprintf(stderr, "%s: can't write to log file\n", ProgramName);
+		write(STDERR, msg, strlen(msg));
+	}
+
+	free(msg);
+#endif /*LOG_FILE*/
+
+#if defined(SYSLOG)
+
+
+	    /* we don't use LOG_PID since the pid passed to us by
+	     * our client may not be our own.  therefore we want to
+	     * print the pid ourselves.
+	     */
+	    /* SteveG says: That comment is not consistent with the
+	       code, and makes no sense -- I suspect it's a remnant
+	       of a cut-n-paster... */
+# ifdef LOG_CRON
+	openlog(ProgramName, LOG_PID, LOG_CRON);
+# else
+	openlog(ProgramName, LOG_PID);
+# endif
+	  
+	syslog(LOG_INFO, "(%s) %s (%s)", username, event, detail);
+
+	closelog();
+#endif /*SYSLOG*/
+
+#if DEBUGGING
+	if (DebugFlags) {
+		fprintf(stderr, "log_it: (%s %d) %s (%s)\n",
+			username, xpid, event, detail);
+	}
+#endif
+}
+
+
+void
+log_close() {
+#if defined(LOG_FILE)
+	if (LogFD != ERR) {
+		close(LogFD);
+		LogFD = ERR;
+	}
+#endif
+#if defined(SYSLOG)
+	closelog();
+#endif
+}
+
+
+/* two warnings:
+ *	(1) this routine is fairly slow
+ *	(2) it returns a pointer to static storage
+ */
+char *
+first_word(s, t)
+	register char *s;	/* string we want the first word of */
+	register char *t;	/* terminators, implicitly including \0 */
+{
+	static char retbuf[2][MAX_TEMPSTR + 1];	/* sure wish C had GC */
+	static int retsel = 0;
+	register char *rb, *rp;
+
+	/* select a return buffer */
+	retsel = 1-retsel;
+	rb = &retbuf[retsel][0];
+	rp = rb;
+
+	/* skip any leading terminators */
+	while (*s && (NULL != strchr(t, *s))) {
+		s++;
+	}
+
+	/* copy until next terminator or full buffer */
+	while (*s && (NULL == strchr(t, *s)) && (rp < &rb[MAX_TEMPSTR])) {
+		*rp++ = *s++;
+	}
+
+	/* finish the return-string and return it */
+	*rp = '\0';
+	return rb;
+}
+
+
+/* warning:
+ *	heavily ascii-dependent.
+ */
+static void
+mkprint(dst, src, len)
+	register char *dst;
+	register unsigned char *src;
+	register int len;
+{
+	while (len-- > 0)
+	{
+		register unsigned char ch = *src++;
+
+		if (ch < ' ') {			/* control character */
+			*dst++ = '^';
+			*dst++ = ch + '@';
+		} else if (ch < 0177) {		/* printable */
+			*dst++ = ch;
+		} else if (ch == 0177) {	/* delete/rubout */
+			*dst++ = '^';
+			*dst++ = '?';
+		} else {			/* parity character */
+		    /* well, the following snprintf is paranoid, but that will
+		     * keep grep happy */
+		    snprintf(dst, 5, "\\%03o", ch);
+		    dst += 4;
+		}
+	}
+	*dst = '\0';
+}
+
+
+/* warning:
+ *	returns a pointer to malloc'd storage, you must call free yourself.
+ */
+char *
+mkprints(src, len)
+	register unsigned char *src;
+	register unsigned int len;
+{
+	register char *dst = malloc(len*4 + 1);
+
+	if (dst)
+		mkprint(dst, src, len);
+
+	return dst;
+}
+
+
+#ifdef MAIL_DATE
+/* Sat, 27 Feb 1993 11:44:51 -0800 (CST)
+ * 1234567890123456789012345678901234567
+ */
+char *
+arpadate(clock)
+	time_t *clock;
+{
+	static char ret[64];	/* zone name might be >3 chars */
+	time_t t = clock ? *clock : time(NULL);
+	struct tm *tm = localtime(&t);
+	char *qmark;
+	size_t len;
+        long gmtoff = get_gmtoff(&t, tm);
+        int hours = gmtoff / 3600;
+        int minutes = (gmtoff - (hours * 3600)) / 60;
+
+	if (minutes < 0)
+		minutes = -minutes;
+
+	/* Defensive coding (almost) never hurts... */
+	len = strftime(ret, sizeof(ret), "%a, %e %b %Y %T ????? (%Z)", tm);
+	if (len == 0) {
+		ret[0] = '?';
+		ret[1] = '\0';
+		return ret;
+	}
+	qmark = strchr(ret, '?');
+	if (qmark && len - (qmark - ret) >= 6) {
+		snprintf(qmark, 6, "% .2d%.2d", hours, minutes);
+		qmark[5] = ' ';
+	}
+	return ret;
+}
+#endif /*MAIL_DATE*/
+
+
+#ifdef HAVE_SAVED_UIDS
+static uid_t save_euid, save_egid;
+int swap_uids()
+{
+	save_euid = geteuid(); save_egid = getegid();
+	return (setegid(getgid()) || seteuid(getuid())) ? -1 : 0;
+}
+int swap_uids_back()
+{
+	return (setegid(save_egid) || seteuid(save_euid)) ? -1 : 0;
+}
+#else /*HAVE_SAVED_UIDS*/
+int swap_uids()
+{
+	return (setregid(getegid(), getgid()) || setreuid(geteuid(), getuid()))
+		? -1 : 0;
+}
+int swap_uids_back() { return swap_uids(); }
+#endif /*HAVE_SAVED_UIDS*/
+
+
+/* Return the offset from GMT in seconds (algorithm taken from sendmail).
+ *
+ * warning:
+ *	clobbers the static storage space used by localtime() and gmtime().
+ *	If the local pointer is non-NULL it *must* point to a local copy.
+ */
+#ifndef HAVE_TM_GMTOFF
+long get_gmtoff(time_t *clock, struct tm *local)
+{
+	struct tm gmt;
+	long offset;
+
+	gmt = *gmtime(clock);
+	if (local == NULL)
+		local = localtime(clock);
+
+	offset = (local->tm_sec - gmt.tm_sec) +
+	    ((local->tm_min - gmt.tm_min) * 60) +
+	    ((local->tm_hour - gmt.tm_hour) * 3600);
+
+	/* Timezone may cause year rollover to happen on a different day. */
+	if (local->tm_year < gmt.tm_year)
+		offset -= 24 * 3600;
+	else if (local->tm_year > gmt.tm_year)
+		offset += 24 * 3600;
+	else if (local->tm_yday < gmt.tm_yday)
+		offset -= 24 * 3600;
+	else if (local->tm_yday > gmt.tm_yday)
+		offset += 24 * 3600;
+
+	return (offset);
+}
+#endif /* HAVE_TM_GMTOFF */
diff --git a/src/pg_cron.c b/src/pg_cron.c
index a42b8b1..a050f32 100644
--- a/src/pg_cron.c
+++ b/src/pg_cron.c
@@ -10,9 +10,7 @@
  */
 
 #include "postgres.h"
-
-/* these are internal headers */
-#include "job_metadata.h"
+#include "fmgr.h"
 
 /* these are always necessary for a bgworker */
 #include "miscadmin.h"
@@ -24,66 +22,117 @@
 #include "storage/shmem.h"
 
 /* these headers are used by this particular worker's code */
-#include "fmgr.h"
+
+#define MAIN_PROGRAM
+#include "cron.h"
+
+#include "pg_cron.h"
+#include "cron_job.h"
+
+#include "poll.h"
+#include "sys/time.h"
+#include "sys/poll.h"
+#include "time.h"
+
+#include "access/genam.h"
+#include "access/heapam.h"
+#include "access/htup_details.h"
+#include "access/xact.h"
+#include "access/xlog.h"
+#include "catalog/indexing.h"
+#include "catalog/namespace.h"
+#include "commands/dbcommands.h"
+#include "commands/extension.h"
+#include "commands/sequence.h"
+#include "commands/trigger.h"
 #include "lib/stringinfo.h"
 #include "libpq-fe.h"
 #include "libpq/pqsignal.h"
-#include "sys/time.h"
+#include "mb/pg_wchar.h"
+#include "pgstat.h"
+#include "postmaster/postmaster.h"
 #include "utils/builtins.h"
+#include "utils/fmgroids.h"
+#include "utils/inval.h"
+#include "utils/lsyscache.h"
 #include "utils/memutils.h"
+#include "utils/rel.h"
+#include "utils/snapmgr.h"
+#include "utils/syscache.h"
+#include "utils/timestamp.h"
 #include "tcop/utility.h"
 
 
-typedef enum
-{
-	CRON_TASK_INITIAL = 0,
-	CRON_TASK_CONNECTING = 1,
-	CRON_TASK_SENDING = 2,
-	CRON_TASK_RUNNING = 3,
-	CRON_TASK_RECEIVING = 4
-	CRON_TASK_OK = 5,
-	CRON_TASK_ERROR = 6,
-	CRON_TASK_WAITING = 7
-	
-} CronTaskState;
-
-typedef struct CronTask
-{
-	CronJob *job;
-	CronTaskState state;
-	PGconn *connection;
-	bool readyToPoll;
-	PostgresPollingStatusType pollingStatus;
-	struct timeval nextEventTime;
+#define CRON_SCHEMA_NAME "cron"
+#define JOBS_TABLE_NAME "job"
+#define JOB_ID_INDEX_NAME "job_pkey"
+#define JOB_ID_SEQUENCE_NAME "cron.jobid_seq"
 
-} CronTask;
 
-
-void _PG_init(void);
-static void PgOctopusWorkerMain(Datum arg);
-static List * CreateCronTasks(List *cronJobList);
-static CronTask * CreateCronTask(CronJob *cronJob);
-static void DoCronTasks(List *taskList);
-static void ManageCronTask(CronTask *task, struct timeval currentTime);
-static int WaitForEvent(List *taskList);
-static int CompareTimes(struct timeval *leftTime, struct timeval *rightTime);
-static int SubtractTimes(struct timeval base, struct timeval subtract);
-static struct timeval AddTimeMillis(struct timeval base, uint32 additionalMs);
+PG_MODULE_MAGIC;
 
 
-PG_MODULE_MAGIC;
+void _PG_init(void);
+void _PG_fini(void);
+static void pg_cron_sigterm(SIGNAL_ARGS);
+static void pg_cron_sighup(SIGNAL_ARGS);
+static void PgCronWorkerMain(Datum arg);
+
+static void InvalidateJobCacheCallback(Datum argument, Oid relationId);
+static void InvalidateJobCache(void);
+static Oid CronJobRelationId(void);
+
+static void ReloadCronJobs(void);
+static List * LoadCronJobList(void);
+static CronJob * TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple);
+static bool PgCronHasBeenLoaded(void);
+
+static void StartAllPendingRuns(List *taskList, TimestampTz currentTime);
+static void StartPendingRuns(CronTask *task, ClockProgress clockProgress,
+							 TimestampTz lastMinute, TimestampTz currentTime);
+static int MinutesPassed(TimestampTz startTime, TimestampTz stopTime);
+static TimestampTz TimestampMinuteStart(TimestampTz time);
+static TimestampTz TimestampMinuteEnd(TimestampTz time);
+static bool ShouldRunTask(entry *schedule, TimestampTz currentMinute,
+						  bool doWild, bool doNonWild);
+
+static List * CurrentTaskList(void);
+static void WaitForCronTasks(List *taskList);
+static void PollForTasks(List *taskList);
+static void ManageCronTasks(List *taskList, TimestampTz currentTime);
+static void ManageCronTask(CronTask *task, TimestampTz currentTime);
+
+static HTAB * CreateCronJobHash(void);
+static HTAB * CreateCronTaskHash(void);
+static CronJob * GetCronJob(int64 jobId);
+static CronTask * GetCronTask(int64 jobId);
+static void InitializeCronTask(CronTask *task, int64 jobId);
 
 
 /* flags set by signal handlers */
-static volatile sig_atomic_t got_sighup = false;
 static volatile sig_atomic_t got_sigterm = false;
 
+static MemoryContext CronJobContext = NULL;
+static MemoryContext CronTaskContext = NULL;
+static HTAB *CronJobHash = NULL;
+static HTAB *CronTaskHash = NULL;
+static bool CronJobCacheValid = false;
+static Oid CachedCronJobRelationId = InvalidOid;
+static int64 RunCount = 0;
+
+static char *CronTableDatabaseName = "postgres";
+static int CronTaskStartTimeout = 10000; /* maximum connection time */
+static const int MaxWait = 1000; /* maximum time in ms that poll() can block */
+
+
+/* declarations for dynamic loading */
+PG_FUNCTION_INFO_V1(cron_schedule);
+PG_FUNCTION_INFO_V1(cron_unschedule);
+PG_FUNCTION_INFO_V1(cron_job_cache_invalidate);
+
 
 /*
- * Entrypoint of this module.
- *
- * We register more than one worker process here, to demonstrate how that can
- * be done.
+ * _PG_init gets called when the extension is loaded.
  */
 void
 _PG_init(void)
@@ -92,14 +141,29 @@ _PG_init(void)
 
 	if (!process_shared_preload_libraries_in_progress)
 	{
-		return;
+		ereport(ERROR, (errmsg("pg_cron can only be loaded via shared_preload_libraries"),
+						errhint("Add pg_cron to shared_preload_libraries configuration "
+								"variable in postgresql.conf in master and workers.")));
 	}
 
+	DefineCustomStringVariable(
+		"cron.database_name",
+		gettext_noop("Database in which pg_cron metadata is kept."),
+		NULL,
+		&CronTableDatabaseName,
+		"postgres",
+		PGC_POSTMASTER,
+		GUC_SUPERUSER_ONLY,
+		NULL, NULL, NULL);
+
+	/* watch for invalidation events */
+	CacheRegisterRelcacheCallback(InvalidateJobCacheCallback, (Datum) 0);
+
 	/* set up common data for all our workers */
 	worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
 	worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
 	worker.bgw_restart_time = BGW_NEVER_RESTART;
-	worker.bgw_main = PgOctopusWorkerMain;
+	worker.bgw_main = PgCronWorkerMain;
 	worker.bgw_main_arg = Int32GetDatum(0);
 	worker.bgw_notify_pid = 0;
 	sprintf(worker.bgw_library_name, "pg_cron");
@@ -117,40 +181,29 @@ _PG_init(void)
 static void
 pg_cron_sigterm(SIGNAL_ARGS)
 {
-	int save_errno = errno;
-
 	got_sigterm = true;
-	SetLatch(MyLatch);
-
-	errno = save_errno;
 }
 
 
 /*
  * Signal handler for SIGHUP
- *		Set a flag to tell the main loop to reread the config file, and set
- *		our latch to wake it up.
+ *		Set a flag to tell the main loop to reload the cron jobs.
  */
 static void
 pg_cron_sighup(SIGNAL_ARGS)
 {
-	int save_errno = errno;
-
-	got_sighup = true;
-	SetLatch(MyLatch);
-
-	errno = save_errno;
+	CronJobCacheValid = false;
 }
 
 
 /*
- * PgOctopusWorkerMain is the main entry-point for the background worker
+ * PgCronWorkerMain is the main entry-point for the background worker
  * that performs tasks.
  */
 static void
-PgOctopusWorkerMain(Datum arg)
+PgCronWorkerMain(Datum arg)
 {
-	MemoryContext taskContext = NULL;
+	MemoryContext CronLoopContext = NULL;
 
 	/* Establish signal handlers before unblocking signals. */
 	pqsignal(SIGHUP, pg_cron_sighup);
@@ -161,167 +214,848 @@ PgOctopusWorkerMain(Datum arg)
 	BackgroundWorkerUnblockSignals();
 
 	/* Connect to our database */
-	BackgroundWorkerInitializeConnection("postgres", NULL);
+	BackgroundWorkerInitializeConnection(CronTableDatabaseName, NULL);
+
+	CronJobContext = AllocSetContextCreate(CurrentMemoryContext,
+										   "pg_cron job context",
+										   ALLOCSET_DEFAULT_MINSIZE,
+										   ALLOCSET_DEFAULT_INITSIZE,
+										   ALLOCSET_DEFAULT_MAXSIZE);
 
-	taskContext = AllocSetContextCreate(CurrentMemoryContext,
-											   "CronTask context",
-											   ALLOCSET_DEFAULT_MINSIZE,
-											   ALLOCSET_DEFAULT_INITSIZE,
-											   ALLOCSET_DEFAULT_MAXSIZE);
+	CronTaskContext = AllocSetContextCreate(CurrentMemoryContext,
+											"pg_cron task context",
+											ALLOCSET_DEFAULT_MINSIZE,
+											ALLOCSET_DEFAULT_INITSIZE,
+											ALLOCSET_DEFAULT_MAXSIZE);
 
-	MemoryContextSwitchTo(taskContext);
+	CronLoopContext = AllocSetContextCreate(CurrentMemoryContext,
+											"pg_cron loop context",
+											ALLOCSET_DEFAULT_MINSIZE,
+											ALLOCSET_DEFAULT_INITSIZE,
+											ALLOCSET_DEFAULT_MAXSIZE);
+
+	CronJobHash = CreateCronJobHash();
+	CronTaskHash = CreateCronTaskHash();
 
 	elog(LOG, "pg_cron scheduler started");
 
-	/*
-	 * Main loop: do this until the SIGTERM handler tells us to terminate
-	 */
+	MemoryContextSwitchTo(CronLoopContext);
+
 	while (!got_sigterm)
 	{
-		List *cronJobList = NIL;
 		List *taskList = NIL;
+		TimestampTz currentTime = 0;
 
-		cronJobList = LoadCronJobList();
-		taskList = CreateCronTasks(cronJobList);
-
-		DoCronTasks(taskList);
+		AcceptInvalidationMessages();
 
-		MemoryContextReset(taskContext);
-
-		if (got_sighup)
+		if (!CronJobCacheValid)
 		{
-			got_sighup = false;
-			ProcessConfigFile(PGC_SIGHUP);
+			ReloadCronJobs();
 		}
+
+		taskList = CurrentTaskList();
+		currentTime = GetCurrentTimestamp();
+
+		StartAllPendingRuns(taskList, currentTime);
+
+		WaitForCronTasks(taskList);
+		ManageCronTasks(taskList, currentTime);
+
+		MemoryContextReset(CronLoopContext);
 	}
 
-	elog(LOG, "pg_cron scheduler exiting");
+	elog(LOG, "pg_cron scheduler shutting down");
 
 	proc_exit(0);
 }
 
 
 /*
- * CreateCronTasks creates a list of tasks from a list of job
- * descriptions.
+ * cluster_schedule schedules a cron job.
  */
-static List *
-CreateCronTasks(List *cronJobList)
+Datum
+cron_schedule(PG_FUNCTION_ARGS)
 {
-	List *taskList = NIL;
-	ListCell *cronJobCell = NULL;
+	text *scheduleText = PG_GETARG_TEXT_P(0);
+	text *commandText = PG_GETARG_TEXT_P(1);
+
+	char *schedule = text_to_cstring(scheduleText);
+	char *command = text_to_cstring(commandText);
+	entry *parsedSchedule = NULL;
+
+	int64 jobId = 0;
+	Datum jobIdDatum = 0;
+	Datum jobIdSequenceName = 0;
+
+	Oid cronSchemaId = InvalidOid;
+	Oid cronJobsRelationId = InvalidOid;
 
-	foreach(cronJobCell, cronJobList)
+	Relation cronJobsTable = NULL;
+	TupleDesc tupleDescriptor = NULL;
+	HeapTuple heapTuple = NULL;
+	Datum values[Natts_cron_job];
+	bool isNulls[Natts_cron_job];
+
+	Oid userId = GetUserId();
+	char *userName = GetUserNameFromId(userId, false);
+
+	parsedSchedule = parse_cron_entry(schedule);
+	if (parsedSchedule == NULL)
 	{
-		CronJob *cronJob = (CronJob *) lfirst(cronJobCell);
-		CronTask *task = CreateCronTask(cronJob);
-		taskList = lappend(taskList, task);
+		free_entry(parsedSchedule);
+
+		ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+						errmsg("invalid schedule: %s", schedule)));
 	}
 
-	return taskList;
+	free_entry(parsedSchedule);
+
+	/* form new job tuple */
+	memset(values, 0, sizeof(values));
+	memset(isNulls, false, sizeof(isNulls));
+
+	jobIdSequenceName = CStringGetTextDatum(JOB_ID_SEQUENCE_NAME);
+	jobIdDatum = DirectFunctionCall1(nextval, jobIdSequenceName);
+	jobId = DatumGetInt64(jobIdDatum);
+
+	values[Anum_cron_job_jobid - 1] = jobIdDatum;
+	values[Anum_cron_job_schedule - 1] = CStringGetTextDatum(schedule);
+	values[Anum_cron_job_command - 1] = CStringGetTextDatum(command);
+	values[Anum_cron_job_nodename - 1] = CStringGetTextDatum("localhost");
+	values[Anum_cron_job_nodeport - 1] = Int32GetDatum(PostPortNumber);
+	values[Anum_cron_job_database - 1] = CStringGetTextDatum(CronTableDatabaseName);
+	values[Anum_cron_job_username - 1] = CStringGetTextDatum(userName);
+
+	cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
+	cronJobsRelationId = get_relname_relid(JOBS_TABLE_NAME, cronSchemaId);
+
+	/* open jobs relation and insert new tuple */
+	cronJobsTable = heap_open(cronJobsRelationId, RowExclusiveLock);
+
+	tupleDescriptor = RelationGetDescr(cronJobsTable);
+	heapTuple = heap_form_tuple(tupleDescriptor, values, isNulls);
+
+	simple_heap_insert(cronJobsTable, heapTuple);
+	CatalogUpdateIndexes(cronJobsTable, heapTuple);
+	CommandCounterIncrement();
+
+	/* close relation and invalidate previous cache entry */
+	heap_close(cronJobsTable, RowExclusiveLock);
+
+	InvalidateJobCache();
+
+	PG_RETURN_INT64(jobId);
 }
 
 
 /*
- * CreateCronTask creates a task from a job description.
+ * cluster_unschedule removes a cron job.
  */
-static CronTask *
-CreateCronTask(CronJob *cronJob)
+Datum
+cron_unschedule(PG_FUNCTION_ARGS)
+{
+	int64 jobId = PG_GETARG_INT64(0);
+
+	Oid cronSchemaId = InvalidOid;
+	Oid cronJobsRelationId = InvalidOid;
+	Oid cronJobIndexId = InvalidOid;
+
+	Relation cronJobsTable = NULL;
+	SysScanDesc scanDescriptor = NULL;
+	ScanKeyData scanKey[1];
+	int scanKeyCount = 1;
+	bool indexOK = true;
+	HeapTuple heapTuple = NULL;
+
+
+	cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
+	cronJobsRelationId = get_relname_relid(JOBS_TABLE_NAME, cronSchemaId);
+	cronJobIndexId = get_relname_relid(JOB_ID_INDEX_NAME, cronSchemaId);
+
+	cronJobsTable = heap_open(CronJobRelationId(), RowExclusiveLock);
+
+	ScanKeyInit(&scanKey[0], Anum_cron_job_jobid,
+				BTEqualStrategyNumber, F_INT8EQ, Int64GetDatum(jobId));
+
+	scanDescriptor = systable_beginscan(cronJobsTable,
+										cronJobIndexId, indexOK,
+										NULL, scanKeyCount, scanKey);
+
+	heapTuple = systable_getnext(scanDescriptor);
+	if (!HeapTupleIsValid(heapTuple))
+	{
+		ereport(ERROR, (errmsg("could not find valid entry for job "
+							   UINT64_FORMAT, jobId)));
+	}
+
+	simple_heap_delete(cronJobsTable, &heapTuple->t_self);
+	CommandCounterIncrement();
+
+	systable_endscan(scanDescriptor);
+	heap_close(cronJobsTable, RowExclusiveLock);
+
+	InvalidateJobCache();
+
+	PG_RETURN_BOOL(true);
+}
+
+
+/*
+ * cron_job_cache_invalidate invalidates the job cache in response to
+ * a trigger.
+ */
+Datum
+cron_job_cache_invalidate(PG_FUNCTION_ARGS)
+{
+	if (!CALLED_AS_TRIGGER(fcinfo))
+	{
+		ereport(ERROR, (errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),
+						errmsg("must be called as trigger")));
+	}
+
+	InvalidateJobCache();
+
+	PG_RETURN_DATUM(PointerGetDatum(NULL));
+}
+
+
+/*
+ * Invalidate job cache ensures the job cache is reloaded on the next
+ * iteration of pg_cron.
+ */
+static void
+InvalidateJobCache(void)
+{
+	HeapTuple classTuple = NULL;
+
+	classTuple = SearchSysCache1(RELOID, ObjectIdGetDatum(CronJobRelationId()));
+	if (HeapTupleIsValid(classTuple))
+	{
+		CacheInvalidateRelcacheByTuple(classTuple);
+		ReleaseSysCache(classTuple);
+	}
+}
+
+
+/*
+ * InvalidateJobCacheCallback invalidates the job cache in response to
+ * an invalidation event.
+ */
+static void
+InvalidateJobCacheCallback(Datum argument, Oid relationId)
+{
+	if (relationId == CachedCronJobRelationId ||
+		CachedCronJobRelationId == InvalidOid)
+	{
+		CronJobCacheValid = false;
+		CachedCronJobRelationId = InvalidOid;
+	}
+}
+
+
+/*
+ * CachedCronJobRelationId returns a cached oid of the cron.job relation.
+ */
+static Oid
+CronJobRelationId(void)
 {
+	if (CachedCronJobRelationId == InvalidOid)
+	{
+		Oid cronSchemaId = get_namespace_oid(CRON_SCHEMA_NAME, false);
+
+		CachedCronJobRelationId = get_relname_relid(JOBS_TABLE_NAME, cronSchemaId);
+	}
+
+	return CachedCronJobRelationId;
+}
+
+
+/*
+ * ReloadCronJobs reloads the cron jobs from the cron.job table.
+ * If a job that has an active task has been removed, the task
+ * is marked as inactive by this function.
+ */
+static void
+ReloadCronJobs(void)
+{
+	List *jobList = NIL;
+	ListCell *jobCell = NULL;
 	CronTask *task = NULL;
-	struct timeval invalidTime = {0, 0};
+	HASH_SEQ_STATUS status;
 
-	task = palloc0(sizeof(CronTask));
-	task->job = cronJob;
-	task->state = CRON_TASK_INITIAL;
-	task->connection = NULL;
-	task->nextEventTime = invalidTime;
+	/* destroy old job hash */
+	MemoryContextResetAndDeleteChildren(CronJobContext);
 
-	return task;
+	CronJobHash = CreateCronJobHash();
+
+	hash_seq_init(&status, CronTaskHash);
+
+	/* mark all tasks as inactive */
+	while ((task = hash_seq_search(&status)) != NULL)
+	{
+		task->isActive = false;
+	}
+
+	jobList = LoadCronJobList();
+
+	/* mark tasks that still have a job as active */
+	foreach(jobCell, jobList)
+	{
+		CronJob *job = (CronJob *) lfirst(jobCell);
+
+		CronTask *task = GetCronTask(job->jobId);
+		task->isActive = true;
+	}
+
+	CronJobCacheValid = true;
+}
+
+
+/*
+ * LoadCronJobList loads the current list of jobs from the
+ * cron.job table and adds each job to the CronJobHash.
+ */
+static List *
+LoadCronJobList(void)
+{
+	List *jobList = NIL;
+
+	Relation cronJobTable = NULL;
+
+	SysScanDesc scanDescriptor = NULL;
+	ScanKeyData scanKey[1];
+	int scanKeyCount = 0;
+	HeapTuple heapTuple = NULL;
+	TupleDesc tupleDescriptor = NULL;
+
+	SetCurrentStatementStartTimestamp();
+	StartTransactionCommand();
+	PushActiveSnapshot(GetTransactionSnapshot());
+
+	/*
+	 * If the pg_cron extension has not been created yet or
+	 * we are on a hot standby, the job table is treated as
+	 * being empty.
+	 */
+	if (!PgCronHasBeenLoaded() || RecoveryInProgress())
+	{
+		PopActiveSnapshot();
+		CommitTransactionCommand();
+		pgstat_report_activity(STATE_IDLE, NULL);
+
+		return NIL;
+	}
+
+	cronJobTable = heap_open(CronJobRelationId(), AccessShareLock);
+
+	scanDescriptor = systable_beginscan(cronJobTable,
+										InvalidOid, false,
+										NULL, scanKeyCount, scanKey);
+
+	tupleDescriptor = RelationGetDescr(cronJobTable);
+
+	heapTuple = systable_getnext(scanDescriptor);
+	while (HeapTupleIsValid(heapTuple))
+	{
+		MemoryContext oldContext = NULL;
+		CronJob *job = NULL;
+
+		oldContext = MemoryContextSwitchTo(CronJobContext);
+
+		job = TupleToCronJob(tupleDescriptor, heapTuple);
+		jobList = lappend(jobList, job);
+
+		MemoryContextSwitchTo(oldContext);
+
+		heapTuple = systable_getnext(scanDescriptor);
+	}
+
+	systable_endscan(scanDescriptor);
+	heap_close(cronJobTable, AccessShareLock);
+
+	PopActiveSnapshot();
+	CommitTransactionCommand();
+	pgstat_report_activity(STATE_IDLE, NULL);
+
+	return jobList;
+}
+
+
+/*
+ * TupleToCronJob takes a heap tuple and converts it into a CronJob
+ * struct.
+ */
+static CronJob *
+TupleToCronJob(TupleDesc tupleDescriptor, HeapTuple heapTuple)
+{
+	CronJob *job = NULL;
+	int64 jobKey = 0;
+	bool isNull = false;
+	bool isPresent = false;
+	entry *parsedSchedule = NULL;
+
+	Datum jobId = heap_getattr(heapTuple, Anum_cron_job_jobid,
+							   tupleDescriptor, &isNull);
+	Datum schedule = heap_getattr(heapTuple, Anum_cron_job_schedule,
+								  tupleDescriptor, &isNull);
+	Datum command = heap_getattr(heapTuple, Anum_cron_job_command,
+								 tupleDescriptor, &isNull);
+	Datum nodeName = heap_getattr(heapTuple, Anum_cron_job_nodename,
+								  tupleDescriptor, &isNull);
+	Datum nodePort = heap_getattr(heapTuple, Anum_cron_job_nodeport,
+								  tupleDescriptor, &isNull);
+	Datum database = heap_getattr(heapTuple, Anum_cron_job_database,
+								  tupleDescriptor, &isNull);
+	Datum userName = heap_getattr(heapTuple, Anum_cron_job_username,
+								  tupleDescriptor, &isNull);
+
+	Assert(!HeapTupleHasNulls(heapTuple));
+
+	jobKey = DatumGetUInt32(jobId);
+	job = hash_search(CronJobHash, &jobKey, HASH_ENTER, &isPresent);
+
+	job->jobId = DatumGetUInt32(jobId);
+	job->scheduleText = TextDatumGetCString(schedule);
+	job->command = TextDatumGetCString(command);
+	job->nodeName = TextDatumGetCString(nodeName);
+	job->nodePort = DatumGetUInt32(nodePort);
+	job->userName = TextDatumGetCString(userName);
+	job->database = TextDatumGetCString(database);
+
+	parsedSchedule = parse_cron_entry(job->scheduleText);
+	if (parsedSchedule != NULL)
+	{
+		/* copy the schedule and free the allocated memory immediately */
+
+		job->schedule = *parsedSchedule;
+		free_entry(parsedSchedule);
+	}
+	else
+	{
+		elog(LOG, "invalid pg_cron schedule for job %ld: %s", jobId, job->scheduleText);
+	}
+
+	return job;
+}
+
+
+/*
+ * PgCronHasBeenLoaded returns true if the pg_cron extension has been created
+ * in the current database and the extension script has been executed. Otherwise,
+ * it returns false. The result is cached as this is called very frequently.
+ */
+static bool
+PgCronHasBeenLoaded(void)
+{
+	bool extensionLoaded = false;
+	bool extensionPresent = false;
+	bool extensionScriptExecuted = true;
+
+	Oid extensionOid = get_extension_oid("pg_cron", true);
+	if (extensionOid != InvalidOid)
+	{
+		extensionPresent = true;
+	}
+
+	if (extensionPresent)
+	{
+		/* check if PgCron extension objects are still being created */
+		if (creating_extension && CurrentExtensionObject == extensionOid)
+		{
+			extensionScriptExecuted = false;
+		}
+	}
+
+	extensionLoaded = extensionPresent && extensionScriptExecuted;
+
+	return extensionLoaded;
 }
 
 
 /*
- * DoCronTasks performs the given tasks.
+ * StartPendingRuns goes through the list of tasks and kicks of
+ * runs for tasks that should start, taking clock changes into
+ * into consideration.
  */
 static void
-DoCronTasks(List *taskList)
+StartAllPendingRuns(List *taskList, TimestampTz currentTime)
 {
-	while (!got_sigterm)
+	static TimestampTz lastMinute = 0;
+
+	int minutesPassed = 0;
+	ListCell *taskCell = NULL;
+	ClockProgress clockProgress;
+
+	if (lastMinute == 0)
+	{
+		lastMinute = TimestampMinuteStart(currentTime);
+	}
+
+	minutesPassed = MinutesPassed(lastMinute, currentTime);
+	if (minutesPassed == 0)
+	{
+		/* wait for new minute */
+		return;
+	}
+
+	/* use Vixie cron logic for clock jumps */
+	if (minutesPassed > (3*MINUTE_COUNT))
+	{
+		/* clock jumped forward by more than 3 hours */
+		clockProgress = CLOCK_CHANGE;
+	}
+	else if (minutesPassed > 5)
+	{
+		/* clock went forward by more than 5 minutes (DST?) */
+		clockProgress = CLOCK_JUMP_FORWARD;
+	}
+	else if (minutesPassed > 0)
+	{
+		/* clock went forward by 1-5 minutes */
+		clockProgress = CLOCK_PROGRESSED;
+	}
+	else if (minutesPassed > -(3*MINUTE_COUNT))
+	{
+		/* clock jumped backwards by less than 3 hours (DST?) */
+		clockProgress = CLOCK_JUMP_BACKWARD;
+	}
+	else
+	{
+		/* clock jumped backwards 3 hours or more */
+		clockProgress = CLOCK_CHANGE;
+	}
+
+	foreach(taskCell, taskList)
+	{
+		CronTask *task = (CronTask *) lfirst(taskCell);
+
+		StartPendingRuns(task, clockProgress, lastMinute, currentTime);
+	}
+
+	/*
+	 * If the clock jump backwards then we avoid repeating the fixed-time
+	 * tasks by preserving the last minute from before the clock jump,
+	 * until the clock has caught up (clockProgress will be
+	 * CLOCK_JUMP_BACKWARD until then).
+	 */
+	if (clockProgress != CLOCK_JUMP_BACKWARD)
 	{
-		int pendingCheckCount = 0;
-		struct timeval currentTime = {0, 0};
-		ListCell *taskCell = NULL;
+		lastMinute = TimestampMinuteStart(currentTime);
+	}
+}
+
+
+
+/*
+ * StartPendingRuns kicks off pending runs for a task if it
+ * should start, taking clock changes into consideration.
+ */
+static void
+StartPendingRuns(CronTask *task, ClockProgress clockProgress,
+				 TimestampTz lastMinute, TimestampTz currentTime)
+{
+	CronJob *cronJob = GetCronJob(task->jobId);
+	entry *schedule = &cronJob->schedule;
+	TimestampTz virtualTime = lastMinute;
+	TimestampTz currentMinute = TimestampMinuteStart(currentTime);
 
-		gettimeofday(&currentTime, NULL);
 
-		foreach(taskCell, taskList)
+	switch (clockProgress)
+	{
+		case CLOCK_PROGRESSED:
 		{
-			CronTask *task = (CronTask *) lfirst(taskCell);
+			/*
+			 * case 1: minutesPassed is a small positive number
+			 * run jobs for each virtual minute until caught up.
+			 */
+
+			do
+			{
+				virtualTime = TimestampTzPlusMilliseconds(virtualTime,
+														  60*1000);
 
-			ManageCronTask(task, currentTime);
+				if (ShouldRunTask(schedule, virtualTime, true, true))
+				{
+					task->pendingRunCount += 1;
+				}
+			}
+			while (virtualTime < currentMinute);
 
-			if (task->state != CRON_TASK_OK &&
-				task->state != CRON_TASK_DEAD)
+			break;
+		}
+
+		case CLOCK_JUMP_FORWARD:
+		{
+			/*
+			 * case 2: minutesPassed is a medium-sized positive number,
+			 * for example because we went to DST run wildcard
+			 * jobs once, then run any fixed-time jobs that would
+			 * otherwise be skipped if we use up our minute
+			 * (possible, if there are a lot of jobs to run) go
+			 * around the loop again so that wildcard jobs have
+			 * a chance to run, and we do our housekeeping
+			 */
+
+			/* run fixed-time jobs for each minute missed */
+			do
+			{
+				virtualTime = TimestampTzPlusMilliseconds(virtualTime,
+														  60*1000);
+
+				if (ShouldRunTask(schedule, virtualTime, false, true))
+				{
+					task->pendingRunCount += 1;
+				}
+
+			} while (virtualTime < currentMinute);
+
+			/* run wildcard jobs for current minute */
+			if (ShouldRunTask(schedule, currentMinute, true, false))
 			{
-				pendingCheckCount++;
+				task->pendingRunCount += 1;
 			}
+
+			break;
 		}
-		if (pendingCheckCount == 0)
+
+		case CLOCK_JUMP_BACKWARD:
 		{
+			/*
+			 * case 3: timeDiff is a small or medium-sized
+			 * negative num, eg. because of DST ending just run
+			 * the wildcard jobs. The fixed-time jobs probably
+			 * have already run, and should not be repeated
+			 * virtual time does not change until we are caught up
+			 */
+
+			if (ShouldRunTask(schedule, currentMinute, true, false))
+			{
+				task->pendingRunCount += 1;
+			}
+
 			break;
 		}
 
-		WaitForEvent(taskList);
+		default:
+		{
+			/*
+			 * other: time has changed a *lot*, skip over any
+			 * intermediate fixed-time jobs and go back to
+			 * normal operation.
+			 */
+			if (ShouldRunTask(schedule, currentMinute, true, true))
+			{
+				task->pendingRunCount += 1;
+			}
+		}
 	}
 }
 
 
 /*
- * WaitForEvent sleeps until a time-based or I/O event occurs in any of the jobs. 
+ * MinutesPassed returns the number of minutes between startTime and
+ * stopTime rounded down to the closest integer.
  */
 static int
-WaitForEvent(List *taskList)
+MinutesPassed(TimestampTz startTime, TimestampTz stopTime)
+{
+	int microsPassed = 0;
+	long secondsPassed = 0;
+	int minutesPassed = 0;
+
+	TimestampDifference(startTime, stopTime,
+						&secondsPassed, &microsPassed);
+
+	minutesPassed = secondsPassed / 60;
+
+	return minutesPassed;
+}
+
+
+/*
+ * TimestampMinuteEnd returns the timestamp at the start of the
+ * current minute for the given time.
+ */
+static TimestampTz
+TimestampMinuteStart(TimestampTz time)
+{
+	TimestampTz result = 0;
+
+#ifdef HAVE_INT64_TIMESTAMP
+	result = time - time % 60000000;
+#else
+	result = (long) time - (long) time % 60;
+#endif
+
+	return result;
+}
+
+
+/*
+ * TimestampMinuteEnd returns the timestamp at the start of the
+ * next minute from the given time.
+ */
+static TimestampTz
+TimestampMinuteEnd(TimestampTz time)
+{
+	TimestampTz result = TimestampMinuteStart(time);
+
+#ifdef HAVE_INT64_TIMESTAMP
+	result += 60000000;
+#else
+	result += 60;
+#endif
+
+	return result;
+}
+
+
+/*
+ * ShouldRunTask returns whether a job should run in the current
+ * minute according to its schedule.
+ */
+static bool
+ShouldRunTask(entry *schedule, TimestampTz currentTime, bool doWild,
+			  bool doNonWild)
+{
+	time_t currentTime_t = timestamptz_to_time_t(currentTime);
+	struct tm *tm = gmtime(&currentTime_t);
+
+	int minute = tm->tm_min -FIRST_MINUTE;
+	int hour = tm->tm_hour -FIRST_HOUR;
+	int dayOfMonth = tm->tm_mday -FIRST_DOM;
+	int month = tm->tm_mon +1 -FIRST_MONTH;
+	int dayOfWeek = tm->tm_wday -FIRST_DOW;
+
+	if (bit_test(schedule->minute, minute) &&
+	    bit_test(schedule->hour, hour) &&
+	    bit_test(schedule->month, month) &&
+	    ( ((schedule->flags & DOM_STAR) || (schedule->flags & DOW_STAR))
+	      ? (bit_test(schedule->dow,dayOfWeek) && bit_test(schedule->dom,dayOfMonth))
+	      : (bit_test(schedule->dow,dayOfWeek) || bit_test(schedule->dom,dayOfMonth)))) {
+		if ((doNonWild && !(schedule->flags & (MIN_STAR|HR_STAR)))
+		    || (doWild && (schedule->flags & (MIN_STAR|HR_STAR))))
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+
+/*
+ * CurrentTaskList extracts the current list of tasks from the
+ * cron task hash.
+ */
+static List *
+CurrentTaskList(void)
+{
+	List *taskList = NIL;
+	CronTask *task = NULL;
+	HASH_SEQ_STATUS status;
+
+	hash_seq_init(&status, CronTaskHash);
+
+	while ((task = hash_seq_search(&status)) != NULL)
+	{
+		taskList = lappend(taskList, task);
+	}
+
+	return taskList;
+}
+
+
+/*
+ * WaitForCronTasks blocks waiting for any active task for at most
+ * 1 second.
+ */
+static void
+WaitForCronTasks(List *taskList)
 {
-	ListCell *taskCell = NULL;
 	int taskCount = list_length(taskList);
-	int taskIndex = 0;
-	struct timeval currentTime = {0, 0};
-	struct timeval nextEventTime = {0, 0};
+
+	if (taskCount > 0)
+	{
+		PollForTasks(taskList);
+	}
+	else
+	{
+		/* wait for new jobs */
+		pg_usleep(MaxWait*1000L);
+	}
+}
+
+
+/*
+ * PollForTasks calls poll() for the sockets of all tasks. It checks for
+ * read or write events based on the pollingStatus of the task.
+ */
+static void
+PollForTasks(List *taskList)
+{
+	TimestampTz currentTime = 0;
+	TimestampTz nextEventTime = 0;
 	int pollTimeout = 0;
+	long waitSeconds = 0;
+	int waitMicros = 0;
 	struct pollfd *pollFDs = NULL;
 	int pollResult = 0;
 
+	int taskIndex = 0;
+	int taskCount = list_length(taskList);
+	ListCell *taskCell = NULL;
+
 	pollFDs = (struct pollfd *) palloc0(taskCount * sizeof(struct pollfd));
 
-	gettimeofday(&currentTime, NULL);
+	currentTime = GetCurrentTimestamp();
+
+	/*
+	 * At the latest, wake up when the next minute starts.
+	 */
+	nextEventTime = TimestampMinuteEnd(currentTime);
 
 	foreach(taskCell, taskList)
 	{
 		CronTask *task = (CronTask *) lfirst(taskCell);
-		struct pollfd *pollFileDescriptor = NULL;
-		pollFileDescriptor = &pollFDs[taskIndex];
+		PostgresPollingStatusType pollingStatus = task->pollingStatus;
+		struct pollfd *pollFileDescriptor = &pollFDs[taskIndex];
 
-		if (task->state == CRON_TASK_WAITING)
+		if (task->state == CRON_TASK_WAITING &&
+			task->pendingRunCount > 0)
 		{
-			bool hasTimeout = task->nextEventTime.tv_sec != 0;
+			/*
+			 * We have a task that can start, don't wait.
+			 */
+			pfree(pollFDs);
+			return;
+		}
 
-			if (hasTimeout &&
-				(nextEventTime.tv_sec == 0 ||
-				 CompareTimes(&task->nextEventTime, &nextEventTime) < 0))
+		if (task->state == CRON_TASK_CONNECTING ||
+			task->state == CRON_TASK_SENDING)
+		{
+			/*
+			 * We need to wake up when a timeout expires.
+			 * Take the minimum of nextEventTime and task->startDeadline.
+			 */
+			if (TimestampDifferenceExceeds(task->startDeadline, nextEventTime, 0))
 			{
-				nextEventTime = task->nextEventTime;
+				nextEventTime = task->startDeadline;
 			}
 		}
 
-		if (task->state == CRON_TASK_CONNECTING
-			task->state == CRON_TASK_SENDING
-			task->state == CRON_TASK_RUNNING
-			task->state == CRON_TASK_RECEIVING)
+		if (task->state == CRON_TASK_CONNECTING ||
+			task->state == CRON_TASK_SENDING ||
+			task->state == CRON_TASK_RUNNING)
 		{
 			PGconn *connection = task->connection;
 			int pollEventMask = 0;
 
+			/*
+			 * Set the appropriate mask for poll, based on the current polling
+			 * status of the task, controlled by ManageCronTask.
+			 */
+
 			if (pollingStatus == PGRES_POLLING_READING)
 			{
 				pollEventMask = POLLERR | POLLIN;
@@ -336,6 +1070,10 @@ WaitForEvent(List *taskList)
 		}
 		else
 		{
+			/*
+			 * Task is not running.
+			 */
+
 			pollFileDescriptor->fd = -1;
 			pollFileDescriptor->events = 0;
 		}
@@ -345,12 +1083,33 @@ WaitForEvent(List *taskList)
 		taskIndex++;
 	}
 
-	pollTimeout = SubtractTimes(nextEventTime, currentTime);
-	pollResult = poll(pollFDs, taskCount, pollTimeout);
+	/*
+	 * Find the first time-based event, which is either the start of a new
+	 * minute or a timeout.
+	 */
+	TimestampDifference(currentTime, nextEventTime, &waitSeconds, &waitMicros);
+
+	pollTimeout = waitSeconds * 1000 + waitMicros / 1000;
+	if (pollTimeout > MaxWait)
+	{
+		/*
+		 * We never wait more than 1 second, this gives us a chance to react
+		 * to external events like a TERM signal and job changes.
+		 */
 
+		pollTimeout = MaxWait;
+	}
+
+	pollResult = poll(pollFDs, taskCount, pollTimeout);
 	if (pollResult < 0)
 	{
-		return STATUS_ERROR;
+		/*
+		 * This typically happens in case of a signal, though we should
+		 * probably check errno in case something bad happened.
+		 */
+
+		pfree(pollFDs);
+		return;
 	}
 
 	taskIndex = 0;
@@ -360,201 +1119,468 @@ WaitForEvent(List *taskList)
 		CronTask *task = (CronTask *) lfirst(taskCell);
 		struct pollfd *pollFileDescriptor = &pollFDs[taskIndex];
 
-		task->readyToPoll = pollFileDescriptor->revents & pollFileDescriptor->events;
+		task->isSocketReady = pollFileDescriptor->revents &
+							  pollFileDescriptor->events;
 
 		taskIndex++;
 	}
 
-	return 0;
+	pfree(pollFDs);
+}
+
+
+/*
+ * ManageCronTasks proceeds the state machines of the given list of tasks.
+ */
+static void
+ManageCronTasks(List *taskList, TimestampTz currentTime)
+{
+	ListCell *taskCell = NULL;
+
+	foreach(taskCell, taskList)
+	{
+		CronTask *task = (CronTask *) lfirst(taskCell);
+
+		ManageCronTask(task, currentTime);
+	}
 }
 
 
 /*
- * ManageCronTask proceeds the task state machine.
+ * ManageCronTask implements the cron task state machine.
  */
 static void
-ManageCronTask(CronTask *task, struct timeval currentTime)
+ManageCronTask(CronTask *task, TimestampTz currentTime)
 {
 	CronTaskState checkState = task->state;
-	CronJob *cronJob = task->job;
-	
+	int64 jobId = task->jobId;
+	CronJob *cronJob = GetCronJob(jobId);
+	PGconn *connection = task->connection;
+	ConnStatusType connectionStatus = CONNECTION_BAD;
+
 	switch (checkState)
 	{
-		case CRON_TASK_INITIAL:
+		case CRON_TASK_WAITING:
 		{
-			PGconn *connection = NULL;
-			ConnStatusType connStatus = CONNECTION_BAD;
-			
-			connection = PQconnectStart(cronJob->connectionString);
-			connStatus = PQstatus(connection);
-			if (connStatus == CONNECTION_BAD)
+			/* check if job has been removed */
+			if (!task->isActive)
 			{
-				PQfinish(connection);
-
-				LogTaskResult(cronJob->jobName, 1);
-
-				task->connection = NULL;
-				task->pollingStatus = PGRES_POLLING_FAILED;
-				task->state = CRON_TASK_DEAD;
+				/* remove task as well */
+				bool isPresent = false;
+				hash_search(CronTaskHash, &jobId, HASH_REMOVE, &isPresent);
 			}
-			else
+
+			/* check whether runs are pending */
+			if (task->pendingRunCount == 0)
 			{
-				struct timeval timeoutTime = {0, 0};
+				break;
+			}
 
-				timeoutTime = AddTimeMillis(currentTime, CronTaskTimeout);
+			task->runId = RunCount++;
+			task->pendingRunCount -= 1;
+			task->state = CRON_TASK_START;
+		}
 
-				task->nextEventTime = timeoutTime;
-				task->connection = connection;
-				task->pollingStatus = PGRES_POLLING_WRITING;
-				task->state = CRON_TASK_CONNECTING;
+		case CRON_TASK_START:
+		{
+			const char *clientEncoding = GetDatabaseEncodingName();
+			char nodePortString[12];
+			TimestampTz startDeadline = 0;
+
+			const char *keywordArray[] = {
+				"host",
+				"port",
+				"fallback_application_name",
+				"client_encoding",
+				"dbname",
+				"user",
+				NULL
+			};
+			const char *valueArray[] = {
+				cronJob->nodeName,
+				nodePortString,
+				"pg_cron",
+				clientEncoding,
+				cronJob->database,
+				cronJob->userName,
+				NULL
+			};
+			sprintf(nodePortString, "%d", cronJob->nodePort);
+
+			Assert(sizeof(keywordArray) == sizeof(valueArray));
+
+			connection = PQconnectStartParams(keywordArray, valueArray, false);
+			PQsetnonblocking(connection, 1);
+
+			connectionStatus = PQstatus(connection);
+			if (connectionStatus == CONNECTION_BAD)
+			{
+				task->errorMessage = PQerrorMessage(connection);
+				task->pollingStatus = 0;
+				task->state = CRON_TASK_ERROR;
+				break;
 			}
 
+			startDeadline = TimestampTzPlusMilliseconds(currentTime,
+														CronTaskStartTimeout);
+
+			task->startDeadline = startDeadline;
+			task->connection = connection;
+			task->pollingStatus = PGRES_POLLING_WRITING;
+			task->state = CRON_TASK_CONNECTING;
+
 			break;
 		}
 
 		case CRON_TASK_CONNECTING:
 		{
-			PGconn *connection = task->connection;
-			PostgresPollingStatusType pollingStatus = PGRES_POLLING_FAILED;
+			PostgresPollingStatusType pollingStatus = 0;
 
-			if (CompareTimes(&task->nextEventTime, &currentTime) < 0)
+			/* check if job has been removed */
+			if (!task->isActive)
 			{
-				PQfinish(connection);
+				task->errorMessage = "job cancelled";
+				task->pollingStatus = 0;
+				task->state = CRON_TASK_ERROR;
+				break;
+			}
 
-				LogTaskResult(cronJob->jobName, 1);
+			/* check if timeout has been reached */
+			if (TimestampDifferenceExceeds(task->startDeadline, currentTime, 0))
+			{
+				task->errorMessage = "connection timeout";
+				task->pollingStatus = 0;
+				task->state = CRON_TASK_ERROR;
+				break;
+			}
 
-				task->connection = NULL;
-				task->pollingStatus = pollingStatus;
-				task->state = CRON_TASK_DEAD;
+			/* check if connection is still alive */
+			connectionStatus = PQstatus(connection);
+			if (connectionStatus == CONNECTION_BAD)
+			{
+				task->errorMessage = PQerrorMessage(connection);
+				task->pollingStatus = 0;
+				task->state = CRON_TASK_ERROR;
 				break;
 			}
 
-			if (!task->readyToPoll)
+			/* check if socket is ready to send */
+			if (!task->isSocketReady)
 			{
 				break;
 			}
 
+			/* check whether a connection has been established */
 			pollingStatus = PQconnectPoll(connection);
-			if (pollingStatus == PGRES_POLLING_FAILED)
+			if (pollingStatus == PGRES_POLLING_OK)
 			{
-				PQfinish(connection);
+				/* wait for socket to be ready to send a query */
+				task->pollingStatus = PGRES_POLLING_WRITING;
 
-				LogTaskResult(cronJob->jobName, 1);
+				task->state = CRON_TASK_SENDING;
+			}
+			else if (pollingStatus == PGRES_POLLING_FAILED)
+			{
+				task->errorMessage = PQerrorMessage(connection);
+				task->pollingStatus = 0;
+				task->state = CRON_TASK_ERROR;
+			}
+			else
+			{
+				/*
+				 * Connection is still being established.
+				 *
+				 * On the next WaitForTasks round, we wait for reading or writing
+				 * based on the status returned by PQconnectPoll, see:
+				 * https://www.postgresql.org/docs/9.5/static/libpq-connect.html
+				 */
+				task->pollingStatus = pollingStatus;
+			}
 
-				task->connection = NULL;
-				task->state = CRON_TASK_DEAD;
+			break;
+		}
+
+		case CRON_TASK_SENDING:
+		{
+			char *command = cronJob->command;
+			int sendResult = 0;
+
+			/* check if job has been removed */
+			if (!task->isActive)
+			{
+				task->errorMessage = "job cancelled";
+				task->pollingStatus = 0;
+				task->state = CRON_TASK_ERROR;
+				break;
 			}
-			else if (pollingStatus == PGRES_POLLING_OK)
+
+			/* check if timeout has been reached */
+			if (TimestampDifferenceExceeds(task->startDeadline, currentTime, 0))
 			{
-				PQfinish(connection);
+				task->errorMessage = "connection timeout";
+				task->pollingStatus = 0;
+				task->state = CRON_TASK_ERROR;
+				break;
+			}
 
-				LogTaskResult(cronJob->jobName, 0);
+			/* check if socket is ready to send */
+			if (!task->isSocketReady)
+			{
+				break;
+			}
 
-				task->connection = NULL;
-				task->state = CRON_TASK_OK;
+			/* check if connection is still alive */
+			connectionStatus = PQstatus(connection);
+			if (connectionStatus == CONNECTION_BAD)
+			{
+				task->errorMessage = PQerrorMessage(connection);
+				task->pollingStatus = 0;
+				task->state = CRON_TASK_ERROR;
+				break;
+			}
+
+			sendResult = PQsendQuery(connection, command);
+			if (sendResult == 1)
+			{
+				/* wait for socket to be ready to receive results */
+				task->pollingStatus = PGRES_POLLING_READING;
+
+				/* command is underway, stop using timeout */
+				task->startDeadline = 0;
+				task->state = CRON_TASK_RUNNING;
 			}
 			else
 			{
-				/* still connecting */
+				/* not yet ready to send */
 			}
 
-			task->pollingStatus = pollingStatus;
+			break;
+		}
+
+		case CRON_TASK_RUNNING:
+		{
+			int connectionBusy = 0;
+			PGresult *result = NULL;
+
+			/* check if job has been removed */
+			if (!task->isActive)
+			{
+				task->errorMessage = "job cancelled";
+				task->pollingStatus = 0;
+				task->state = CRON_TASK_ERROR;
+				break;
+			}
+
+			/* check if connection is still alive */
+			connectionStatus = PQstatus(connection);
+			if (connectionStatus == CONNECTION_BAD)
+			{
+				task->errorMessage = PQerrorMessage(connection);
+				task->pollingStatus = 0;
+				task->state = CRON_TASK_ERROR;
+				break;
+			}
+
+			/* check if socket is ready to send */
+			if (!task->isSocketReady)
+			{
+				break;
+			}
+
+			PQconsumeInput(connection);
+
+			connectionBusy = PQisBusy(connection);
+			if (connectionBusy)
+			{
+				/* still waiting for results */
+				break;
+			}
+
+			while ((result = PQgetResult(connection)) != NULL)
+			{
+				ExecStatusType executionStatus = PQresultStatus(result);
+
+				switch (executionStatus)
+				{
+					case PGRES_TUPLES_OK:
+					{
+						break;
+					}
+
+					case PGRES_COMMAND_OK:
+					{
+						break;
+					}
+
+					case PGRES_BAD_RESPONSE:
+					case PGRES_FATAL_ERROR:
+					{
+						task->errorMessage = PQresultErrorMessage(result);
+						task->pollingStatus = 0;
+						task->state = CRON_TASK_ERROR;
+						return;
+					}
+
+					case PGRES_COPY_IN:
+					case PGRES_COPY_OUT:
+					case PGRES_COPY_BOTH:
+					{
+						/* cannot handle COPY input/output */
+						task->errorMessage = "COPY not supported";
+						task->pollingStatus = 0;
+						task->state = CRON_TASK_ERROR;
+						return;
+					}
+
+					case PGRES_EMPTY_QUERY:
+					case PGRES_SINGLE_TUPLE:
+					case PGRES_NONFATAL_ERROR:
+					default:
+					{
+						break;
+					}
+
+				}
+
+				PQclear(result);
+			}
+
+			PQfinish(connection);
+
+			task->connection = NULL;
+			task->pollingStatus = 0;
+			task->isSocketReady = false;
+			task->state = CRON_TASK_DONE;
 
 			break;
 		}
 
-		case CRON_TASK_DEAD:
-		case CRON_TASK_OK:
+		case CRON_TASK_ERROR:
+		{
+			if (connection != NULL)
+			{
+				PQfinish(connection);
+				task->connection = NULL;
+			}
+
+			if (!task->isActive)
+			{
+				bool isPresent = false;
+				hash_search(CronTaskHash, &jobId, HASH_REMOVE, &isPresent);
+			}
+
+			if (task->errorMessage != NULL)
+			{
+				elog(LOG, "error running job %ld: %s", jobId, task->errorMessage);
+			}
+
+			task->startDeadline = 0;
+			task->isSocketReady = false;
+			task->state = CRON_TASK_DONE;
+
+			/* fall through to CRON_TASK_DONE */
+		}
+
+		case CRON_TASK_DONE:
 		default:
 		{
-			/* task is done */
+			InitializeCronTask(task, jobId);
 		}
 
 	}
 }
 
 
-/*
- * CompareTime compares two timeval structs.
- *
- * If leftTime < rightTime, return -1
- * If leftTime > rightTime, return 1
- * else, return 0
- */
-static int
-CompareTimes(struct timeval *leftTime, struct timeval *rightTime)
+static HTAB *
+CreateCronJobHash(void)
 {
-	int compareResult = 0;
-	
-	if (leftTime->tv_sec < rightTime->tv_sec)
-	{
-		compareResult = -1;
-	}
-	else if (leftTime->tv_sec > rightTime->tv_sec)
-	{
-		compareResult = 1;
-	}
-	else if (leftTime->tv_usec < rightTime->tv_usec)
-	{
-		compareResult = -1;
-	}
-	else if (leftTime->tv_usec > rightTime->tv_usec)
-	{
-		compareResult = 1;
-	}
-	else
-	{
-		compareResult = 0;
-	}
+	HTAB *taskHash = NULL;
+	HASHCTL info;
+	int hashFlags = 0;
+
+	memset(&info, 0, sizeof(info));
+	info.keysize = sizeof(int64);
+	info.entrysize = sizeof(CronJob);
+	info.hash = tag_hash;
+	info.hcxt = CronJobContext;
+	hashFlags = (HASH_ELEM | HASH_FUNCTION | HASH_CONTEXT);
 
-	return compareResult;
+	taskHash = hash_create("pg_cron jobs", 32, &info, hashFlags);
+
+	return taskHash;
 }
 
+
+static HTAB *
+CreateCronTaskHash(void)
+{
+	HTAB *taskHash = NULL;
+	HASHCTL info;
+	int hashFlags = 0;
+
+	memset(&info, 0, sizeof(info));
+	info.keysize = sizeof(int64);
+	info.entrysize = sizeof(CronTask);
+	info.hash = tag_hash;
+	info.hcxt = CronTaskContext;
+	hashFlags = (HASH_ELEM | HASH_FUNCTION | HASH_CONTEXT);
+
+	taskHash = hash_create("pg_cron tasks", 32, &info, hashFlags);
+
+	return taskHash;
+}
+
+
 /*
- * SubtractTimes subtracts the struct timeval values y from x,
- * returning the result in milliseconds.
- *
- * From:
- * http://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html
+ * GetCronTask gets the current task with the given job ID.
  */
-static int
-SubtractTimes(struct timeval x, struct timeval y)
+static CronTask *
+GetCronTask(int64 jobId)
 {
-	int differenceMs = 0;
+	CronTask *task = NULL;
+	int64 hashKey = jobId;
+	bool isPresent = false;
 
-	/* Perform the carry for the later subtraction by updating y. */
-	if (x.tv_usec < y.tv_usec)
+	task = hash_search(CronTaskHash, &hashKey, HASH_ENTER, &isPresent);
+	if (!isPresent)
 	{
-		int nsec = (y.tv_usec - x.tv_usec) / 1000000 + 1;
-		y.tv_usec -= 1000000 * nsec;
-		y.tv_sec += nsec;
+		InitializeCronTask(task, jobId);
 	}
 
-	if (x.tv_usec - y.tv_usec > 1000000)
-	{
-		int nsec = (x.tv_usec - y.tv_usec) / 1000000;
-		y.tv_usec += 1000000 * nsec;
-		y.tv_sec -= nsec;
-	}
+	return task;
+}
 
-	differenceMs += 1000 * (x.tv_sec - y.tv_sec);
-	differenceMs += (x.tv_usec - y.tv_usec) / 1000;
 
-	return differenceMs;
+/*
+ * InitializeCronTask intializes a CronTask struct.
+ */
+static void
+InitializeCronTask(CronTask *task, int64 jobId)
+{
+	task->runId = 0;
+	task->jobId = jobId;
+	task->state = CRON_TASK_WAITING;
+	task->pendingRunCount = 0;
+	task->connection = NULL;
+	task->pollingStatus = 0;
+	task->startDeadline = 0;
+	task->isSocketReady = false;
+	task->isActive = true;
+	task->errorMessage = NULL;
 }
 
 
 /*
- * AddTimeMillis adds additionalMs milliseconds to a timeval.
+ * GetCronJob gets the cron job with the given id.
  */
-static struct timeval
-AddTimeMillis(struct timeval base, uint32 additionalMs)
+static CronJob *
+GetCronJob(int64 jobId)
 {
-	struct timeval result = {0, 0};
+	CronJob *job = NULL;
+	int64 hashKey = jobId;
+	bool isPresent = false;
 
-	result.tv_sec = base.tv_sec + additionalMs / 1000;
-	result.tv_usec = base.tv_usec + (additionalMs % 1000) * 1000;
+	job = hash_search(CronJobHash, &hashKey, HASH_FIND, &isPresent);
 
-	return result;
+	return job;
 }
-

COMMIT_HASH:44bd3c17be77ced1a23a94118260b68b3ad91753|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-02-20 13:44:52 +0100|TITLE:Initial aeroplane scribblings|MESSAGE:
diff --git a/META.json b/META.json
new file mode 100644
index 0000000..dce89e0
--- /dev/null
+++ b/META.json
@@ -0,0 +1,49 @@
+{
+    "name": "pg_cron",
+    "abstract": "Periodic background job scheduler for PostgreSQL",
+    "description": "Sets up a background worker that periodically runs queries in the background",
+    "version": "0.1",
+    "maintainer": "\"Marco Slot\" <marco@citusdata.com>",
+    "license": {
+		"PostgreSQL": "http://www.postgresql.org/about/licence"
+	},
+    "prereqs": {
+       "runtime": {
+          "requires": {
+             "PostgreSQL": "9.5.0"
+          }
+       }
+    },
+    "provides": {
+        "pg_cron": {
+            "abstract": "Periodic background job scheduler",
+            "file": "sql/pg_cron--0.1.sql",
+            "docfile": "README.md",
+            "version": "0.1"
+        }
+    },
+    "release_status": "stable",
+    "resources": {
+        "homepage": "https://citusdata.com/",
+        "bugtracker": {
+            "web": "https://github.com/marcocitus/pg_cron/issues",
+            "mailto": "support@citusdata.com"
+        },
+        "repository": {
+          "url":  "git://github.com/marcocitus/pg_cron.git",
+          "web":  "https://github.com/marcocitus/pg_cron",
+          "type": "git"
+        }
+    },
+
+    "generated_by": "\"Marco Slot\" <marco@citusdata.com>",
+
+    "tags": [
+        "cluster"
+    ],
+
+    "meta-spec": {
+        "version": "1.0.0",
+        "url": "http://pgxn.org/meta/spec.txt"
+    }
+}
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..d47ff2f
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,41 @@
+# src/test/modules/pg_cron/Makefile
+
+# grab name and version from META.json file
+EXTENSION = $(shell grep -m 1 '"name":' META.json | sed -e 's/[[:space:]]*"name":[[:space:]]*"\([^"]*\)",/\1/')
+EXTVERSION = $(shell grep default_version $(EXTENSION).control | sed -e "s/default_version[[:space:]]*=[[:space:]]*'\([^']*\)'/\1/")
+
+# installation scripts
+DATA = $(wildcard updates/*--*.sql)
+
+# compilation configuration
+MODULE_big = $(EXTENSION)
+OBJS = $(patsubst %.c,%.o,$(wildcard src/*.c))
+PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Iinclude -I$(libpq_srcdir)
+SHLIB_LINK = $(libpq)
+EXTRA_CLEAN += $(addprefix src/,*.gcno *.gcda) # clean up after profiling runs
+
+# add coverage flags if requested
+ifeq ($(enable_coverage),yes)
+PG_CPPFLAGS += --coverage
+SHLIB_LINK += --coverage
+endif
+
+# be explicit about the default target
+all:
+
+# delegate to subdirectory makefiles as needed
+include sql/Makefile
+
+# detect whether to build with pgxs or build in-tree
+ifndef NO_PGXS
+PG_CONFIG = pg_config
+PGXS := $(shell $(PG_CONFIG) --pgxs)
+include $(PGXS)
+else
+SHLIB_PREREQS = submake-libpq
+subdir = contrib/$(EXTENSION)
+top_builddir = ../..
+include $(top_builddir)/src/Makefile.global
+include $(top_srcdir)/contrib/contrib-global.mk
+endif
+
diff --git a/include/job_metadata.h b/include/job_metadata.h
new file mode 100644
index 0000000..73cdd27
--- /dev/null
+++ b/include/job_metadata.h
@@ -0,0 +1,35 @@
+/*-------------------------------------------------------------------------
+ *
+ * include/job_metadata.h
+ *
+ * Declarations for public functions and types related to job metadata.
+ *
+ * Copyright (c) 2016, Citus Data, Inc.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#pragma once
+
+#include "postgres.h"
+
+#include "access/htup.h"
+#include "access/tupdesc.h"
+#include "nodes/pg_list.h"
+
+
+/*
+ * CronJob represents a periodic job.
+ */
+typedef struct CronJob
+{
+	char *jobName;
+	char *cronString;
+	char *query;
+	char *connectionString;
+
+} CronJob;
+
+
+extern List * LoadCronJobList(void);
+extern void LogCronTaskResult(char *jobName, int taskStatus);
diff --git a/pg_cron.control b/pg_cron.control
new file mode 100644
index 0000000..d010f1e
--- /dev/null
+++ b/pg_cron.control
@@ -0,0 +1,4 @@
+comment = 'Job scheduler for PostgreSQL'
+default_version = '0.1'
+module_pathname = '$libdir/pg_cron'
+relocatable = true
diff --git a/sql/Makefile b/sql/Makefile
new file mode 100644
index 0000000..dcb1ca0
--- /dev/null
+++ b/sql/Makefile
@@ -0,0 +1,5 @@
+DATA_built += sql/$(EXTENSION)--$(EXTVERSION).sql
+
+# define build process for latest install file
+sql/$(EXTENSION)--$(EXTVERSION).sql: sql/$(EXTENSION).sql
+	cp $< $@
diff --git a/sql/pg_cron.sql b/sql/pg_cron.sql
new file mode 100644
index 0000000..e955bd3
--- /dev/null
+++ b/sql/pg_cron.sql
@@ -0,0 +1,34 @@
+CREATE SCHEMA cron
+
+	CREATE TABLE jobs (
+		job_name text not null,
+		cron_string not null,
+		query text not null,
+		connection_string text not null,
+		PRIMARY KEY (job_name)
+	)
+
+	CREATE TABLE results (
+		id bigint primary key default nextval('task_id_sequence'),
+		job_name text not null,
+		start_time timestamptz,
+		end_time timestamptz,
+		status int not null,
+		output text
+	)
+
+	CREATE SEQUENCE task_id_sequence NO CYCLE;
+
+CREATE FUNCTION cron.schedule(text,text,text,text)
+    RETURNS text
+    LANGUAGE C STRICT
+    AS 'MODULE_PATHNAME', $$pg_cron_schedule$$;
+COMMENT ON FUNCTION cron.schedule(text,text,text,text)
+    IS 'schedule a pg_cron job';
+
+CREATE FUNCTION cron.unschedule(text)
+    RETURNS text
+    LANGUAGE C STRICT
+    AS 'MODULE_PATHNAME', $$pg_cron_schedule$$;
+COMMENT ON FUNCTION cron.unschedule(text)
+    IS 'unschedule a pg_cron job';
diff --git a/src/job_metadata.c b/src/job_metadata.c
new file mode 100644
index 0000000..612357e
--- /dev/null
+++ b/src/job_metadata.c
@@ -0,0 +1,167 @@
+/*-------------------------------------------------------------------------
+ *
+ * src/job_metadata.c
+ *
+ * Implementation of functions related to job metadata.
+ *
+ * Copyright (c) 2016, Citus Data, Inc.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#include "postgres.h"
+
+#include "job_metadata.h"
+
+#include "access/htup.h"
+#include "access/tupdesc.h"
+#include "access/xact.h"
+#include "executor/spi.h"
+#include "lib/stringinfo.h"
+#include "nodes/pg_list.h"
+#include "pgstat.h"
+#include "utils/builtins.h"
+#include "utils/memutils.h"
+#include "utils/snapmgr.h"
+
+
+/* human-readable names for addressing columns of job metadata */
+#define TLIST_NUM_JOB_NAME 1
+#define TLIST_NUM_CRON_STRING 2
+#define TLIST_NUM_QUERY 3
+#define TLIST_NUM_CONNECTION_STRING 4
+
+
+static void StartSPITransaction(void);
+extern CronJob * TupleToCronJob(HeapTuple heapTuple,
+								TupleDesc tupleDescriptor);
+static void EndSPITransaction(void);
+
+
+/*
+ * LoadCronJobList loads a list of periodic jobs.
+ */
+List *
+LoadCronJobList(void)
+{
+	List *cronJobList = NIL;
+	int spiStatus PG_USED_FOR_ASSERTS_ONLY = 0;
+	StringInfoData query;
+
+	MemoryContext upperContext = CurrentMemoryContext, oldContext = NULL;
+
+	StartSPITransaction();
+
+	initStringInfo(&query);
+	appendStringInfo(&query,
+					 "SELECT job_name, cron_string, query, connection_string "
+					 "FROM cron.jobs");
+
+	pgstat_report_activity(STATE_RUNNING, query.data);
+
+	spiStatus = SPI_execute(query.data, false, 0);
+	Assert(spiStatus == SPI_OK_SELECT);
+
+	oldContext = MemoryContextSwitchTo(upperContext);
+
+	for (uint32 rowNumber = 0; rowNumber < SPI_processed; rowNumber++)
+	{
+		HeapTuple heapTuple = SPI_tuptable->vals[rowNumber];
+		CronJob *cronJob = TupleToCronJob(heapTuple,
+										  SPI_tuptable->tupdesc);
+		cronJobList = lappend(cronJobList, cronJob);
+	}
+
+	MemoryContextSwitchTo(oldContext);
+
+	pgstat_report_activity(STATE_IDLE, NULL);
+
+	EndSPITransaction();
+
+	return cronJobList;
+}
+
+
+/*
+ * TupleToCronJob constructs a job description from a heap tuple obtained
+ * via SPI.
+ */
+CronJob *
+TupleToCronJob(HeapTuple heapTuple, TupleDesc tupleDescriptor)
+{
+	CronJob *cronJob = NULL;
+	bool isNull[4] = {false, false, false, false};
+
+	Datum jobNameDatum = SPI_getbinval(heapTuple, tupleDescriptor,
+									   TLIST_NUM_JOB_NAME, &isNull[0]);
+	Datum cronStringDatum = SPI_getbinval(heapTuple, tupleDescriptor,
+										  TLIST_NUM_CRON_STRING, &isNull[1]);
+	Datum queryDatum = SPI_getbinval(heapTuple, tupleDescriptor,
+									 TLIST_NUM_QUERY, &isNull[2]);
+	Datum connectionStringDatum = SPI_getbinval(heapTuple, tupleDescriptor,
+												TLIST_NUM_CONNECTION_STRING,
+												&isNull[3]);
+
+	cronJob = palloc0(sizeof(CronJob));
+	cronJob->jobName = TextDatumGetCString(jobNameDatum);
+	cronJob->cronString = TextDatumGetCString(cronStringDatum);
+	cronJob->query = TextDatumGetCString(queryDatum);
+	cronJob->connectionString = TextDatumGetCString(connectionStringDatum);
+
+	return cronJob;
+}
+
+
+/*
+ * LogCronTaskResult logs the result of a cron task.
+ */
+void
+LogCronTaskResult(char *jobName, int taskStatus)
+{
+	StringInfoData query;
+	int spiStatus PG_USED_FOR_ASSERTS_ONLY = 0;
+
+	StartSPITransaction();
+
+	initStringInfo(&query);
+	appendStringInfo(&query,
+					 "INSERT INTO cron.results "
+					 "(job_name, status) "
+					 "VALUES (%s,%d) "
+					 quote_literal_cstr(jobName),
+					 taskStatus);
+
+	pgstat_report_activity(STATE_RUNNING, query.data);
+
+	spiStatus = SPI_execute(query.data, false, 0);
+	Assert(spiStatus == SPI_OK_UPDATE);
+
+	pgstat_report_activity(STATE_IDLE, NULL);
+
+	EndSPITransaction();
+}
+
+
+/*
+ * StartSPITransaction starts a transaction using SPI.
+ */
+static void
+StartSPITransaction(void)
+{
+	SetCurrentStatementStartTimestamp();
+	StartTransactionCommand();
+	SPI_connect();
+	PushActiveSnapshot(GetTransactionSnapshot());
+}
+
+
+/*
+ * EndSPITransaction finishes a transaction that was started using SPI.
+ */
+static void
+EndSPITransaction(void)
+{
+	SPI_finish();
+	PopActiveSnapshot();
+	CommitTransactionCommand();
+}
diff --git a/src/pg_cron.c b/src/pg_cron.c
new file mode 100644
index 0000000..a42b8b1
--- /dev/null
+++ b/src/pg_cron.c
@@ -0,0 +1,560 @@
+/*-------------------------------------------------------------------------
+ *
+ * src/pg_cron.c
+ *
+ * Implementation of the pg_cron task scheduler.
+ *
+ * Copyright (c) 2016, Citus Data, Inc.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#include "postgres.h"
+
+/* these are internal headers */
+#include "job_metadata.h"
+
+/* these are always necessary for a bgworker */
+#include "miscadmin.h"
+#include "postmaster/bgworker.h"
+#include "storage/ipc.h"
+#include "storage/latch.h"
+#include "storage/lwlock.h"
+#include "storage/proc.h"
+#include "storage/shmem.h"
+
+/* these headers are used by this particular worker's code */
+#include "fmgr.h"
+#include "lib/stringinfo.h"
+#include "libpq-fe.h"
+#include "libpq/pqsignal.h"
+#include "sys/time.h"
+#include "utils/builtins.h"
+#include "utils/memutils.h"
+#include "tcop/utility.h"
+
+
+typedef enum
+{
+	CRON_TASK_INITIAL = 0,
+	CRON_TASK_CONNECTING = 1,
+	CRON_TASK_SENDING = 2,
+	CRON_TASK_RUNNING = 3,
+	CRON_TASK_RECEIVING = 4
+	CRON_TASK_OK = 5,
+	CRON_TASK_ERROR = 6,
+	CRON_TASK_WAITING = 7
+	
+} CronTaskState;
+
+typedef struct CronTask
+{
+	CronJob *job;
+	CronTaskState state;
+	PGconn *connection;
+	bool readyToPoll;
+	PostgresPollingStatusType pollingStatus;
+	struct timeval nextEventTime;
+
+} CronTask;
+
+
+void _PG_init(void);
+static void PgOctopusWorkerMain(Datum arg);
+static List * CreateCronTasks(List *cronJobList);
+static CronTask * CreateCronTask(CronJob *cronJob);
+static void DoCronTasks(List *taskList);
+static void ManageCronTask(CronTask *task, struct timeval currentTime);
+static int WaitForEvent(List *taskList);
+static int CompareTimes(struct timeval *leftTime, struct timeval *rightTime);
+static int SubtractTimes(struct timeval base, struct timeval subtract);
+static struct timeval AddTimeMillis(struct timeval base, uint32 additionalMs);
+
+
+PG_MODULE_MAGIC;
+
+
+/* flags set by signal handlers */
+static volatile sig_atomic_t got_sighup = false;
+static volatile sig_atomic_t got_sigterm = false;
+
+
+/*
+ * Entrypoint of this module.
+ *
+ * We register more than one worker process here, to demonstrate how that can
+ * be done.
+ */
+void
+_PG_init(void)
+{
+	BackgroundWorker worker;
+
+	if (!process_shared_preload_libraries_in_progress)
+	{
+		return;
+	}
+
+	/* set up common data for all our workers */
+	worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
+	worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
+	worker.bgw_restart_time = BGW_NEVER_RESTART;
+	worker.bgw_main = PgOctopusWorkerMain;
+	worker.bgw_main_arg = Int32GetDatum(0);
+	worker.bgw_notify_pid = 0;
+	sprintf(worker.bgw_library_name, "pg_cron");
+	snprintf(worker.bgw_name, BGW_MAXLEN, "pg_cron_scheduler");
+
+	RegisterBackgroundWorker(&worker);
+}
+
+
+/*
+ * Signal handler for SIGTERM
+ *		Set a flag to let the main loop to terminate, and set our latch to wake
+ *		it up.
+ */
+static void
+pg_cron_sigterm(SIGNAL_ARGS)
+{
+	int save_errno = errno;
+
+	got_sigterm = true;
+	SetLatch(MyLatch);
+
+	errno = save_errno;
+}
+
+
+/*
+ * Signal handler for SIGHUP
+ *		Set a flag to tell the main loop to reread the config file, and set
+ *		our latch to wake it up.
+ */
+static void
+pg_cron_sighup(SIGNAL_ARGS)
+{
+	int save_errno = errno;
+
+	got_sighup = true;
+	SetLatch(MyLatch);
+
+	errno = save_errno;
+}
+
+
+/*
+ * PgOctopusWorkerMain is the main entry-point for the background worker
+ * that performs tasks.
+ */
+static void
+PgOctopusWorkerMain(Datum arg)
+{
+	MemoryContext taskContext = NULL;
+
+	/* Establish signal handlers before unblocking signals. */
+	pqsignal(SIGHUP, pg_cron_sighup);
+	pqsignal(SIGINT, SIG_IGN);
+	pqsignal(SIGTERM, pg_cron_sigterm);
+
+	/* We're now ready to receive signals */
+	BackgroundWorkerUnblockSignals();
+
+	/* Connect to our database */
+	BackgroundWorkerInitializeConnection("postgres", NULL);
+
+	taskContext = AllocSetContextCreate(CurrentMemoryContext,
+											   "CronTask context",
+											   ALLOCSET_DEFAULT_MINSIZE,
+											   ALLOCSET_DEFAULT_INITSIZE,
+											   ALLOCSET_DEFAULT_MAXSIZE);
+
+	MemoryContextSwitchTo(taskContext);
+
+	elog(LOG, "pg_cron scheduler started");
+
+	/*
+	 * Main loop: do this until the SIGTERM handler tells us to terminate
+	 */
+	while (!got_sigterm)
+	{
+		List *cronJobList = NIL;
+		List *taskList = NIL;
+
+		cronJobList = LoadCronJobList();
+		taskList = CreateCronTasks(cronJobList);
+
+		DoCronTasks(taskList);
+
+		MemoryContextReset(taskContext);
+
+		if (got_sighup)
+		{
+			got_sighup = false;
+			ProcessConfigFile(PGC_SIGHUP);
+		}
+	}
+
+	elog(LOG, "pg_cron scheduler exiting");
+
+	proc_exit(0);
+}
+
+
+/*
+ * CreateCronTasks creates a list of tasks from a list of job
+ * descriptions.
+ */
+static List *
+CreateCronTasks(List *cronJobList)
+{
+	List *taskList = NIL;
+	ListCell *cronJobCell = NULL;
+
+	foreach(cronJobCell, cronJobList)
+	{
+		CronJob *cronJob = (CronJob *) lfirst(cronJobCell);
+		CronTask *task = CreateCronTask(cronJob);
+		taskList = lappend(taskList, task);
+	}
+
+	return taskList;
+}
+
+
+/*
+ * CreateCronTask creates a task from a job description.
+ */
+static CronTask *
+CreateCronTask(CronJob *cronJob)
+{
+	CronTask *task = NULL;
+	struct timeval invalidTime = {0, 0};
+
+	task = palloc0(sizeof(CronTask));
+	task->job = cronJob;
+	task->state = CRON_TASK_INITIAL;
+	task->connection = NULL;
+	task->nextEventTime = invalidTime;
+
+	return task;
+}
+
+
+/*
+ * DoCronTasks performs the given tasks.
+ */
+static void
+DoCronTasks(List *taskList)
+{
+	while (!got_sigterm)
+	{
+		int pendingCheckCount = 0;
+		struct timeval currentTime = {0, 0};
+		ListCell *taskCell = NULL;
+
+		gettimeofday(&currentTime, NULL);
+
+		foreach(taskCell, taskList)
+		{
+			CronTask *task = (CronTask *) lfirst(taskCell);
+
+			ManageCronTask(task, currentTime);
+
+			if (task->state != CRON_TASK_OK &&
+				task->state != CRON_TASK_DEAD)
+			{
+				pendingCheckCount++;
+			}
+		}
+		if (pendingCheckCount == 0)
+		{
+			break;
+		}
+
+		WaitForEvent(taskList);
+	}
+}
+
+
+/*
+ * WaitForEvent sleeps until a time-based or I/O event occurs in any of the jobs. 
+ */
+static int
+WaitForEvent(List *taskList)
+{
+	ListCell *taskCell = NULL;
+	int taskCount = list_length(taskList);
+	int taskIndex = 0;
+	struct timeval currentTime = {0, 0};
+	struct timeval nextEventTime = {0, 0};
+	int pollTimeout = 0;
+	struct pollfd *pollFDs = NULL;
+	int pollResult = 0;
+
+	pollFDs = (struct pollfd *) palloc0(taskCount * sizeof(struct pollfd));
+
+	gettimeofday(&currentTime, NULL);
+
+	foreach(taskCell, taskList)
+	{
+		CronTask *task = (CronTask *) lfirst(taskCell);
+		struct pollfd *pollFileDescriptor = NULL;
+		pollFileDescriptor = &pollFDs[taskIndex];
+
+		if (task->state == CRON_TASK_WAITING)
+		{
+			bool hasTimeout = task->nextEventTime.tv_sec != 0;
+
+			if (hasTimeout &&
+				(nextEventTime.tv_sec == 0 ||
+				 CompareTimes(&task->nextEventTime, &nextEventTime) < 0))
+			{
+				nextEventTime = task->nextEventTime;
+			}
+		}
+
+		if (task->state == CRON_TASK_CONNECTING
+			task->state == CRON_TASK_SENDING
+			task->state == CRON_TASK_RUNNING
+			task->state == CRON_TASK_RECEIVING)
+		{
+			PGconn *connection = task->connection;
+			int pollEventMask = 0;
+
+			if (pollingStatus == PGRES_POLLING_READING)
+			{
+				pollEventMask = POLLERR | POLLIN;
+			}
+			else if (pollingStatus == PGRES_POLLING_WRITING)
+			{
+				pollEventMask = POLLERR | POLLOUT;
+			}
+
+			pollFileDescriptor->fd = PQsocket(connection);
+			pollFileDescriptor->events = pollEventMask;
+		}
+		else
+		{
+			pollFileDescriptor->fd = -1;
+			pollFileDescriptor->events = 0;
+		}
+
+		pollFileDescriptor->revents = 0;
+
+		taskIndex++;
+	}
+
+	pollTimeout = SubtractTimes(nextEventTime, currentTime);
+	pollResult = poll(pollFDs, taskCount, pollTimeout);
+
+	if (pollResult < 0)
+	{
+		return STATUS_ERROR;
+	}
+
+	taskIndex = 0;
+
+	foreach(taskCell, taskList)
+	{
+		CronTask *task = (CronTask *) lfirst(taskCell);
+		struct pollfd *pollFileDescriptor = &pollFDs[taskIndex];
+
+		task->readyToPoll = pollFileDescriptor->revents & pollFileDescriptor->events;
+
+		taskIndex++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * ManageCronTask proceeds the task state machine.
+ */
+static void
+ManageCronTask(CronTask *task, struct timeval currentTime)
+{
+	CronTaskState checkState = task->state;
+	CronJob *cronJob = task->job;
+	
+	switch (checkState)
+	{
+		case CRON_TASK_INITIAL:
+		{
+			PGconn *connection = NULL;
+			ConnStatusType connStatus = CONNECTION_BAD;
+			
+			connection = PQconnectStart(cronJob->connectionString);
+			connStatus = PQstatus(connection);
+			if (connStatus == CONNECTION_BAD)
+			{
+				PQfinish(connection);
+
+				LogTaskResult(cronJob->jobName, 1);
+
+				task->connection = NULL;
+				task->pollingStatus = PGRES_POLLING_FAILED;
+				task->state = CRON_TASK_DEAD;
+			}
+			else
+			{
+				struct timeval timeoutTime = {0, 0};
+
+				timeoutTime = AddTimeMillis(currentTime, CronTaskTimeout);
+
+				task->nextEventTime = timeoutTime;
+				task->connection = connection;
+				task->pollingStatus = PGRES_POLLING_WRITING;
+				task->state = CRON_TASK_CONNECTING;
+			}
+
+			break;
+		}
+
+		case CRON_TASK_CONNECTING:
+		{
+			PGconn *connection = task->connection;
+			PostgresPollingStatusType pollingStatus = PGRES_POLLING_FAILED;
+
+			if (CompareTimes(&task->nextEventTime, &currentTime) < 0)
+			{
+				PQfinish(connection);
+
+				LogTaskResult(cronJob->jobName, 1);
+
+				task->connection = NULL;
+				task->pollingStatus = pollingStatus;
+				task->state = CRON_TASK_DEAD;
+				break;
+			}
+
+			if (!task->readyToPoll)
+			{
+				break;
+			}
+
+			pollingStatus = PQconnectPoll(connection);
+			if (pollingStatus == PGRES_POLLING_FAILED)
+			{
+				PQfinish(connection);
+
+				LogTaskResult(cronJob->jobName, 1);
+
+				task->connection = NULL;
+				task->state = CRON_TASK_DEAD;
+			}
+			else if (pollingStatus == PGRES_POLLING_OK)
+			{
+				PQfinish(connection);
+
+				LogTaskResult(cronJob->jobName, 0);
+
+				task->connection = NULL;
+				task->state = CRON_TASK_OK;
+			}
+			else
+			{
+				/* still connecting */
+			}
+
+			task->pollingStatus = pollingStatus;
+
+			break;
+		}
+
+		case CRON_TASK_DEAD:
+		case CRON_TASK_OK:
+		default:
+		{
+			/* task is done */
+		}
+
+	}
+}
+
+
+/*
+ * CompareTime compares two timeval structs.
+ *
+ * If leftTime < rightTime, return -1
+ * If leftTime > rightTime, return 1
+ * else, return 0
+ */
+static int
+CompareTimes(struct timeval *leftTime, struct timeval *rightTime)
+{
+	int compareResult = 0;
+	
+	if (leftTime->tv_sec < rightTime->tv_sec)
+	{
+		compareResult = -1;
+	}
+	else if (leftTime->tv_sec > rightTime->tv_sec)
+	{
+		compareResult = 1;
+	}
+	else if (leftTime->tv_usec < rightTime->tv_usec)
+	{
+		compareResult = -1;
+	}
+	else if (leftTime->tv_usec > rightTime->tv_usec)
+	{
+		compareResult = 1;
+	}
+	else
+	{
+		compareResult = 0;
+	}
+
+	return compareResult;
+}
+
+/*
+ * SubtractTimes subtracts the struct timeval values y from x,
+ * returning the result in milliseconds.
+ *
+ * From:
+ * http://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html
+ */
+static int
+SubtractTimes(struct timeval x, struct timeval y)
+{
+	int differenceMs = 0;
+
+	/* Perform the carry for the later subtraction by updating y. */
+	if (x.tv_usec < y.tv_usec)
+	{
+		int nsec = (y.tv_usec - x.tv_usec) / 1000000 + 1;
+		y.tv_usec -= 1000000 * nsec;
+		y.tv_sec += nsec;
+	}
+
+	if (x.tv_usec - y.tv_usec > 1000000)
+	{
+		int nsec = (x.tv_usec - y.tv_usec) / 1000000;
+		y.tv_usec += 1000000 * nsec;
+		y.tv_sec -= nsec;
+	}
+
+	differenceMs += 1000 * (x.tv_sec - y.tv_sec);
+	differenceMs += (x.tv_usec - y.tv_usec) / 1000;
+
+	return differenceMs;
+}
+
+
+/*
+ * AddTimeMillis adds additionalMs milliseconds to a timeval.
+ */
+static struct timeval
+AddTimeMillis(struct timeval base, uint32 additionalMs)
+{
+	struct timeval result = {0, 0};
+
+	result.tv_sec = base.tv_sec + additionalMs / 1000;
+	result.tv_usec = base.tv_usec + (additionalMs % 1000) * 1000;
+
+	return result;
+}
+

COMMIT_HASH:b02eab7aec7873818640b371f6fe07cf87daee09|AUTHOR_NAME:Marco Slot|AUTHOR_EMAIL:marco@citusdata.com|DATE:2016-02-20 13:09:50 +0100|TITLE:Initial commit|MESSAGE:
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..a502c58
--- /dev/null
+++ b/README.md
@@ -0,0 +1,2 @@
+# pg_cron
+Run periodic jobs in PostgreSQL
